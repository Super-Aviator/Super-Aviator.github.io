{"meta":{"title":"孤独飞行员","subtitle":null,"description":"熊乾坤的博客","author":"熊乾坤","url":"https://super-aviator.github.io","root":"/"},"pages":[{"title":"","date":"2021-04-03T11:52:58.947Z","updated":"2021-04-03T11:52:58.947Z","comments":true,"path":"README.html","permalink":"https://super-aviator.github.io/README.html","excerpt":"","text":"Blog"},{"title":"时间线","date":"2018-04-02T08:49:00.000Z","updated":"2021-02-23T12:52:14.000Z","comments":true,"path":"archives/index.html","permalink":"https://super-aviator.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-04-02T13:40:08.000Z","updated":"2021-02-23T12:52:20.000Z","comments":true,"path":"categories/index.html","permalink":"https://super-aviator.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-04-02T08:49:39.000Z","updated":"2021-02-23T12:52:26.000Z","comments":true,"path":"about/index.html","permalink":"https://super-aviator.github.io/about/index.html","excerpt":"","text":"我没有考上好的大学，我没有努力开阔自己的视野，我没有在大学里静下心来学习，我不能拿到和别人一样高的薪水，我不能和群里的大佬谈笑风声，我是傻逼。 这一次，我来到一个宁静的海边乡间，沿着一堵巨大的灰墙漫步。墙外轰隆隆地翻涌着惊涛骇浪，我不时被翻墙而过的浪花打湿衣裳，但天气是如此晴朗，空气是如此清新，温暖的阳光驱散了寒意，我感到心旷神怡。-《躲进世界的角落》"},{"title":"category","date":"2021-01-23T16:12:32.000Z","updated":"2021-02-23T12:52:12.000Z","comments":true,"path":"category/index.html","permalink":"https://super-aviator.github.io/category/index.html","excerpt":"","text":""},{"title":"search","date":"2018-07-09T03:27:41.000Z","updated":"2021-02-23T12:52:08.000Z","comments":true,"path":"search/index.html","permalink":"https://super-aviator.github.io/search/index.html","excerpt":"","text":""},{"title":"tag","date":"2021-01-23T16:12:26.000Z","updated":"2021-02-23T12:52:08.000Z","comments":true,"path":"tag/index.html","permalink":"https://super-aviator.github.io/tag/index.html","excerpt":"","text":""},{"title":"标签和分类","date":"2018-04-02T08:50:05.000Z","updated":"2021-02-23T12:52:14.000Z","comments":true,"path":"tags/index.html","permalink":"https://super-aviator.github.io/tags/index.html","excerpt":"","text":""},{"title":"Algorithm","date":"2018-04-04T02:58:36.000Z","updated":"2021-02-23T12:52:22.000Z","comments":true,"path":"categories/Algorithm/index.html","permalink":"https://super-aviator.github.io/categories/Algorithm/index.html","excerpt":"","text":""},{"title":"DataBase","date":"2018-04-04T04:41:33.000Z","updated":"2021-02-23T12:52:20.000Z","comments":true,"path":"categories/DataBase/index.html","permalink":"https://super-aviator.github.io/categories/DataBase/index.html","excerpt":"","text":""},{"title":"Java","date":"2018-04-04T02:49:14.000Z","updated":"2021-02-23T12:52:20.000Z","comments":true,"path":"categories/Java/index.html","permalink":"https://super-aviator.github.io/categories/Java/index.html","excerpt":"","text":""},{"title":"NetWork","date":"2018-04-04T04:41:14.000Z","updated":"2021-02-23T12:52:20.000Z","comments":true,"path":"categories/NetWork/index.html","permalink":"https://super-aviator.github.io/categories/NetWork/index.html","excerpt":"","text":""},{"title":"Python","date":"2018-04-04T02:49:23.000Z","updated":"2021-02-23T12:52:20.000Z","comments":true,"path":"categories/Python/index.html","permalink":"https://super-aviator.github.io/categories/Python/index.html","excerpt":"","text":""},{"title":"OperationSystem","date":"2018-04-04T04:40:48.000Z","updated":"2021-02-23T12:52:22.000Z","comments":true,"path":"categories/OperationSystem/index.html","permalink":"https://super-aviator.github.io/categories/OperationSystem/index.html","excerpt":"","text":""}],"posts":[{"title":"Lambda表达式和匿名内部类中无法更改外部值的原因","slug":"Lambda表达式和匿名内部类中无法更改外部值的原因","date":"2021-04-04T16:05:18.000Z","updated":"2021-04-04T16:53:32.224Z","comments":true,"path":"2021/04/05/Lambda表达式和匿名内部类中无法更改外部值的原因/","link":"","permalink":"https://super-aviator.github.io/2021/04/05/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%AD%E6%97%A0%E6%B3%95%E6%9B%B4%E6%94%B9%E5%A4%96%E9%83%A8%E5%80%BC%E7%9A%84%E5%8E%9F%E5%9B%A0/","excerpt":"","text":"什么情况下无法编译// 在匿名内部类外更改匿名内部类中使用到的值的时候 int a = 12; Function&lt;Integer, Integer&gt; f = x -&gt; x + a; a = 14; // 在匿名内部类中更改外部的值 int a = 16; Function&lt;Integer, Integer&gt; f = x -&gt; &#123; a++; return x + a; &#125; 以上两种情况都无法通过编译，匿名内部类中使用到的外部值是无法更改的。 无法编译的原因在java7中，匿名内部类中使用的外部值必须有final修饰，java8取消了这种限制，但是通过反编译工具可以发现实际上生成的class文件中自动给匿名内部类中使用到的值加上了final，可以看作这是java8的语法糖。 // 原本的代码 int a = 4; Function&lt;Integer, Integer&gt; f = new Function&lt;Integer, Integer&gt;() &#123; @Override public Integer apply(Integer x) &#123; return x + a; &#125; &#125;; // 反编译得到的代码 final int n = 4; Function&lt;Integer, Integer&gt; function = new Function&lt;Integer, Integer&gt;()&#123; @Override public Integer apply(Integer n2) &#123; return n2 + n; &#125; &#125;; 深入探究上面的结论可以解释无法更改的原因，但是我们还无法知道为什么要这么设计，如果不这么设计会产生什么影响。 这里，我们不妨先思考以下，匿名内部类是如何得到外部的值的。假如我们手动创建一个对象，要怎样才能够把外部的值传递给这个对象呢？一般情况下只能够通过方法传递进去。但是我们调用匿名内部类的方法的时候是没有传递外部值进去的。所以只有可能是通过构造器传入的。当编译器发现我们在匿名内部类中使用到了外部值的时候会自动为匿名内部类添加构造器用于将外部的值传递进去。而通过反编译工具可以验证我们的想法。 // 源代码 import java.util.function.*; public class Main &#123; public static void main(String[] args) &#123; int a = 4; Function&lt;Integer, Integer&gt; f = new Function&lt;Integer, Integer&gt;() &#123; @Override public Integer apply(Integer x) &#123; return x + a; &#125; &#125;; System.out.println(f.apply(2)); &#125; &#125; // 反编译的 Main$1.class 的代码 /* * Decompiled with CFR 0.148. */ import java.util.function.Function; static final class Main.1 implements Function&lt;Integer, Integer&gt; &#123; final /* synthetic */ int val$a; Main.1(int n) &#123; this.val$a = n; &#125; @Override public Integer apply(Integer n) &#123; return n + this.val$a; &#125; &#125; 到这里，以构造器的方式传递值进去的想法得到了验证。我们再来看以下无法通过编译的代码 int a = 4; Function&lt;Integer, Integer&gt; f = new Function&lt;Integer, Integer&gt;() &#123; @Override public Integer apply(Integer x) &#123; return x + a; &#125; &#125;; a = 12; System.out.println(f.apply(2)); 假设这段代码能够编译，按照我们的直观理解，最后输出的应该是 14（因为 f.apply 得到的是 a+x，x 传入的是 2，而 a 被我们更改成了 12） 我们回过头看上面的构造器传递值，实际上匿名内部类中得到的值是一份拷贝，那么匿名内部类中的 a 和外部的 a 实际上是两个不同地址里的值，它们不过是值相等罢了。那么，如果以上代码得到编译，实际上得到的输出应该为 6，因为 a 为 4 的时候被当作构造参数传进去了，后面更改 a 不会对它内部造成影响。这样的结果是不符合人的直观感觉的，容易造成混乱，故设计成必须由 final 修饰。 除了以上原因之外，实际上有一个语法语义上的设计原因。匿名内部类可以看作是 java 早期对函数式的一种复杂化实现。以函数式编程的观点来看，能够使用所处环境的外部的值的函数被称为闭包。因此，以上的匿名内部类对象 f 是一个闭包，其所使用的值 a 来自于外部，被称为自由变量，在函数式编程的语义上，自由变量是不可变的。因此设计成 final 更加合理。","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Java疑惑解答","slug":"Java疑惑解答","permalink":"https://super-aviator.github.io/tags/Java%E7%96%91%E6%83%91%E8%A7%A3%E7%AD%94/"}]},{"title":"Kafka-Producer","slug":"Kafka-Producer","date":"2021-04-04T15:39:49.000Z","updated":"2021-04-04T15:50:04.409Z","comments":true,"path":"2021/04/04/Kafka-Producer/","link":"","permalink":"https://super-aviator.github.io/2021/04/04/Kafka-Producer/","excerpt":"","text":"发送方式发送既忘、同步发送、异步发送","categories":[{"name":"Middleware","slug":"Middleware","permalink":"https://super-aviator.github.io/categories/Middleware/"}],"tags":[{"name":"Kafka","slug":"Kafka","permalink":"https://super-aviator.github.io/tags/Kafka/"}]},{"title":"Windows使用","slug":"Windows使用","date":"2021-03-28T07:16:40.000Z","updated":"2021-03-28T13:42:43.342Z","comments":true,"path":"2021/03/28/Windows使用/","link":"","permalink":"https://super-aviator.github.io/2021/03/28/Windows%E4%BD%BF%E7%94%A8/","excerpt":"","text":"重置电脑在新买的二手电脑到手之后，登录了MicroSoft账户，然后本地的账户未设置密码，WIndowsHello也未设置PIN码，在电脑重启之后，我淦，发现没办法登录电脑了，使用MicroSoft账户登录时，会报网络未连接的问题，这个时候感觉只能重置电脑解决了，需要进入安全模式，然后重置电脑：首先按住shift键，然后点击 电源键-&gt;重启；重启后就自动进入了安全模式咯","categories":[{"name":"OperationSystem","slug":"OperationSystem","permalink":"https://super-aviator.github.io/categories/OperationSystem/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://super-aviator.github.io/tags/Windows/"}]},{"title":"【转载】设置Linux交换分区","slug":"【转载】设置Linux交换分区","date":"2021-03-24T15:39:15.000Z","updated":"2021-03-24T15:46:36.000Z","comments":true,"path":"2021/03/24/【转载】设置Linux交换分区/","link":"","permalink":"https://super-aviator.github.io/2021/03/24/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E8%AE%BE%E7%BD%AELinux%E4%BA%A4%E6%8D%A2%E5%88%86%E5%8C%BA/","excerpt":"","text":"设置交换分区Linux下可以创建两种类型的交换空间，一种是swap分区，一种是swap文件。前者适合有空闲的分区可以使用，后者适合于没有空的硬盘分区，硬盘的空间都已经分配完毕。例如：安装redhat的时候，你可以默认划分硬盘空间，交换区的大小事系统默认配置，当你安装完系统后需要安装一个oracle数据库，突然发出警告，交换空间不够。此刻该怎么办？ 查看交换分区的方式可以通过命令top,free命令查看当前的交换分区。也可以使用cat /proc/swaps查看交换分区 如何通过swap文件扩充交换空间的大小例如:增加1G的交换空间 dd if=/dev/zero of=/myswap bs=2k count=524288 //划分空间 mkswap /myswap //格式成交换分区的格式 swapon /myswap //使格式的swap生效 设置后，可以通过上面的命令查看时否生效。当启动系统后需要自动加载交互分区，可以在/etc/fstab文件中增加：/myswap swap swap default 0 0来让交换分区开启自动挂载。","categories":[{"name":"OperationSystem","slug":"OperationSystem","permalink":"https://super-aviator.github.io/categories/OperationSystem/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://super-aviator.github.io/tags/Linux/"}]},{"title":"SpringCloudRibbon","slug":"SpringCloudRibbon","date":"2021-03-23T13:55:37.000Z","updated":"2021-04-04T06:29:10.802Z","comments":true,"path":"2021/03/23/SpringCloudRibbon/","link":"","permalink":"https://super-aviator.github.io/2021/03/23/SpringCloudRibbon/","excerpt":"","text":"LoadBalancerAutoConfiguration自动配置源码分析@LoadBalanced注解该注解是一个标记注解，用来标识RestTemplate使用LoadBalancerClient接口去配置： /** * Annotation to mark a RestTemplate bean to be configured to use a LoadBalancerClient. * @author Spencer Gibb */ @Target(&#123; ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD &#125;) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Qualifier public @interface LoadBalanced &#123; &#125; LoadBalancerClient接口这个接口有一个具体的实现类RibbonLoadBalancerClient；该实现类的execution方法中，将具体的负载均衡交给ILoadBanlancer接口的实现类去实现： public &lt;T&gt; T execute(String serviceId, LoadBalancerRequest&lt;T&gt; request, Object hint) throws IOException &#123; ILoadBalancer loadBalancer = getLoadBalancer(serviceId); Server server = getServer(loadBalancer, hint); if (server == null) &#123; throw new IllegalStateException(&quot;No instances available for &quot; + serviceId); &#125; RibbonServer ribbonServer = new RibbonServer(serviceId, server, isSecure(server, serviceId), serverIntrospector(serviceId).getMetadata(server)); return execute(serviceId, ribbonServer, request); &#125; 上面的getLoadBalancer方法中，通过服务名找到对应的ILoadBalancer的实现类，在getServer方法中，去通过一定的策略找到服务对应的实例。 ILoadBalancer-负载均衡器负载均衡器接口中的方法如下： public interface ILoadBalancer &#123; //向负载均衡器中增加服务实例 public void addServers(List&lt;Server&gt; newServers); //通过某种策略，从负载均衡器中找出一个具体的实例 public Server chooseServer(Object key); //通知某个服务已经停止服务 public void markServerDown(Server server); @Deprecated public List&lt;Server&gt; getServerList(boolean availableOnly); //获取正常服务的列表 public List&lt;Server&gt; getReachableServers(); //获取所有已知服务的列表 public List&lt;Server&gt; getAllServers(); &#125; 该接口有如下几个实现类： AbstractLoadBalancerILoadBalancer接口的抽象实现；所有负载均衡器都是该抽象类的子类；该类中维护了枚举类为：ALL,STATUS_UP,STATUS_NOT_UP的三个服务实例列表，并增加了如下三个方法： public Server chooseServer(); 根据key查找服务，该抽象类中直接调用ILoadBalancer接口的chooseServer接口，传的key为null。 public abstract List&lt; Server&gt;getServerList(ServerGroup serverGroup); 查找某个服务分组下的所有服务实例。 public abstract LoadBalancerStats getLoadBalancerStats(); 获取负载均衡器的详细信息。包含了统计数据和负载均衡器运行情况。 BaseLoadBalancer 该类是负载均衡器最基本的实现类；该类中维护了一个包含所有实例和正常服务的实例，并使用可重入锁进行同步： @Monitor(name = PREFIX + &quot;AllServerList&quot;, type = DataSourceType.INFORMATIONAL protected volatile List&lt;Server&gt; allServerList = Collections .synchronizedList(new ArrayList&lt;Server&gt;()); @Monitor(name = PREFIX + &quot;UpServerList&quot;, type = DataSourceType.INFORMATIONAL) protected volatile List&lt;Server&gt; upServerList = Collections .synchronizedList(new ArrayList&lt;Server&gt;()); protected ReadWriteLock allServerLock = new ReentrantReadWriteLock(); protected ReadWriteLock upServerLock = new ReentrantReadWriteLock(); 该类定义了判断服务是否正常的IPing对象,在BaseLoadBalancer中默认为null，需要再构造参数中注入。 定义了IPing对象的执行策略IPingStrategy，在BaseLoadBalancer中默认使用静态内部类SerialPingStrategy实现。该实现使用线性遍历的方式对服务进行检测。该策略在IPing实现速度不理想或者服务列表过大时会影响服务性能，可以实现IPingStrategy接口去扩展。 定义了负载均衡策略IRule对象。在BaseLoadBalancer类的chooseServer方法中，使用的是IRule接口的choose方法去实现。默认的IRule实现为RoundRobinRule，该实现类会对服务进行轮训操作，轮训失败重试的次数最多为10次： public Server choose(ILoadBalancer lb, Object key) &#123; if (lb == null) &#123; log.warn(&quot;no load balancer&quot;); return null; &#125; Server server = null; int count = 0; while (server == null &amp;&amp; count++ &lt; 10) &#123; List&lt;Server&gt; reachableServers = lb.getReachableServers(); List&lt;Server&gt; allServers = lb.getAllServers(); int upCount = reachableServers.size(); int serverCount = allServers.size(); if ((upCount == 0) || (serverCount == 0)) &#123; log.warn(&quot;No up servers available from load balancer: &quot; + lb); return null; &#125; int nextServerIndex = incrementAndGetModulo(serverCount); server = allServers.get(nextServerIndex); if (server == null) &#123; /* Transient. */ Thread.yield(); continue; &#125; if (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123; return (server); &#125; // Next. server = null; &#125; if (count &gt;= 10) &#123; log.warn(&quot;No available alive servers after 10 tries from load balancer: &quot; + lb); &#125; return server; &#125; 在BaseLoadBalancer构造函数中启动了一个定时任务，用于检查Server是否健康，默认为10秒执行一次。 依次实现了chooseServer、markServerDown、getReachableServers、getAllservers方法。 DynamicServerListLoadBalancer-动态服务列表负载均衡器DynamicServerListLoadBalancer继承自BaseLoadBalancer类，他是对基础负载均衡器的扩展，在该负载均衡器中，提供了动态更新服务实例的功能。通知他还具备对服务实例进行过滤的功能，可以通过过滤器来选择性的获取一批实例清单。 该负载均衡器中还定义了ServerListUpdater接口用于定义实现服务的更新，有默认两个实现类： PollingServerListUpdater 默认的更新策略，通过定时任务的方式对服务列表进行更新;有两个重要参数initialDelayMs和refreshIntervalMs，前者表示在实例初始化之后延迟为多少秒后开始执行，默认为1000毫秒，后者表示每隔多少毫秒周期性的执行，默认为30*1000毫秒； EurekaNotificationServerListUpdater 使用Eureka的时间通知的方式对服务列表进行更新； 在通过上面的方式获取到服务列表之后，这里又使用ServerListFilter过滤器对服务实例进行进一步过滤，包括AbstracServerListFilter、ZoneAfffinityServerListFilter、ZonePreferenceServerListFilter、DefaultNIWSServerListFilter、ServerListSubsetFilter；除了ZonePreferenceServerListFilter的实现是SpringCloudRibbon中新增的，其余都是NetFlexRibbon中原生实现类。 AbstracServerListFilter 基础的过滤器，定义了负载均衡器状态对象LoadBalancerStats。 ZoneAfffinityServerListFilter 该过滤器基于“区域感知”的方式实现服务实例的过滤。他会更具提供服务的实例所处的区域与消费者自身所处的的区域进行比较，过滤掉不属于同一区域的实例。 DefaultNIWSServerListFilter 该过滤器完全继承自ZoneAfffinityServerListFilter过滤器，是默认的NIWS（Netflex Internal Web Service）过滤器。 ServerListSubsetFilter 该过滤器也继承自ZoneAfffinityServerListFilter，适用于拥有大规模服务器集群（上百或者更多）的系统。该过滤器通过区域感知获取服务列表之后，会剔除不健康的实例，然后保存剩下的实例集合。 ZonePreferenceServerListFilter SpringCloud新增的过滤器，在Eureka整合Ribbon时默认的过滤器。实现了将通过配置或者Eureka实例元数据所属的区域来过滤出同区域的服务实例。该过滤器也继承自ZoneAffinityServerListFilter，在通过父类获取到区域感知的实例集合之后，然后遍历集合，取出根据消费者配置预设的区域Zone来进行过滤。如果过滤后结果为空，则直接返回父类获取的结果，否则返回过滤后的结果。 NoOpLoadBalancerZoneAwareLoadBalancer -Ribbon默认的负载均衡器ZoneAwareLoadBalancer是对DynamicServerListLoadBalancer的扩展，在DynamicServerListLoadBalancer中，依旧使用的BaseLoadBalancer中使用的线性轮询的方式获取服务实例，这种算法没有Zone的概念，所以会周期性的产生跨区域访问的问题，产生更高的延迟，所以在多区域部署的情况下一定会有性能问题。 ZoneAwareLoadBalancer负载均衡器默认使用的是ZoneAvoidanceRule负载均衡策略! IRule-负载均衡策略Ribbon中定义了特别多的负载均衡策略，一起来crazy study。 20210329221454.png AbstractLoadBalancerRule-抽象的负载均衡策略该实现类类中定义了一个ILoadBalancer对象，该对象能够获取到一些负载均衡中维护的信息来作为分配依据。 RandomRule-随机选择策略该负载均衡策略为随机获取一个实例进行访问，在具体的实现中，通过ILoadBalancer获取upList和allList实例列表，并通过rand.nextInt来作为upList下标获取具体实例。具体选择逻辑在一个while(server==null)中，可能会存在死循环获取不到实例的Bug。 RoundRobinRule-线性轮询策略该策略实现了线性轮询个的方式一次选择每个服务实例的功能。在实现中使用了count计数器，当尝试10次依旧选择不到server时，就会结束尝试，并打印警告信息。 RetryRule-重试策略该策略实现了一个具备重试机制的实例选择功能。在内部还定义了一个IRule对象，默认使用了RoundRobinRule实例。在开始选择实例时，记录时间戳timeStamp，然后使用timeStamp+maxRetryMillis参数（默认为500）作为阈值重复进行选择，期间如果选择到实例，则返回，否则当时间超过时，则返回null。 WeightedResponseTimeRule- 响应时间权重策略 定时任务：在策略初始化时，会默认启动一个定时任务，为每个服务计算权重，默认每隔30秒计算一次。 权重计算：根据算法计算服务的 实例选择：根据算法分析出的权重选择一个实例 ClientConfigEnbaledRoundRibbonRule该策略与RoundRibbonRule在实现上类似，一般不直接使用，他存在的目的为：一些高级的策略可以使用该类作为父类，当一些策略无法实施时，可以选择该父类的实现作为保障。 BestAvailableRule-最空闲实例策略该策略继承自ClientConfigEnbaledRoundRibbonRule，实现了注入负载均衡器的统计对象LoadBalancerStats。然后通过该对象获取请求数量最小的实例（即最空闲的实例） 并返回，注意，如果LoadBalancerStats对象无法注入，则该策略无法执行，就会使用父类的策略 PredicateBasedRule这是一个抽象策略，继承自ClientConfigEnbaledRoundRibbonRule，是一个基于Predicate实现的接口，该抽象策略定义了大致选择实例的方式为：先使用Predicate来过滤掉一些实例，然后再使用轮询的方式随机选择一个实例进行访问。下面几种策略都是Predicate的具体实现。 AvailabilityFilterRule使用AvailabilityPredicate对实例进行过滤，具体果过滤策略如下： 是否故障，即断路器是否生效已断开。 实例的并发数是否大于阈值，默认为2的32次方-1，可通过参数 &lt; clientName&gt;.&lt; nameSpace&gt;.ActiveConnectionsLimit参数来修改。 上面两个条件有一个满足就返回false，表示该节点可能存在故障。都不满足则返回true。 同时在该策略中，对choose方法也做了改进：它并没有像在父类中那样，先遍历所有的节点进行过滤，然后在过滤后的集合中选择实例。而是先以线性的方式选择一个实例， 接着用过滤条件来判断该实例是否满足要求，若满足就直接使用该实例，若不满足要求就再选择下一个实例，并检查是否满足要求，如此循环进行，当这个过程重复了10次还是没有找到符合要求的实例，就采用父类的实现方案。 简单地说，该策略通过线性抽样的方式直接尝试寻找可用且较空闲的实例来使用，优化了父类每次都要遍历所有实例的开销。 ZoneAvoidanceRule该策略也是PredicateBaseRule的实现类。使用了组合条件对服务进行过滤，优先使用ZoneAvoidancePredicate作为主过滤条件，然后使用AvailabilityPredicate作为次过滤条件。具体实现逻辑如下： 使用主过滤条件对所有实例过滤并返回过滤后的实例清单。 依次使用次过滤条件列表中的过滤条件对主过滤条件的结果进行过滤。 每次过滤之后(包括主过滤条件和次过滤条件)，都需要判断下面两个条件，只要有一个符合就不再进行过滤，将当前结果返回供线性轮询算法选择: 过滤后的实例总数&gt;=最小过滤实例数(minimalFilteredServers`, 默认为1)。 .过滤后的实例比例&gt;最小过滤百分比(minimalFilteredPercentage, 默认为0)。 ZoneAvoidanceRule负载均衡策略如下： TODORibbon自动化配置使用配置文件进行配置在使用Ribbon时，可也以通过配置文件的方式对ribbon进行配置，格式为：&lt;clientName&gt;.ribbon.&lt;key&gt;=&lt;value&gt;，例如：springbootlearn.ribbon.NFLoadBalancerPingClassName=cong.netflex.loadbalancer.PingUrl 具体的key定义在PropertiesFactory中： public PropertiesFactory() &#123; this.classToProperty.put(ILoadBalancer.class, &quot;NFLoadBalancerClassName&quot;); this.classToProperty.put(IPing.class, &quot;NFLoadBalancerPingClassName&quot;); this.classToProperty.put(IRule.class, &quot;NFLoadBalancerRuleClassName&quot;); this.classToProperty.put(ServerList.class, &quot;NIWSServerListClassName&quot;); this.classToProperty.put(ServerListFilter.class, &quot;NIWSServerListFilterClassName&quot;); &#125; 替换默认配置通过自定义Bean替换可以在配置类中增加自定的bean来替换掉默认的配置： @Configuration public class RibbonConfiguration &#123; @Bean public PingUrl getIPing()&#123; return new PingUrl(); &#125; &#125; 使用@RibbonClient替换也可以使用@RibbinClient来对单个服务进行配置： @RibbonClient(name = &quot;microservice-springbootlearn&quot;, configuration = SpringBootLearnConfiguration.class) public class MyRibbonConfiguration &#123; &#125; EurekaClient中增加区域元数据在Eureka客户端中使用下面的元数据配置，就可以让客户端带有区域标识：Eureka.instance.metadataMap.zone=shanghai 添加重试功能SpringCloudRibbon中同时还整合了SpringRetry模块，通过如下的配置就可以对服务进行重试功能： #配置服务的ribbon超时属性,该配置只有在Feign+Hystrix中才生效 microservice-eurekaclient: ribbon: connectTimeout: 1000 #请求链接的超时时间 readTimeout: 1000 #请求处理的超时时间 okToRetryOnAllOperations: true #是否对所有失败都进行重试 maxAutoRetriesNextServer: 0 #重试失败时的切换实例的次数 maxAutoRetries: 2 #相同实例重试的次数 hystrix: command: # default的配置所有熔断方法都生效 default: execution: isolation: thread: timeoutInMilliseconds: 10000 #设置断路器的超时时间，默认为1000毫秒 值得注意的是，如果想要重试生效，必须将Hystrix的超时时间设置为比Ribbon超时时间大，否则请求会直接熔断，无法进行重试！ LoadBalancerFeignClient接口LoadBalancerInterceptor拦截器","categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://super-aviator.github.io/categories/MicroService/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://super-aviator.github.io/tags/SpringCloud/"},{"name":"Ribbon","slug":"Ribbon","permalink":"https://super-aviator.github.io/tags/Ribbon/"}]},{"title":"SpringCloudFeign","slug":"SpringCloudFeign","date":"2021-03-23T13:54:30.000Z","updated":"2021-03-24T02:45:30.000Z","comments":true,"path":"2021/03/23/SpringCloudFeign/","link":"","permalink":"https://super-aviator.github.io/2021/03/23/SpringCloudFeign/","excerpt":"","text":"","categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://super-aviator.github.io/categories/MicroService/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://super-aviator.github.io/tags/SpringCloud/"},{"name":"OpenFeign","slug":"OpenFeign","permalink":"https://super-aviator.github.io/tags/OpenFeign/"}]},{"title":"SpringCloudHystrix","slug":"Spring-Cloud-Hystrix熔断机制","date":"2021-03-22T15:02:56.000Z","updated":"2021-03-23T13:54:44.000Z","comments":true,"path":"2021/03/22/Spring-Cloud-Hystrix熔断机制/","link":"","permalink":"https://super-aviator.github.io/2021/03/22/Spring-Cloud-Hystrix%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6/","excerpt":"","text":"断路器原理及配置BulkHead-仓壁隔离信号量","categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://super-aviator.github.io/categories/MicroService/"}],"tags":[{"name":"Hystrix","slug":"Hystrix","permalink":"https://super-aviator.github.io/tags/Hystrix/"}]},{"title":"IDEA修改配置","slug":"IDEA修改配置","date":"2021-03-22T09:01:08.000Z","updated":"2021-03-24T09:21:40.000Z","comments":true,"path":"2021/03/22/IDEA修改配置/","link":"","permalink":"https://super-aviator.github.io/2021/03/22/IDEA%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE/","excerpt":"","text":"CodeStyle 控制注释是否顶格对齐 JavaDoc注释是否单行：","categories":[],"tags":[]},{"title":"IDEA项目部署到Docker之一顿百度加谷歌","slug":"IDEA项目部署到Docker之一顿百度加谷歌","date":"2021-03-19T14:28:00.000Z","updated":"2021-04-04T08:00:21.856Z","comments":true,"path":"2021/03/19/IDEA项目部署到Docker之一顿百度加谷歌/","link":"","permalink":"https://super-aviator.github.io/2021/03/19/IDEA%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0Docker%E4%B9%8B%E4%B8%80%E9%A1%BF%E7%99%BE%E5%BA%A6%E5%8A%A0%E8%B0%B7%E6%AD%8C/","excerpt":"","text":"我熊老大，今天开始再次学微服务了，想着按着晚上的教程，在阿里云和腾讯云上搭建一个Eureka集群方便学习下。冲了！ 给Docker开放远程端口在IDEA中需要可以远程访问Docker，所以需要给Docker开放下远程端口，命令如下： vim /usr/lib/systemd/system/docker.service 然后在配置文件中，新增如下配置 ExecStart=中追加-H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock：修改后保存文件，然后通知docker服务做出的修改systemctl daemon-reload重启docker服务service docker restart 注意：如果老版本的dokcer修改此配置后，无法启动或者只支持远程连接，命令行无法使用，则可能需要升级docker至最新的版本即可解决，血的教训。（PS：升级之后之前的容器还在不会丢，不要慌，不然会显得很菜很伞兵T_T） 升级Docker1、查看系统要求Docker 要求 CentOS 系统的内核版本高于 3.10 ,查看CentOS的内核版本。 uname -a 2、删除旧版本yum remove docker docker-common docker-selinux docker-engine 3、安装需要的软件包yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 4、设置Docker yum源sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 5、查看所有仓库中所有docker版本可以查看所有仓库中所有docker版本,并选择特定的版本安装。 yum list docker-ce --showduplicates | sort -r 6、安装dockersudo yum install docker-ce 由于repo中默认只开启stable仓库，故这里安装的是最新稳18.03.0.ce-1.el7.centos。 如果要安装特定版本： sudo yum install docker-ce-18.06.1.ce 7、启动设置为开机启动systemctl enable docker 启动systemctl start docker 查看启动状态systemctl status docker 查看版本docker version 防火墙端口开放因为使用的云服务器，所以需要注意将项目映射的端口和主机端口加入白名单才能访问： 编写Dockerfile文件然后需要再springboot项目的更目录中新建dockerfile文件： # Docker image for springboot application # VERSION 0.0.1 # Author: bolingcavalry ### 基础镜像，使用alpine操作系统，openjkd使用8u201 FROM openjdk:8u201-jdk-alpine3.9 #作者 MAINTAINER BolingCavalry &lt;2372389705@qq.com&gt; #系统编码 ENV LANG=C.UTF-8 LC_ALL=C.UTF-8 #声明一个挂载点，容器内此路径会对应宿主机的某个文件夹 VOLUME /tmp #应用构建成功后的jar文件被复制到镜像内，名字也改成了app.jar ADD target/*.jar app.jar #启动容器时的进程 ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] #暴露8080端口 EXPOSE 8080 IDEA配置在IDEA中，需要下载Docker插件，之后连接上远程的Docker： 接下来需要在idea中新增一个启动配置： 最下面的maven命令为：clean package -U -DskipTests，打错了。。 部署项目然后点击启动，即可完成部署： 首次部署时需要拉去镜像，比较慢，后面就快了。","categories":[{"name":"Other","slug":"Other","permalink":"https://super-aviator.github.io/categories/Other/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://super-aviator.github.io/tags/Docker/"}]},{"title":"Kafka-Broker","slug":"Kafka-Broker","date":"2021-03-14T07:43:30.000Z","updated":"2021-04-04T07:57:08.351Z","comments":true,"path":"2021/03/14/Kafka-Broker/","link":"","permalink":"https://super-aviator.github.io/2021/03/14/Kafka-Broker/","excerpt":"","text":"常用命令主题管理：kafka-topic.sh创建分区– createbin/kafka-topics.sh \\ --zookeeper localhost:2181 \\ --create \\ --topic topic-create \\ --partitions 4 \\ --replication-factor 2 \\ --config max.message.bytes=10000 \\ --config cleanup.policy=compact \\ --if-not-exists \\ 执行命令后，会在log.dir和log.dirs配置的目录下创建相应主题的分区。默认情况下这个目录为/tmp/kafka-logs/ topic长度不能超过249； 可以将创建topic的脚本在代码中使用 kafka.topic.TopicCommand.main方法传递参数去执行。 查看分区策略 –describebin/kafka-topics.sh \\ --zookeeper localhost:2181 \\ --describe \\ --topic topic-create \\ --under-replicated-partitions \\ 如果不使用–topic指定主题名称，则会展示所有主题的分区策略；--under-replicated-partitions参数表示只显示有失效副本的分区，即ISR分区； 查看主题列表–listbin/kafka-topics.sh \\ --zookeeper localhost:2181 \\ --list 修改分区 –alterbin/kafka-topics.sh \\ --zookeeper 101.37.172.37:2181 \\ --alter \\ --topic topic-create \\ --config max.message.bytes=20000 \\ --delete-config max.message.bytes \\ --partitions 5 \\ --if-exists \\ 使用–if-exists参数可以防止topic不存在时报错。 配合–config参数可以修改topic的配置。 使用–partitions参数可以修改主题分区，目前kafka只支持增加分区而不支持减少分区，否则会报出invalidPartitionException异常。 使用–delete-config参数可以删除手动增加的配置，从而使用默认的配置。 删除主题 –deletebin/kafka-topics.sh \\ --zookeeper 101.37.172.37:2181 \\ --delete \\ --topic test1 \\ --if-exists \\ 此配置和broker的 delete.topic.enable有关，如果为false，则会忽略改删除操作，为true才会进行删除，默认为true。 删除命令不支持删除内部主题 __consumer_offsets和 __transaction_state。 使用 --if-exists参数用来忽略topic不存在时产生的异常。 配置管理：kafka-configs.sh分区管理在创建主题和分区的时候，该分区及其副本会尽可能均匀分布到Kafka集群的各个broker节点上，对应的leader副本的分配也比较均匀，例如一个主题有三个分区，那个三个分区的leader副本都会均匀的分配到各个broker中去。 针对同一个分区，一个broker节点中不可能出现它的多个副本(如果创建主题时副本数多于broker数，则会报错：InvalidReplicationFactorException: Replication factor: 4 larger than available brokers: )，即Kafka集群中的一个broker中最多只能有它的一个副本，我们可以将leader服务所在的broker节点叫做分区的leader节点，而follower副本所在的节点叫做 分区的follower节点。 优先副本当某个broker宕机或者崩溃之后，分区的leader节点发送故障时，其中一个follower节点就会成为新的leade节点，这样就会导致集群的负载不均衡，从而影响集群的健壮性和稳定性，当原来的leader节点恢复之后重新加入集群，也只能作为新的follower节点不能再对外提供服务。比如主题topic-create的leader节点分布如下： Topic: topic-create PartitionCount: 2 ReplicationFactor: 2 Configs: Topic: topic-create Partition: 0 Leader: 1 Replicas: 1,2 Isr: 1,2 Topic: topic-create Partition: 1 Leader: 2 Replicas: 2,1 Isr: 2,1 当将borker为2的节点重启，那么主题topic-createleader新的节点分布如下： Topic: topic-create PartitionCount: 2 ReplicationFactor: 2 Configs: Topic: topic-create Partition: 0 Leader: 1 Replicas: 1,2 Isr: 1,2 Topic: topic-create Partition: 1 Leader: 1 Replicas: 2,1 Isr: 2,1 此时节点1的负载会变高，集群的原本均衡的负载变成了失衡。 为了有效的治理负载失衡的情况，Kafka引入了 优先副本（preferred replica）的概念。即： 所谓 的优先副本是指在 AR 集合列表中的第一个副本。 比如上面主题 topic-create 中分区0 的AR 集合列表（replicas）为［1,2］,那么分区0的优先副本即为1。理想情况下，优先副本就是该分区的leader副本，所以也可以称之为 preferred leader。 Kafka要确保所有主题的优先副本在 Kafka 集群中均匀分布，这样就保证了所有分区的leader均衡分布。如果 leader 分布过于集中，就会造成集群负载不均衡。 所谓的优先副本的选举是指通过一定的方式促使优先副本选举为leader副本，以此来促进集群的负载均衡，这一行为也称之为“分区平衡” 可以使用配置：auto.leader.rebalance.enable来控制是否自动进行分区平衡，也可以手动使用 kafka-perferred-replica-election.sh脚本手动进行分区平衡。 日志索引与清理日志索引文件Kafka中一个分区对应kafka-logs文件中的一个文件夹即对应一个日志（Log），为了防止日志过大，一个日志对一个多个日志分段（LogSegment），每个日志分段在文件夹中最少包含一个日志文件.log和两个索引文件：偏移量索引文件.index和时间戳索引文件.timeindex，还包括另外的其他文件事务索引文件等。 日志是顺序写入的，只有最后一个日志分段能够写入，之前的日志分段都是无法写入的；每个日志分段都有一个基准偏移量baseOffset，用来表示当前LogSegment中第一条消息的偏移量。偏移量是一个64位的长整型，日志文件都是根据偏移量命名的，长度为20位。 kafka中的索引文件都是以稀疏索引的方式构建的，并不保证每条数据都有对应的缩影项，而是每当写入一定量（broker的log.index.interval.bytes配置指定，默认为4kb）的消息时，偏移量缩影文件和时间戳缩影文件分别增加一个偏移量索引项和时间戳索引项，增大或减少log.index.interval.bytes的值能够增大或减小索引项的密度。 当日志分段满足如下条件时，会新建一个日志分段： //TODO 偏移量和时间戳都是单调递增存储的，查询指定偏移量时，使用二分法来快速定位偏移量的位置，如果不在文件中，则返回小于指定偏移量的最大偏移量。时间戳查询也是二分法查找大不大于该时间的最大偏移量，而要找到对应的物理位置还需要根据偏移量再次定位。 偏移量索引一个索引项占用8字节，分为relativeOffset相对偏移量占用4字节和position物理地址占用4字节。四字节为Integer.MAX_VALUE。 时间戳索引日志清理kafka一个分区副本就相当于一个Log，而一个Log又分为多个日志分段，日志清理分为两个策略： 日志删除（Log Retention）按照一定的保留策略直接删除不符合条件的日志分段。 日志压缩（Log Compaction）针对每个消息的Key进行压缩，相同的Key不同Value的日志只保留最后一个版本。 日志清理的策略可以通过log.cleanup.policy配置，默认为delete，也可以手动修改为compact或者delete,compact同时，需要配合log.cleaner.enable配置为true；注意：日志清理也可以配置为主题级别。 日志删除kafka中有个专门检测和删除不符合保留条件的日志分段文件的任务。这个任务的运行周期可以通过log.retention.check.interval.ms配置，默认为300000，即5分钟。默认的保留策略有三种：基于时间的保留策略、基于日志大小的保留策略、基于日志起始偏移量的保留策略。 基于时间的日志保留策略kafka通过broker配置的RetentionMs来确定日志是否需要被删除，通过log.retention.ms、 log.retention.minutes和log.retention.hours三个参数指定，有限度从高到低；默认情况下只配置了log.retention.hours参数， 其值为168，故默认情况下日志分段文件的保留时间为7天。 查找过期的日志分段文件，并不是简单地根据日志分段的最近修改时间 lastModifiedTime来计算的 ， 而是根据日志分段中最大的时间戳 largestTimeStamp 来计算的。因为日志分段的 lastModifiedTime 可以被有意或无意地修改，比如执行了 touch 操作，或者分区副本进行了重新分配， lastModifiedTime 并不能真实地反映出日志分段在磁盘的保留时间 。要获取日志分段中的最大时间戳 largestTimeStamp的值，首先要查询该日志分段所对应的时间戳索引文件，查找时间戳索引文件中最后一条索引项，若最后一条索引项的时间戳字段值大于0，则取其值，否则才设置为最近修改时间 lastModifiedTime 。若待删除的日志分段的总数等于该日志文件中所有的日志分段的数量，那么说明所有的日志分段都己过期， 但该日志文件中还要有一个日志分段用于接收消息的写入，即必须要保证有一个活跃的日志分段 activeSegment，在此种情况下，会先切分出一个新的日志分段作为activeSegment，然后执行删除操作。 删除日志分段时，首先会从Log对象中所维护日志分段的跳跃表中移除待删除的日志分段，以保证没有线程对这些日志分段进行读取操作 。 然后将日志分段所对应的所有文件添加上”.deleted”的后缀（当然也包括对应的索引文件）。最后交由一个以“delete-file”命名的延迟任务来删除这些以”.deleted “为后缀的文件，这个任务的延迟执行时间可以通过file.delete.delay.ms参数来调配，此参数的默认值为60000， 即1分钟。 基于日志大小的日志保留策略日志删除任务会检查当前日志的大小是否超过设定的阔值（retentionSize）来寻找可删除的日志分段的文件集合（deletableSegments），retentionSize可以通过broker端参数log .retention.bytes 来配置，默认值为-1，表示无穷大。注意log.retention.bytes配置的是Log中所有日志文件的总大小，而不是单个日志分段的大小。单个日志分段的大小由broker端参数log.segment.bytes 来限制，默认值为1073741824, 即1GB 。 基于日志大小的保留策略 基于日志大小的保留策略与基于时间的保留策略类似，首先计算日志文件的总大小 size和retentionSize的差值diff，即计算需要删除的日志总大小，然后从日志文件中的第一个日志分段开始进行查找可删除的日志分段的文件集合deletableSegments。查找出deletableSegments之后就执行删除操作。 基于日志起始偏移量的保留策略一般情况下，日志文件的起始偏移量logStartOffset等于第一个日志分段的baseOffset，但这并不是绝对的， logStartOffset的值可以通过DeleteRecordsRequest请求（比如使用 KafkaAdminClient 的 deleteR巳cords()方法、使用kafka-delete-records . sh脚本）、日志的清理和截断等操作进行修改。 基于日志起始偏移量的保留策略的判断依据是某日志分段的下一个日志分段的起始偏移量baseOffset 是否小于等于 logStartOffset，若是，则可以删除此日志分段假设 logStartOffset 等于 25，日志分段1的起始偏移量为0，日志分段2的起始偏移量为11 ，日志分段3的起始偏移量为23，通过如下动作收集可删除的日志分段的文件集合deletableSegments : (1）从头开始遍历每个日志分段，日志分段1的下一个日志分段的起始偏移量为 1 1 ，小于 logStartOffset的大小，将日志分段1加入deletableSegments 。 (2）日志分段2的下一个日志偏移量的起始偏移量为23，也小于logStartOffset的大小，将日志分段2页加入deletableSegments。 (3）日志分段3的下一个日志偏移量在logStartOffset的右侧，故从日志分段3开始的所有日志分段都不会加入deletableSegments。","categories":[{"name":"Middleware","slug":"Middleware","permalink":"https://super-aviator.github.io/categories/Middleware/"}],"tags":[{"name":"Kafka","slug":"Kafka","permalink":"https://super-aviator.github.io/tags/Kafka/"}]},{"title":"Java并发工具","slug":"Java并发工具","date":"2021-03-09T14:30:04.000Z","updated":"2021-04-04T16:04:34.579Z","comments":true,"path":"2021/03/09/Java并发工具/","link":"","permalink":"https://super-aviator.github.io/2021/03/09/Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7/","excerpt":"","text":"Future、CompletableFutureThreadLocal-线程本地变量本质： 在Thread类中，会自带一个ThreadLocalMap（定制化的一种HashMap）类型的threadLocals和InheritableThreadLocals属性，在ThreadLocal中set进去的值并不是放在ThreadLocal中，而是保存在Thread类自己的threadLocals中，同样get获取的值也只是从调用的线程中的threadLocals中去取值，而ThreadLocal只是一个工具壳。 ThreadLocal被设计成map结构，表示一个线程可以关联多个ThreadLocal变量，因ThreadLocalMap中的key是ThreadLocal的this指针。 方法源码 void set(T value) set方法在第一次调用时，会调用crateMap方法初始化Map public void set(T value) &#123; //获取当前线程 Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) //如果已经初始化过，则直接set即可 map.set(this, value); else //表示第一次调用，初始化threadLocals变量 createMap(t, value); &#125; createMap方法如下： void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; getMap方法则直接获取的当前线程的threadLocals变量： ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; T get() get方法如果发现当前线程有初始化过threadLocals变量，则会从中获取对应ThreadLocal的值： public T get() &#123; //获取当前线程 Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; 如果发现未初始化threadLocals，则会初始化一次，value为null private T setInitialValue() &#123; //这里value直接返回null T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) //如果当前现线程的threadLocals不为空，则直接把value设置为null map.set(this, value); else //否则初始化threadLocals变量，value为null createMap(t, value); return value; &#125; void remove() remove方法判断当前线程的threadLocals变量不为空时，则删除对应的ThreadLocal变量。 public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); &#125; 总结： 在每个线程内部都有一个名为threadLocals的成员变量，该变量的类型为 HashMap，其中key为我们定义的ThreadLocal变量的this引用，value则为我们使用set方法设置的值。每个线程的本地变量存放在线程自己的内存变量threadLocals中，如果当前线程一直不消亡，那么这些本地变量会一直存在，所以可能会造成内存溢出，因此使用完毕后要记得调用ThreadLocal的remove 方法删除对应线程的ThreadLocals中的本地变量。在ThreadLocalRandom中，也是借鉴ThreadLocal的思想实现的。 支持继承的InheritableThreadLocalThreadLocal是不支持继承的，即再父线程中设置了ThreadLocal变量，然后再子线程中则无法获取到父线程中设置到的值，这时，需要使用InheritableThreadLocal来替换掉ThreadLcaol。 InheritableThreadLocal继承自ThreadLocal，并重写了三个方法： public class InheritableThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; &#123; protected T childValue(T parentValue) &#123; return parentValue; &#125; ThreadLocalMap getMap(Thread t) &#123; return t.inheritableThreadLocals; &#125; void createMap(Thread t, T firstValue) &#123; t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue); &#125; &#125; getMap和createMap将threadLocals变量替换为使用inheritableThreadLocals变量，后续get、set方法使用的不再是threadLocals而是inheritableThreadLocals； 具体的数据拷贝是在创建Thread对象的时候传递进去的： public Thread() &#123; init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0); &#125; private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) &#123; if (name == null) &#123; throw new NullPointerException(&quot;name cannot be null&quot;); &#125; this.name = name; Thread parent = currentThread(); this.group = g; this.daemon = parent.isDaemon(); //线程优先级也是继承的 this.priority = parent.getPriority(); this.target = target; setPriority(priority); //这里执行拷贝操作 if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); /* Stash the specified stack size in case the VM cares */ this.stackSize = stackSize; /* Set thread ID */ tid = nextThreadID(); &#125; static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) &#123; return new ThreadLocalMap(parentMap); &#125; private ThreadLocalMap(ThreadLocalMap parentMap) &#123; Entry[] parentTable = parentMap.table; int len = parentTable.length; setThreshold(len); table = new Entry[len]; for (int j = 0; j &lt; len; j++) &#123; Entry e = parentTable[j]; if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get(); if (key != null) &#123; //这里拷贝的过程中调用了重载的方法，返回的是e.value Object value = key.childValue(e.value); Entry c = new Entry(key, value); int h = key.threadLocalHashCode &amp; (len - 1); while (table[h] != null) h = nextIndex(h, len); table[h] = c; size++; &#125; &#125; &#125; &#125; ReentrantLock-可重入锁可重入锁用于替代synchronized关键字，在性能方面，JDK5及之前性能远由于synchronized，但是JDK6对synchronized做了优化，性能差距并不大。同时在使用上也更加灵活可重入锁主要提供了以下特性： 中断响应在尝试获取到锁时，如果调用 lockInterruptibly()方法，即可在等待锁的过程中可以响应中断，当产生死锁的线程被中断时，也可以避免死锁的发送。调用 isHeldByCurrentThread()方法可以检测所是否被当前线程获取的： ReentrantLock lock=new ReentrantLock(); try&#123; lock.lockInterruptibly(); if(lock.isHeldByCurrentThread())&#123; lock.unlock(); &#125; &#125;catch(Exception e)&#123; &#125; 锁申请等待限时 {java}调用 tryLock(long,TimeUnit)方法，可以设置等待所得超时时间，并返回true或者false表示是否成功获取到锁。也可以有效避免死锁。 同样也可以调用不带参数的tryLock方法，此方法在获取到锁时返回true，否则立即返回false，不会进行锁等待，这种方式不会引起锁等待，也不会产生死锁。 公平锁正常情况下，锁的获取都是非公平的，在使用可重入锁时，可以在构造参数中指定锁是公平的，当fair为true时，标识创建的锁为公平锁: public ReentrantLock(boolean fair); 公平锁需要系统维护一个有序的等待队列，所以成本比较高，性能非常低下，因此默认情况下所示非公平的。 可重入锁的实现上主要是三个要素： 原子状态：使用CAS操作存储当前锁状态，判断锁是否已被其他线程拥有 等待队列：如果没有请求到锁，就进入等待队列，如果锁被释放，则从对待队列中唤醒一个线程，继续工作 阻塞原语：park()和unpark()方法用来挂起和回复线程，没有得到锁的线程会被挂起 Condition与Object对象的wait和notify方法类似，前者与synchronized一起使用，而Condition则与ReentrantLock一起使用。ReentrantLock中的newCondision方法则可以获取一个与之关联的Condition对象，一个锁可以获取多个Condition对象，但是由于必须获取到锁才能调用对应的方法，所以同一时刻只能有一个Condition在使用咯，Condition具体包含如下几个常用方法： await():是当前线程等待，同时释放当前锁，其他线程调用singnal或者singnalAll方法后会重新获得锁并继续执行，当被中断时也能跳出等待 awaitUnInterruptibly():等待过程中不会响应中断 sigal()：唤醒一个等待中的线程 sigleAll()：唤醒所有等待的线程 注意： 此方法和那啥wait、notify方法一样，当前线程也必须首先获取可重入锁，然后才能调用相应的await和singal方法。 同时，再signal或者signalAll方法调用后，行线程需要重新获取锁才能运行，否则依旧无法匀巡（所以在调用signal方法之后，需要立即调用unlock方法将锁释放，让唤醒的线程获得锁才能执行） Semaphore-信号量Semaphore是更加高级的工具，在重入锁ReentrantLock或者synchronized中，一次只允许一个线程进入临界区，但是Semaphore则允许一次有多个线程进入临界区。构造函数如下： public Semaphore(int permits); public Semaphore(int permits, boolean fair); 在构造信号量时，需要指定准入数，即同时能有多少个线程获得许可，如果没有获得信号量，则会进行等待或者被中断。主要方法如下： public void acquire() throws InterruptedException; public void acquire(int permits) throws InterruptedException; public void acquireUninterruptibly(); public void acquireUninterruptibly(int permits) public boolean tryAcquire(); public boolean tryAcquire(long timeout, TimeUnit unit); public void release(); public boolean tryAcquire(int permits) public boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException; public void release(int permits); 在使用时需要注意避免发生信号泄漏，acquire时如果获取的信号量数比创建Semaphore时指定的初始信号量多，则当前以及后续所有线程都将阻塞；同样，如果release时释放了多的信号量，则会导致有多于初始信号量的线程进入临界区。 ReadWriteLock-读写锁ReadWriteLock是JDK5中提供的读写分离锁，读写分离锁在读多写少的情况下能够有效减少锁竞争，提升系统性能。 读写分离锁所有的写操作以及写操作与读操作都是互斥的，所有的读操作之间不是互斥的，所有的读操作与写操作都是互斥的。 读写锁需要通过ReentrantReadWriteLock获取： ReentrantReadWriteLock reentrantReadWriteLock=new ReentrantReadWriteLock(); Lock readLock=reentrantReadWriteLock.readLock(); Lock writeLock=reentrantReadWriteLock.writeLock(); CountDownLatch-倒计时器倒计时器主要用来控制线程等待计数器倒计时结束后才开始执行。 需要注意CountDownLatch与join方法有如下几点不同: 线程A调用线程B的join方法后，必须等到B线程运行结束后A线程才能继续运行；而CountDownLatch可以在线程B运行过程中就开始运行。 在使用线程池运行任务时，无法直接调用线程的join方法，故使用CountDownLatch比使用join更加灵活。 LongAdder在高并发场景下，同时有多个线程对AtomicLong对象进行自增时，只会有一个线程能够成功，势必就会造成其他线程的自旋CAS操作，浪费CPU资源，针对这种情况，JDK1.8新增了专门用于高并发场景的自增工具LongAdder。 在LongAdder实现中，将一个数拆分为多个Cell，使得原本对单个变量的自增操作变成对多个变量的操作，降低资源竞争的并发量，同时如果对当前Cell的CAS失败后，会转换为对其他Cell的CAS操作，这个改变增加了当前线程重试 CAS 成功的可能性。最后，在获取 LongAdder 当前值时，是把所有 Cell 变量的 value 值累加后再加上 base 返回的。","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://super-aviator.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"Kafka-Consumer","slug":"Kafka-Consumer","date":"2021-03-08T12:08:04.000Z","updated":"2021-03-09T13:35:30.000Z","comments":true,"path":"2021/03/08/Kafka-Consumer/","link":"","permalink":"https://super-aviator.github.io/2021/03/08/Kafka-Consumer/","excerpt":"","text":"seek调用seek方法前必须要调用poll方法使消费者获取到分区，否则将抛出异常，同时如果调用poll方法超时时间为0或者过小，同样会获取不到分区导致seek方法因为还未获取到分区而报错。 weakup唯一一个线程安全方法，用于的其他线程跳出consumer的poll方法。正确的使用姿势如下： try &#123; while (isRunning) &#123; consumer.poll(); &#125; &#125;catch(WakeupException wakeupException)&#123; log.error(wakeupException); &#125;finally&#123; consumer.commitSync(); &#125; ConsumerInterceptor多线程实现KafkaConsumer不是线程安全的，除了调用wakeup方法之外，其余方法在操作前都会调动acquire方法确保只有单个线程使用，否则会报出ConcurrencyModificationException异常，源码如下： private void acquire() &#123; long threadId = Thread.currentThread().getId(); //这里为了确保第一次调用acquire方法时，能正确初始化currentThread的值 //如果不同的线程调用，compareAndSet会失败 if (threadId != currentThread.get() &amp;&amp; !currentThread.compareAndSet(NO_CURRENT_THREAD, threadId)) throw new ConcurrentModificationException(&quot;KafkaConsumer is not safe for multi-threaded access&quot;); //引用自增一 refcount.incrementAndGet(); &#125; release方法和acquire方法成对出现，分别对应加锁和解锁操作，源码如下： private void release() &#123; //这里当没有线程引用时，设置currentThread的值为初始值，后续调用acquire方法时compareAndSet会成功 if (refcount.decrementAndGet() == 0) currentThread.set(NO_CURRENT_THREAD); &#125;","categories":[],"tags":[]},{"title":"Java并发集合","slug":"Java并发集合","date":"2021-02-28T09:16:30.000Z","updated":"2021-03-24T09:21:32.000Z","comments":true,"path":"2021/02/28/Java并发集合/","link":"","permalink":"https://super-aviator.github.io/2021/02/28/Java%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88/","excerpt":"","text":"并发操作ArrayList并发操作HashMap","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://super-aviator.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"Java并发基础","slug":"Java并发基础","date":"2021-02-28T09:11:58.000Z","updated":"2021-03-25T16:15:08.000Z","comments":true,"path":"2021/02/28/Java并发基础/","link":"","permalink":"https://super-aviator.github.io/2021/02/28/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/","excerpt":"","text":"线程创建的三种方式 实现Runnable接口 继承Thread类并重写run方法 使用FutureTask方式 /** * @author 熊乾坤 * @since 2021-03-13 12:34 */ public class FutureTaskTest implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; return &quot;hello&quot;; &#125; public static void main(String[] args) &#123; FutureTask&lt;String&gt; futureTask=new FutureTask&lt;&gt;(new FutureTaskTest()); Thread thread=new Thread(futureTask); thread.start(); try &#123; System.out.println(futureTask.get()); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 只有调用Thread类的start方法，才会创建线程，否则是在调用线程中执行run方法；同时调用start方法之后，只是将线程设置为就绪状态，只有获得CPU资源之后才会处于运行状态； 小结： 继承的方式会收到单继承的限制，但是传参比较方便，内部获取线程直接使用this而无需使用Thread.currentThread方法；而实现Runnable接口则只能使用主线程中被声明为final的变量。如果需要线程返回结果，则使用FutureTask的方式。 线程中断 void interrupt()方法👀️中断线程，该方法设置线程的中断标识为true并立即返回，但是线程并没有被中断，会继续往下执行。如果线程因为调用了join、sleep、wait系列的函数而被挂起，调用线程的interrupt方法则会抛出InterruptedException异常并返回。 boolean isterrupt()方法 👀️ 检测线程是否被中断，如果是则返回true，否则返回false. public boolean isInterrupted() &#123; //这里传递false表示不清理中断标识 return isInterrupted(false); &#125; boolean interrupted()方法👀️ 检测当前线程是否被中断，如果是则返回true,否则返回false。该方法如果发现线程被中断，则会清理中断标识；该方法是static方法，可以通过Thread类直接调用；该方法是判断当前线程的终端标识，而非调用interrupted方法的线程的中断标识。 public static boolean interrupted() &#123; //传入true表示清理中断标识；并且判断的当前线程的中断标识； return currentThread().isInterrupted(true); &#125; 使用中断使线程优雅退出try&#123; while(!Thread.currentThread().isInterrupted()&amp;&amp;more work to do)&#123; //do more work &#125; &#125;catch(InterruptedException e)&#123; //线程被中断 &#125;finally &#123; //进行清理工作 &#125; JMM(Java Memory Model)原子性可见性有序性synchronizesynchronize在JDK5.0早期版本中性能远不如ReentrantLock，但从JDK6.0开始，JDK在synchronized上做了大量优化，两者性能相差并不大。 synchronize内存语义：进入synchronized块时，将块内用到的变量从线程的工作内存中清除,这样在synchronized块内使用到该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取。退出synchronized块时，将块内修改过的变量刷新到内存。 上面的语义其实也是加锁的语义。 synchronized有三种常见用法： 指定加锁对象：给对象加锁，进入临界区前要获取给定对象的锁。 直接作用于示例方法：相当于对当前实例加锁，进入临界区前要获的当前实例的锁。 直接作用于静态方法：相当于对类加锁，进入临界区前要获取类的锁。 synchronized关键字能够解决原子性、可见性、有序性三个问题，但是当使用synchronzed时如果未获取到锁，则会从用户态切换为系统态并执行阻塞操作，会引起线程上下文切换并带来线程调度开销。 volatile相比于锁或者synchronized的这种比较笨重的方式解决可见性，java还提供了一种弱形式的同步：volatile。volatile可以确保对一个变量的更新立即刷新到主内存。当其他线程读取该共享变量时，会从主内存重新获取最新值。 同时volatile声明的关键字还能够避免因为编译器指令重排序导致的问题：写volatile变量是，可以确保volatile写之前的操作不会被编译器重排序到volatile写操作之后。读volatile变量时，可以确保volatile读之后的操作不会被编译器重排序到volatile读之前。 volatile只提供了可见性、有序性，并不能保证操作的原子性。使用原则如下： 写入变量不依赖变量的当前值。 因为如果依赖当前值，将是获取-计算-写入三步操作，而这三部操作不是原子性的，volatile不保证原子性。 读写变量值时没有加锁。 因为加锁已经保证了可见性，不需要再申明为volatile。 CAS（Compare And Swap）CAS是JDK提供的非阻塞原子性操作,他通过硬件保证了比较更新操作的原子性。JDK里面的Unsafe类提供了一系列的compareAndSwap＊方法，下面以 compareAndSwapLong方法为例进行简单介绍。 boolean compareAndSwapLong(Object obj,long valueOffset,long expect,long update）CAS有四个操作数，分别为：对象内存位置、对象中的变量的偏移量、变量预期值、新的值。其操作含义是，如果对象obj中内存偏移量为valueOffset的变量值为expect，则使用新的值update替换旧的值expect。这是处理器提供的一个原子性指令。 关于CAS操作有个经典的ABA问题，具体如下：假如线程I使用CAS修改初始值为A的变量X，那么线程I会首先去获取当前变量X的值（为A〕，然后使用CAS操作尝试修改X的值为B，如果使用CAS操作成功了，那么程序运行一定是正确的吗？其实未必，这是因为有可能在线程I获取变量X的值A后，在执行CAS前，线程II使用CAS修改了变量X的值为B，然后又使用CAS修改了变量X的值为A。所以虽然线程I执行CAS时X的值是A，但是这个A己经不是线程I获取时的A了。这就是ABA问题。 ABA问题的产生是因为变量的状态值产生了环形转换，就是变量的值可以从A到B,然后再从B到A。如果变量的值只能朝着一个方向转换，比如A到B,B到C，不构成环形，就不会存在问题。JDK中的 AtomicStampedReference类给每个变量的状态值都配备了一个时间戳，从而避免了ABA问题的产生。 通过反射使用Unsafe类在Unsafe类的内部，使用类加载器限定了只有Bootstrap类加载器加载的类才能使用Unsafe，所以自己编写的代码无法使用Unsafe，需要使用反射才能使用： /** * @author 熊乾坤 * @since 2021-03-16 23:51 */ public class UnsafeUse &#123; //声明一个待修改的变量 private volatile long status = 0; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); field.setAccessible(true); //使用反射拿到Unsafe类的theUnsafe引用 Unsafe unsafe = (Unsafe) field.get(Unsafe.class); UnsafeUse unsafeUse = new UnsafeUse(); long statusOffset = unsafe.objectFieldOffset(UnsafeUse.class.getDeclaredField(&quot;status&quot;)); System.out.println(&quot;CAS结果：&quot; + unsafe.compareAndSwapLong(unsafeUse, statusOffset , 0, 1)); System.out.println(&quot;修改后的值：&quot; + unsafeUse.status); //再测一次CAS失败的情况 System.out.println(&quot;CAS结果：&quot; + unsafe.compareAndSwapLong(unsafeUse, statusOffset , 0, 1)); System.out.println(&quot;修改后的值：&quot; + unsafeUse.status); &#125; &#125; 伪共享","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://super-aviator.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"转载-兔子的邀请","slug":"转载-兔子的邀请","date":"2021-02-27T08:09:04.000Z","updated":"2021-04-05T03:33:13.257Z","comments":true,"path":"2021/02/27/转载-兔子的邀请/","link":"","permalink":"https://super-aviator.github.io/2021/02/27/%E8%BD%AC%E8%BD%BD-%E5%85%94%E5%AD%90%E7%9A%84%E9%82%80%E8%AF%B7/","excerpt":"","text":"&lt;– iframe frameborder=”no” border=”0” marginwidth=”0” marginheight=”0” width=330 height=86 src=”//music.163.com/outchain/player?type=2&amp;id=40021474&amp;auto=1&amp;height=66” -&gt; 《兔子的邀请》 郑成南 你收到过一只兔子的邀请吗？ 那可是一只可爱的兔子哦。一双长长的尖尖的耳朵，一双红红的亮亮的眼睛，走起路来一蹦一跳，背着一只小巧玲珑的布袋，袋子里装满了请帖。每个清晨，在太阳还没露脸的时候，他要把一张张请帖送到邀请人的手里。 就是在某个冬日清早，你还在睡梦里。梦里又是如此甜蜜，似乎从没做过如此甜蜜的梦。突然咚咚咚传来一阵敲门声，险些把那扇破木门拍碎了。你被敲门声惊醒，一边生气地嘟囔着，一边急着跑去开门，门口站着的竟然是一只兔子。 “真是抱歉，”兔子说，“可能打搅您的美梦了哦。” 你哈欠连连，对兔子的清早来访表示极度不满。 “这是给您的请帖。”兔子递上来一张金黄色的请帖。 多精致的请帖啊，封面上还绣着一朵可爱的玫瑰花呢！那也是兔子自己亲手绣上去的吧。 “到时候请光临寒舍，参加一个特殊的舞会哦。”兔子眨了眨可爱的红眼睛，那双红眼睛里似乎蕴藏着一片粉红色的玫瑰花海。 当时，你没多想，只是擦了擦惺忪睡眼，觉得眼前这只兔子还真滑稽，参加特殊舞会？兔子还开什么舞会？真是闻所未闻哦。 不过，你的手却情不自禁地伸了出去，接过了那张亲贴。金黄色的请帖在你手上显得有些沉甸甸的。你打开一看，里面用黑色小楷认认真真写着： 请您务必在10月18日晚上6点光临寒舍参加特殊舞会哦！ 可爱的兔子奉上 你冷笑了两下，仅仅只是两下。你把嗓门压得很低，原本你的嗓门就沉。所以，那只兔子根本就没听见你的冷笑，他仍然是一副兴奋而幸福的表情。 “到时候一定参加哦。”你说。 “记住，是10月18日6点哦。”兔子叮嘱了一句，转身跑走了。在太阳露脸之前，他要把更多的请帖送到所邀请的人手里。 你拿着请帖愣愣地站着看兔子跑远，然后回屋继续睡觉。 这样的好天气，你是不会错过睡觉的。对你来说，美好的事情莫过于躺在床上，做一个甜美或美好的梦。 所以，那天，兔子走后，你就把那张请帖扔到一边。到了第二天，你就把这件事情忘得一干二净，以致到了10月18日，你也没有想不起舞会那回事，错过了。这件事让你后悔了一辈子。 多年后，你在清理房间的时候，意外地在床地下发现了那张请帖，虽然布满了灰尘，但是，拂去灰尘之后，那层黄色依然如此亮丽，封面上的玫瑰花依然如此精致绝美。你缓缓地开启，然后那行工工整整的小楷再次出现在你的眼前： 请您务必在10月18日6点光临寒舍参加特殊舞会哦！ 可爱的兔子奉上 你的回忆就像电影倒带一般，快速地闪到了多年前的那个清晨，你在睡梦中被一只兔子吵醒，然后看到一只可爱的兔子。 一双长长的尖尖的耳朵，一双红红的亮亮的眼睛，走起路来一蹦一跳，背着一只小巧玲珑的布袋，袋子里装满了请帖…… 即使如今，你在回忆过去，但是，回忆起来比当时更加让你清晰，也更加让你感到奇妙。因为你似乎看到了兔子眼神里的盛情，额头的微微汗珠。那天早上，或许是兔子第一个给你送请帖吧。 过了多少年了啊？多少个10月18日过去了啊？兔子的舞会也早就结束了吧。你手里拿着请帖，就像拿着一张秋日里飘落下来的黄色落叶。 那年以后，兔子再也没出现过了，或许他早离开这里了吧？ 那天，你的心情很不好，就是因为找到了那张请帖，你觉得自己辜负了一只兔子的邀请，辜负了兔子对你的信赖和期盼。整个白天，你在收拾屋子的时候，就显得心不在焉，神不守舍的。以致发生了许多不该发生的意外： 在收拾厨房时，你把家里所有的十三个碟子全打碎了，虽然那些碟子原本就破陋不堪。 在收拾客厅时，你把祖父留给你的唯一相框也碰散架了。祖父唯一的照片就跑出来了，祖父闭着眼睛，或许当年他在照这张照片的时候，刚好望着刺眼的阳光。不过，这张唯一的照片也好，一直挂在客厅的大墙上。 这可是祖父遗留给你的唯一财产啊！你自己很心疼，就拿到后院修理。可是，你哪里用过斧头，又哪里会刨木头。用锤子钉铁钉的时候，又不知道控制力气，结果自然把整个相框都糟蹋完了。 看着一堆碎木片，你心里是如此悲伤。不过，你忍痛割爱把相框扔掉了，只保留了那张照片。失去了相框的照片，就像被脱去衣服的布娃娃，看起来孤孤单单的。 让你收拾屋子，真是难为你了。一天下来，除了那些笨重的东西，几乎没剩什么了。不过，除了对那个相框感到惋惜之外，其他的东西你一点都不在乎。 某个早晨，你突然醒过来，一看日历，快到10月18日了。你再次想起了兔子的请帖，于是，你在枕头地下找出了那张请帖。 （上次你找到请帖后，就一直把请帖压在枕头底下。） 这次，你似乎下了很大决心。你要去参加兔子的特殊舞会，实现多年前的约定。 你拿着请帖，走出家门，准备去找那只可爱的兔子。 或许，他还在那里等我呢？或许，他每年在10月18日6点如期举行特殊舞会呢？你假设了108个“或许”，然后胸有成竹地走出了家门。 你一旦决定的事，谁都无法改变。 你走的时候很干脆，没带上什么东西，虽然你也考虑过兔子或许离你家很远，或许在第五个或第六个山头，那么，你步行需要十天或二十天。但是，你离开家的时候，竟然连门都没有关，因为你知道，那扇破门几年前就破得不成样子，关了跟没关是一样的，何况，家里确实没有什么值钱的东西。 于是，你就放心地上路了。左边口袋里装了祖父留给的唯一照片，虽然没有了相框，可在你心里觉得依然珍贵。（这样带着似乎更加方便哦） 你右边的口袋里装着那张金黄色的请帖。 你离开家的时间是在清晨，或许是多年前兔子把请帖送到你手里的时候吧。这样的清晨，正是赶路的好时候，因为太阳还没有露脸，因为森林里还笼罩着一层薄薄的雾，那些高大挺拔的树看起来就若隐若现。 路边的野花盛开得真好，虽然没有人欣赏，而她们孤芳自赏。这是深山密林里所有植物的生存态度，必须学会孤芳自赏。 你无视路边的野花，你觉得你当务之急是赶去兔子的舞会，你已经错过了很多个舞会，这次再不能错过了。你觉得自己是个守信之人，轻易不该失约的。 （因多年前的失约，你仍耿耿于怀。） 你继续赶路，太阳慢慢露出脸庞。先是从树梢里探出半张脸，似乎在跟那密密麻麻的枝桠捉迷藏。接着，太阳就把整张脸都跳出来了，羞羞答答的。不久，太阳光越来越刺眼，穿过密密层层的树叶，纷纷落在树林里。 太阳的光芒就像一根根光柱，在地上照出一个个圈。据说，每一个圈就是一个缩小的太阳。 你一直急着赶路，你想，在下一个10月18日6点钟务必赶到兔子家里。 走了一段路，你觉得自己已经走出很远了，停下来，转过身，看不到自家屋顶高高的烟囱了。 兔子的家到底在哪里呢？ 你从右边口袋里掏出那张请帖，缓缓地开启，上面依然是一行工工整整的小楷： 请您务必在10月18日6点光临寒舍参加特殊舞会哦！ 可爱的兔子奉上 你自己看了几遍，又轻声地读了几遍，发现上面确实少了什么。 请帖上竟然没有地址！ 这是个致命的错误，那只兔子也太粗心了吧。既然邀请人参加舞会，只写明时间，不留下地址，叫人去哪里寻找呢？ 你摸了摸脑袋，你认为自己的大脑袋充满了智慧，此时却也显得有些无助和踌躇了。你站在一块空地上，一抬头就看到明晃晃的太阳。此时太阳正停在半天空，你分不清东西南北，你也不知道该朝哪个方向走了。 这只粗心的兔子怎么没留下地址呢？ 你在心里反复琢磨着这句话。你想过放弃寻找，漫无目的地寻找，好比是大海捞针，希望是非常渺茫的。 可是，最终你并没有放弃，你摸了摸左边的口袋，觉得坚持到底是你家族的优良传统。这点，在祖父身上就有很好的见证。 你朝着那个最高的山头走去，你认为兔子或许就住在那个山头。你想象，在那个山头后面，有一群可爱的兔子，正在举行舞会。他们手牵着手，在蟋蟀动听的声乐伴奏下，跳起了圆圈舞。他们的脚步很灵巧，身上的毛洁白如雪，在如水的月光下显得那么可爱。 那个山头，在你的联想中有了神秘和生机勃勃。 走了一天，你觉得累了，但是你身上有股神奇的力量。你继续向那个山头走去。可是，那座山头，看起来近在眼前，走起来却是如此遥远，似乎有意躲着你。在太阳下山之时，你只走到山脚。 你抬头望望巍巍的高山，心中有稍微的恐惧，这么高的山，你能顺利爬上去吗？ 那天晚上，你准备在山脚住下。你清楚，只有休息足够了，才有力气爬山。于是，你找到了一块平地，去河边先喝足了水，然后摘了几张芭蕉叶摊在地上，你躺在芭蕉叶上好好的睡了一觉。 你一躺下就睡着了，你从没感到那么累。因为长这么大，你从没出过这么远的门。那天晚上，你没有梦，一夜睡到第二天清晨醒来，你没有梦，这真是让人难以置信啊。 第二天清晨，你是被冰冷的露水冻醒的。因为晚上睡觉时你很不老实，总是把身上的芭蕉叶踢掉。你不知道露珠其实比你更调皮，总是往你身上钻。 你爬起来，揉了揉惺忪睡眼，然后又望了望那座高高的山。你准备向山头进发。 进发之前，你用手摸了摸左边的口袋，祖父的照片还在。你又摸了摸右边的口袋，黄色的请帖还在。它们都还在，你就放心了。 山路很崎岖，你每走一步都显得很艰难。不过，你很有信心，每向上爬一步，你就觉得离山头近一步，也觉得跟兔子的约定近了一步。 中午的时候，你终于爬到了山头，你显得有些气喘。就坐在一块岩石上休息。坐在山头，你往下俯瞰，巍巍的高山，如此峻拔。山头的风真大啊，呼呼呼呼一直吹着。你惊讶着自己是如何爬上来的呢？ 山头很荒芜，几乎没什么树木，甚至连青草也不多。你想，或许兔子就会在这里举办舞会吧，这样的地方举办舞会可正合适。 可是，你打量了所有地方，都想象不出这里有开过舞会的痕迹。 这时，你看到一只山羊。当时，山羊正埋着头吃稀少的青草。因为青草稀少，山羊总是吃不饱，这点从山羊骨瘦如柴的身架就看出来了。 那么，山羊为何选择生活在这里呢？山脚却是一片肥沃啊！或许，在这样的山头，最适合山羊生活，他喜欢跟自己过不去。 “这里从来没有举行过什么舞会。”山羊很肯定地说，“因为我一直生活在这里，从我小时候起，一直到现在。我见过的事情比我下巴上的胡须还多，我听过的事情比我身上的毛发还多……” 原来这是一只善于倾述的山羊。是啊，一直生活在这样荒芜的山头，根本没机会倾述，是会被憋坏的。 面对这只年迈憨厚的山羊，你认为他说的没错。可是，你不能听着他把所见多的事情讲完。或许，他一直讲着讲着，突然倒地，老死了。因为等他讲完，确实需要很久很久。 山羊邀请你留下，他确实需要你。可是，你清楚自己不能留下。因为，你一直想着右边口袋里的请帖，你清楚自己的目的。 “你可以把故事说给山听啊，山会回答你的哦。” 山羊就对着山咩咩地喊了几声，果然，山也跟着咩咩喊了几声。山羊很高兴，他在山头活了一辈子，却不懂得山头是有回声的。此后，他每天对着山讲故事。山也跟着把他的故事重述一遍。 这只可怜的山羊，活了一辈子，到老了才活出点精彩来。 “或许，兔子就在下一座山头上吧。”你想。 于是，你告别了山羊，在山羊留恋的注视下，向下一座山头走去。 下一座山头比这个山头更高，而你已经习惯了爬山。很快就爬到了山顶。这里的山头比之前的山头似乎显得更加荒芜，你可以肯定兔子不可能在这里开舞会。果然，你的猜测在一只老牦牛的嘴巴里得到了证实。 老牦牛说自己在山头生活了一辈子。在他很小很小的时候，跟着牦牛家族来到了这里，最后牦牛家族迁移了，而他执意留下来。 老牦牛说：“之前，这里可是一片肥沃的草地，自从牦牛家族来后，把所有的草都吃掉了。这个山头就像一个孩子的脑袋，青青的草就像脑袋上的头发，总是不停地破坏，头发自然就不长了，只剩了这片光秃秃的山头。” 牦牛说这些话的时候，一直坐在一块凹进去的石头上，或许那块石头就是被他坐凹陷的吧。 “别说一只兔子，连一只蜜蜂都没关顾过。”牦牛说。 “或许他在下一座山头吧。” 你告别了牦牛，又向下一座山头进发了。 你认为，只要继续寻找，一定能找到那只兔子，他就在某一座山头上，在10月18日6点举行特殊舞会。 在第三座山头上，你坐在一根枯败的树杆上，从右边口袋里掏出了那张金黄色请帖，你推算着，离18日只差五天了，这五天之内能找到兔子吗？ 第四天，你坐在第四座山头上，然后看着落山的夕阳。你从没看过夕阳，觉得太阳落山时竟然也有如此美丽的景致，你被那美丽陶醉了。 第五天，你站在第五座山头，你从一条蟒蛇口中救出了一只可怜的野鼠。你把那只奄奄一息的野鼠送回家里，然后很好的照顾他。野鼠很快就恢复了健康。 第六天，你走到第六座山头上。在一棵千年老树下，你听到了一首美妙的歌。那首歌是一只长尾巴鸟唱的，你从没听过如此美妙的歌。那歌声犹如纯洁的清泉叮叮咚咚地流淌，犹如可爱的婴儿熟睡时甜甜的笑声。你想认识这只长尾巴鸟，可是，长尾巴鸟唱完了歌，展翅飞走了。 你愣愣地站了片刻，并没有感到遗憾，因为他的歌声会让你记忆一辈子，也会让你感动一辈子。 第七天，你终于到了第七座山头上。 第八天，你想着，如果今晚再找不到那只兔子，又要错过今年的舞会了，因为今天就是10月18日。 你很快就到了第八座山头上。站在山头，吹拂着凉凉的风，你的心情很好，特别的好，或许你期待着今晚就会看到那只兔子。还会看到那场神秘的特殊舞会。你再次从右边口袋里掏出了那张请帖，金黄色的请帖，封面上依然是一朵精致的玫瑰花。 夜幕徐徐降临，你看到赤黄的太阳就像被剥去蛋清的蛋黄，落在山的半山腰。等繁星慢慢出现在夜空的时候，山头依然很安静。 这时，你有些失望了，你觉得兔子根本就不会在这座山头。因为当年你错过了约定，他离开了。或许，当年他给你送请帖的时候，根本就是个恶作剧！ 可是，不久，你却别眼前的情景惊呆了。你看到了一只萤火虫。这个时候，并非是萤火虫活动的季节，可是，你却看到了萤火虫。 起先是一只萤火虫，闪着暗淡的光芒。接着，是一群，不久，就是一片。所有暗淡的光都聚集起来，就是一片明亮！ 这时，一只兔子出现了，你发现了正是当年那只兔子。你心里有股按捺不住兴奋，迅速向兔子跑去。 跟当年一样，兔子没有改变，依然是一双长长的尖尖的耳朵，一双红红的亮亮的眼睛，走起路来一蹦一跳。不过，此时，兔子在跳舞，他一个人在跳圆圈舞。看起来如此滑稽。兔子尽情地舞蹈，他的舞步很笨拙，不过很有激情。那股激情是从他内心散发出来的，你看着，也被感染，你想着跳舞。你就跟着兔子一起跳了。你的舞步比兔子的更加笨拙，因为你是第一次跳舞，况且你天生就不是跳舞的料。 萤火虫团团将你围住，她们的光芒很暗淡。 很快，你们就停止了舞步。因为兔子累了，你也累了。 “听说您找我了，我就一路跟着来了。真抱歉，让您找了那么久。” 说抱歉的应该是你，兔子的话让你感到更加内疚。你从右边口袋里掏出那张请帖，说起了当年的那个清晨，你说自己失约了。 “真高兴您还收藏着请帖。我送出去108张请帖，您是唯一守约的，虽然迟了多年。” 你很激动，一时无语。 不过，你为自己感到高兴。 此文发表于2010年6月《儿童文学》下，感谢编辑木马老师，感谢CAFE-Y老师的精美插图。遗憾的是，发稿时作者写成了“郑成楠”！ 原文链接：《兔子的邀请》","categories":[{"name":"Daily","slug":"Daily","permalink":"https://super-aviator.github.io/categories/Daily/"}],"tags":[]},{"title":"MySQL批量修改数据过大导致事务无法提交的问题","slug":"MySQL批量修改数据过大导致事务无法提交的问题","date":"2021-02-25T09:07:39.000Z","updated":"2021-03-24T09:22:16.000Z","comments":true,"path":"2021/02/25/MySQL批量修改数据过大导致事务无法提交的问题/","link":"","permalink":"https://super-aviator.github.io/2021/02/25/MySQL%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%A7%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E6%97%A0%E6%B3%95%E6%8F%90%E4%BA%A4%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"哈哈哈","categories":[{"name":"Database","slug":"Database","permalink":"https://super-aviator.github.io/categories/Database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://super-aviator.github.io/tags/MySQL/"}]},{"title":"MySQL事务与锁","slug":"MySQL事务与锁学习","date":"2021-02-24T10:31:31.000Z","updated":"2021-03-11T00:54:18.000Z","comments":true,"path":"2021/02/24/MySQL事务与锁学习/","link":"","permalink":"https://super-aviator.github.io/2021/02/24/MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"MySQL中的事务由存储引擎层进行管理，所以在同一个事务中混合使用事务型和非事务性的表是不可靠的，例如需要回滚时，事务型的表则无法撤销操作，造成数据不一致的情况； 事务的ACID属性 原子性事务被视为一个不可分割的最小执行单元，整个事务中的所有操作要么全部成功，要么全部回滚，不存在只执行一半的情况 一致性数据库总是从一个一致性状态转换到另一个一致性状态；例如事务执行到一半系统崩溃，所做的修改也不会提交 隔离性在某些隔离级别下，事务所做的修改在事务最终提交前，对其他事务是不可见的 持久性一旦事务提交，事务所做的修改就会永久保存到数据库中，此时即使系统崩溃，修改的数据也不会丢失 并发事务带来的问题更新丢失脏读不可重复读（针对UPDATE和DELETE的行）幻读（针对INSERT的行）事务的四种隔离级别READ UNCOMMITED(未提交读)一个事务所做的修改即使未提交，对于另一个事务来说都是可见的。事务可以读取到未提交的行，这种也被成为脏读（Dirty Read）。 READ COMMITED(已提交度、不可重复读)大多数数据库默认的隔离级别；事务只能看到已提交的事务所做的修改，一个事务所做的修改对另外一个事务是不可见的。但是在一个事务中执行两次同样的查询，可能会得到不一样的结果。 REPEATABLE READ(可重复读)MySQL默认的隔离级别；该级别解决了脏读的问题，保证了在一个事务中多次读取同样的记录的结果是一致的。但是在在理论上还是存在幻读的问题。InnoDB和XtraDB使用MVCC多版本并发控制解决了幻读的问题。 SERIALIZABLE(序列化)最高的隔离级别，他通过强制事务串行化执行，避免了前面提到的幻读问题。简单来说，SERIALIZABLE会在读取到的每一行数据上都加锁，所以可能导致大量超时和锁争用问题。 注意：MySQL可以动态更改事务隔离级别： #修改当前事务隔离级别为可重复读 SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ; #修改当前事务隔离界别为序列化 SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE; MVCC（Molti Version Concurrency Control）MVCC只在READ COMMITED和REPEATABLE READ级别下工作，另外两种隔离级别并不兼容MVCC，READ UNCOMMITED每次都读取最新的行，SERIALIZABLE则对每次读取都加锁；在InnoDB引擎下，简单描述其工作原理如下： 前提条件： 为每一行数据都增加两个隐藏列，一列保存行的创建系统版本号，一列保存行的删除系统版本号。没开始一个事务，系统版本号都会自增，事务开始是的系统版本号作为事务的版本号，和查询到记录的版本号做比较，例如在REPEATABLE READ隔离级别下,具体行为如下： INSERT: DELETE: UPDATE: SELECT: MyISAM表锁LOCK TABLE table_name WRITE; #获取表的写锁 LOCK TABLE table_name READ; #获取表的读锁 LOCK TABLE table_name READ LOCAL; #获取表的读锁，并且允许并发插入（CONCURRENT_INSERT） LOCK TABLES table_name1 , table_name2 READ; #获取多个表的读锁 ... #执行SQL语句 UNLOCK TABLES; #释放锁 注意：上面加锁的方式同样使用与InnoDB表锁，但是在InnoDB中释放锁的方式不一样； 在使用MyISAM表锁时，需要一次性获取SQL语句涉及到的所有的表锁，并且因为MySQL不支持表升级，所以只能访问锁定的表，不能访问未锁定的表。读锁不能执行更新操作；MyISAM总是一次性获取所有所需的锁，这也是MyISAM表锁不会存在死锁的原因 表锁是MySQL服务层实现的，和存储引擎无关。 使用MyISAM表锁时，需要对SQL中使用到的所有别名进行锁定，否则会提示Table ‘别名’ was not locked white LOCK TABLES; LOCK TABLES table_name AS a, table_name AS b READ; 并发插入（Concurrency Insert）MyISAM引擎还支持支持并发插入的操作，即在一个session获取到读锁时，允许另外一个session在表的末尾进行INSERT操作。搜索引擎有一个配置concurrent_insert控制并发插入的行为： concurrent_insert=0：不允许并发插入操作 consurrent_insert=1：在表中没有空洞是，允许并发插入操作（默认设置） concurrent_insert=2：无论如何，都允许并发插入操作 在手动锁定表时，可以使用 LOCK TABLE table_name READ LOCAL;中的LOCAL关键字来指定是否启用并发插入。 锁调度MyISAM引擎会优先处理获取写锁的请求，及时读请求比写请求先入队列；所以不建议有大量更新和查询操作的应用使用MyISAM引擎，因为大量的更新操作会造成查询操作长时间获取不到锁，从而可能永远阻塞。 InnoDB行锁InnoDB引擎定义了如下几种行锁： 共享锁（S锁）：允许一个事务读一行，防止其他事务获取相同数据集的排他锁。（主要用于确保在查询期间没有其他事务修改该数据集） 排他锁（X锁）：允许获取排他锁的事务更新数据，阻止其他事务获取相同数据集的共享锁和排他锁。 为了行锁和表锁共存 ，实现多粒度锁机制，InnoDB在内部还使用另外两种锁： 意向共享锁（IS)：事务打算给数据行加共享锁，事务再给一个数据行加共享锁之前必须先取得改表的IS锁。 意向排他锁（IX)：事务打算给数据行加排他锁，事务再给一个数据行加排他锁之前必须先取得改表的IX锁。 使用InnoDB引擎时，SELECT语句是不加任何锁的，如果需要手动加锁，则需要使用如下方式： # MySQL5.7中： SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE; SELECT * FROM table_name WHERE ... FOR UPDATE; # 在MySQL8.0中： SELECT * FROM table_name WHERE ... FOR SHARE; SELECT * FROM table_name WHERE ... FOR UPDATE [NOWAIT|SKIP LOCKED]; LOCK IN SHARE MODE在8.0版本中依旧兼容；NOWAIT表示发现有锁等待时立即返回；SKIP LOCKED表示跳过被锁定的行，只更新未加锁的行。 某事务在获得某数据集的S锁之后，如果对数据进行更新，会发生什么？实验证明，在单个事务中，是可以正常更新的，但是如果多个事务时可能导致死锁问题：在事务A、B中获得共享锁，A中执行UPDATE，A会阻塞，B然后也执行UPDATE，此时B会因为死锁而事务结束，事务A此时会获得锁然后更新成功。因此在需要对数据进行更新操作时，应该获得X锁而非S锁。 InnoDB行锁的实现方式nnoDB行锁是通过给索引项加锁实现的，如果无索引则会使用聚簇[cù]索引来对记录加锁；InnoDB行锁分为以下三种： Record Lock：对索引项加锁 Gap Lock：对索引项之间的间隙加锁 Next Key Lock：前两种所得组合，对索引项以及项之间的间隙加锁 注意： 行锁的这种实现方式意味着当查询未使用到任何索引时，将会对这个表加锁，效果相当于表锁！可能导致大量的锁冲突。 即使是查询列上有索引，但是如果两个查询使用的是一个索引键（id列上有索引，查询条件中索引列查询的是同一列，例如WHERE id=1 AND name =’1’ 和WHERE id=1AND name=’4’都会锁定id为的索引项）,或者查询的是同一行数据（id列上有主键索引，name上有普通索引，例如WHERE id=1和where name =’1’,锁定的是同一行id为1，name为1数据项），同样会出现锁冲突。 查询有可能不走索引走全表扫描，也会导致锁全表，例如数据量小时数据库会优先使用全表扫描而不使用索引、索引列存在隐式类型转换而不使用索引等。 Next-Key锁当使用范围查询而不是相等条件检索数据并请求共享锁或者排他锁时，InnoDB会对范围内的数据使用Next-Key锁；一方面是为了防止幻读，另一方面是为了满足其恢复和复制的需要（InnoDB在使用范围更新都会使用到Next-Key锁，与事务隔离级别无关）；InnoDB这种加锁方式在并发插入时往往会造成严重的所等待，开发中应该优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件； 注意： 就算是使用等值条件，如果给一个不存在的记录加锁，InnoDB也会使用Next-Key锁，例如在id为1~100的表中，锁定表中不存在的id为101的记录，并发插入id为102的事务会进行锁等待； InnoDB表锁同样可以使用MyISAM加表锁的方式对InnoDB引擎中的表加表锁，但是有以下两点需要注意： InnoDB中的表锁由MySQL Server层进行管理，只有使用设置成autocommit=0、innodb_table_locks=1(默认)时，引擎层才能感知服务层的表锁，服务层才能感知引擎层的行锁，这种情况下InnoDB才能感知表的死锁，否则InnoDB无法处理死锁。 使用LOCK TABLES对表加锁时，需要设置为autocommit=0，否则不会给表加锁；事务结束前，正确的做法是先COMMIT提交事务，然后UNLOCK TABLES释放表锁； SET AUTOCOMMIT =0; LOCK TABLES table_name1 WRITE,table_name2 READ; [do something...] COMMIT; UNLOCK TABLES; 死锁InnoDB可以使用 innodb_lock_wait_timeout 参数设定锁等待超时时间 死锁发生后的解决方法","categories":[{"name":"Database","slug":"Database","permalink":"https://super-aviator.github.io/categories/Database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://super-aviator.github.io/tags/MySQL/"}]},{"title":"告别静静","slug":"告别静静","date":"2021-01-27T16:03:00.000Z","updated":"2021-02-24T10:32:02.000Z","comments":true,"path":"2021/01/28/告别静静/","link":"","permalink":"https://super-aviator.github.io/2021/01/28/%E5%91%8A%E5%88%AB%E9%9D%99%E9%9D%99/","excerpt":"","text":"又过了一个秋天冬天快来特别容易想念桌上的照片我们羞涩的脸从来没有改变翻开过去的日记字里行间充满爱的诗篇也不曾忘记为你流下眼泪而不敢面对明天 某天晚上在明白自己是个又丑又蠢的屌丝之后，一切的问题都迎刃而解；在见识到爱情最终的模样和彼此之间的差距之后，我选择躲进世界的角落；静静再见。","categories":[{"name":"Daily","slug":"Daily","permalink":"https://super-aviator.github.io/categories/Daily/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://super-aviator.github.io/tags/%E7%94%9F%E6%B4%BB/"}],"author":"熊乾坤"},{"title":"Redis-Redis内存管理","slug":"Redis-Redis内存管理","date":"2021-01-24T07:42:00.000Z","updated":"2021-02-24T05:38:38.000Z","comments":true,"path":"2021/01/24/Redis-Redis内存管理/","link":"","permalink":"https://super-aviator.github.io/2021/01/24/Redis-Redis%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"将redis当做使用LRU算法的缓存来使用当Redis被当做缓存来使用，当你新增数据时，让它自动地回收旧数据是件很方便的事情。这个行为在开发者社区非常有名，因为它是流行的memcached系统的默认行为。 LRU是Redis唯一支持的回收方法。本页面包括一些常规话题，Redis的maxmemory指令用于将可用内存限制成一个固定大小，还包括了Redis使用的LRU算法，这个实际上只是近似的LRU。 Maxmemory配置指令maxmemory配置指令用于配置Redis存储数据时指定限制的内存大小。通过redis.conf可以设置该指令，或者之后使用CONFIG SET命令来进行运行时配置。 例如为了配置内存限制为100mb，以下的指令可以放在redis.conf文件中。 maxmemory 100mb 设置maxmemory为0代表没有内存限制。对于64位的系统这是个默认值，对于32位的系统默认内存限制为3GB。 当指定的内存限制大小达到时，需要选择不同的行为，也就是策略。 Redis可以仅仅对命令返回错误，这将使得内存被使用得更多，或者回收一些旧的数据来使得添加数据时可以避免内存限制。 回收策略当maxmemory限制达到的时候Redis会使用的行为由 Redis的maxmemory-policy配置指令来进行配置。 以下的策略是可用的: noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外），redis默认为次策略 allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。 volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。 allkeys-random: 回收随机的键使得新添加的数据有空间存放。 volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。 volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。 如果没有键满足回收的前提条件的话，策略volatile-lru, volatile-random以及volatile-ttl就和noeviction 差不多了。 选择正确的回收策略是非常重要的，这取决于你的应用的访问模式，不过你可以在运行时进行相关的策略调整，并且监控缓存命中率和没命中的次数，通过RedisINFO命令输出以便调优。 一般的经验规则: 使用allkeys-lru策略：当你希望你的请求符合一个幂定律分布，也就是说，你希望部分的子集元素将比其它其它元素被访问的更多。如果你不确定选择什么，这是个很好的选择。.使用allkeys-random：如果你是循环访问，所有的键被连续的扫描，或者你希望请求分布正常（所有元素被访问的概率都差不多）。 使用volatile-ttl：如果你想要通过创建缓存对象时设置TTL值，来决定哪些对象应该被过期。allkeys-lru 和 volatile-random策略对于当你想要单一的实例实现缓存及持久化一些键时很有用。不过一般运行两个实例是解决这个问题的更好方法。 为了键设置过期时间也是需要消耗内存的，所以使用allkeys-lru这种策略更加高效，因为当内存有压力时没有必要为键取设置过期时间。 回收进程如何工作理解回收进程如何工作是非常重要的: 一个客户端运行了新的命令，添加了新的数据。 Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。 一个新的命令被执行，等等。 所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。 近似LRU算法Redis的LRU算法并非完整的实现。这意味着Redis并没办法选择最佳候选来进行回收，也就是最久未被访问的键。相反它会尝试运行一个近似LRU的算法，通过对少量keys进行取样，然后回收其中一个最好的key（被访问时间较早的）。 不过从Redis 3.0算法已经改进为回收键的候选池了。这改善了算法的性能，使得更加近似真是的LRU算法的行为。 Redis LRU有个很重要的点，你通过调整每次回收时检查的采样数量，以实现调整算法的精度。这个参数可以通过以下的配置指令调整: maxmemory-samples 5 Redis为什么不使用真实的LRU实现是因为这需要太多的内存。不过近似的LRU算法对于应用而言应该是等价的。使用真实的LRU算法与近似的算法可以通过下面的图像对比。 LRU comparison在LRU实现的理论中，我们希望的是，在旧键中的第一半将会过期。Redis的LRU算法则是概率的过期旧的键。你可以看到，在都是五个采样的时候Redis 3.0比Redis 2.8要好，Redis2.8中在最后一次访问之间的大多数的对象依然保留着。使用10个采样大小的Redis 3.0的近似值已经非常接近理论的性能。 注意LRU只是个预测键将如何被访问的模型。另外，如果你的数据访问模式非常接近幂定律，大部分的访问将集中在一个键的集合中，LRU的近似算法将处理得很好。 在模拟实验的过程中，我们发现如果使用幂定律的访问模式，则真实的LRU算法和近似的Redis算法几乎没有差别。 当然你可以提升采样大小到10，消耗更多的CPU时间以实现更真实的LRU算法，同时查看下是否让你的缓存命中率有差别。 通过CONFIG SET maxmemory-samples 命令在生产环境上设置不同的采样大小是非常简单的。 参考地址： Redis官网","categories":[{"name":"Redis","slug":"Redis","permalink":"https://super-aviator.github.io/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://super-aviator.github.io/tags/Redis/"}],"author":"熊乾坤"},{"title":"Elasticsearch-JavaHighLevelRESTClient学习","slug":"Elasticsearch-JavaHighLevelRESTClient学习","date":"2021-01-24T05:02:00.000Z","updated":"2021-02-23T13:00:08.000Z","comments":true,"path":"2021/01/24/Elasticsearch-JavaHighLevelRESTClient学习/","link":"","permalink":"https://super-aviator.github.io/2021/01/24/Elasticsearch-JavaHighLevelRESTClient%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"","categories":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://super-aviator.github.io/categories/Elasticsearch/"}],"tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://super-aviator.github.io/tags/Elasticsearch/"}],"author":"熊乾坤"},{"title":"2021-01-14（公司年会）","slug":"2021-01-14（公司年会）","date":"2021-01-16T07:11:56.000Z","updated":"2021-03-24T09:21:48.000Z","comments":true,"path":"2021/01/16/2021-01-14（公司年会）/","link":"","permalink":"https://super-aviator.github.io/2021/01/16/2021-01-14%EF%BC%88%E5%85%AC%E5%8F%B8%E5%B9%B4%E4%BC%9A%EF%BC%89/","excerpt":"","text":"好吧，第二次参加年会了，相比去年的大部门的年会，今年的年会相对就简单了许多，一方面是因为部门人数变少，另一方面是经费也确实不够了，听辉哥说很多钱都是他暂时补贴的，领导不批了。。 幸运的是年会中了200块钱E卡，又能京东剁一手了；不幸的是饭吃到一半被拉去海关现场去解决问题，凌晨4点左右才回酒店。（小明在开心的吃年夜饭，小坤在苦逼的熬夜搞现场，大家都有美好的未来！） 放一些年会拍到的图片吧，拍的不是很多，顺便测试下买的腾讯的COS存储桶好不好用哈，拿来做图床使应该阔以","categories":[],"tags":[],"author":"熊乾坤"},{"title":"第N个N年计划-Websocket学习","slug":"Websocket学习","date":"2020-08-13T01:02:00.000Z","updated":"2021-04-04T16:06:41.378Z","comments":true,"path":"2020/08/13/Websocket学习/","link":"","permalink":"https://super-aviator.github.io/2020/08/13/Websocket%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"WebSocket协议帧WebSocket请求由Http协议升级而来，在Http连接建立之后，会再次进行协议升级，具体发送的协议帧如下： 客户端会发送如下头部的http请求： GET /null HTTP/1.1\\r\\n Connection: Upgrade\\r\\n Host: 127.0.0.1:2346\\r\\n Sec-WebSocket-Key: xh2LW9mb1ZklWVH2gCUlHw==\\r\\n Sec-WebSocket-Version: 13\\r\\n Upgrade: websocket\\r\\n GET 请求标识符 Request-URI，用于识别 websocket 链接到不同的服务终结点。 Connection 告诉服务端对协议进行升级，具体升级内容取决于 Upgrade部分 Host 服务器地址以及service端口 Sec-WebSocket-Key 为了保证握手一致性，由客户端生成随机字符串并base64编码，发送给服务端 Sec-WebSocket-Version ws协议版本，常用13 Upgrade 升级至*协议 服务端接收到协议升级的请求后，会给与如下的响应： HTTP/1.1 101 Switching Protocols\\r\\n Upgrade: websocket\\r\\n Sec-WebSocket-Version: 13\\r\\n Connection: Upgrade\\r\\n Server: workerman/3.5.3\\r\\n Sec-WebSocket-Accept: 47N20KYf6c6Qe2+UDp2BQfK0hkw=\\r\\n 状态码101 代表协议升级成功后的状态码 Connection 和 Upgrade 内容代表协议成功升级为ws Sec-WebSocket-Version 和 Server 内容代表 ws协议版本 以及 服务端服务软件信息 Sec-WebSocket-Accept 重点在此，证明服务端接受了客户端的请求，然后客户端对accept值进行验证，任何 为空或者不符合验证规则的都视为服务器拒绝了请求。服务端生成 Sec-WebSocket-Accept 规则：服务端将客户端传递的key进行去除首尾空白，然后和一段固定的GUID（258EAFA5-E914-47DA-95CA-C5AB0DC85B11）进行连接，连接后的结果使用 SHA-1（160数位）进行哈希操作，对哈希后的字符串进行base64编码，即为 Accept 内容。 客户端验证规则 仿上述规则对 Sec-WebSocket-Key 进行加密，跟服务端返回 Sec-WebSocket-Accept 值进行对比即可。 WebSocket服务端对于Springboot，支持SockJS或者STOMP两种方式建立WebSocket，基本的配置类如下： 服务配置首先需要在项目中加入如下依赖： &lt;!--websocket--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 这会自动引入spring-websockt以及spring-message两个模块。 然后需要在配置类中配置服务的端点和代理Broker： import org.springframework.context.annotation.Configuration; import org.springframework.messaging.simp.config.MessageBrokerRegistry; import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker; import org.springframework.web.socket.config.annotation.StompEndpointRegistry; import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer; /** * @author 熊乾坤 * @date 2020-08-14 10:35 */ @Configuration @EnableWebSocketMessageBroker public class MySTOMPWebSocketConfigurer implements WebSocketMessageBrokerConfigurer &#123; @Override public void registerStompEndpoints(StompEndpointRegistry registry) &#123; //开启一个WebSocket端点，客户端可以直接连接到此端点（在转发和订阅中，都需要首先连接到此端点） registry.addEndpoint(&quot;/stomp/test&quot;) .setAllowedOrigins(&quot;*&quot;); //如果使用Stomp的方式，则不能指定withSockJS，否则会连不上，前端报异常 //.withSockJS(); &#125; @Override public void configureMessageBroker(MessageBrokerRegistry registry) &#123; //指定所有Broker的前缀 registry.setApplicationDestinationPrefixes(&quot;/web-socket&quot;) //开启一个broker消息代理（如果不开启消息代理，则无法使用broker，消息将无法转发） .enableSimpleBroker(&quot;/topic&quot;,&quot;/web-socket/subscribe&quot;); &#125; &#125; 以上的配置有如下几个要点: addEndpoint(&quot;/stomp/test&quot;)为WebSocket客户端首先需要连接的地址，所有的订阅和取消订阅等操作都是需要客户端连接上此端点后进行的操作。 .setAllowedOrigins(&quot;*&quot;)此方法指定了后台跨域的配置。 withSocketJS()此方法指定了/stomp/test端点使用的协议，如果使用的sockjs，则必须要调用此方法以指定协议，否则不能指定。（例如当客户端指定使用stomp协议时，调用此方法前端会报出：握手期间非法的200响应码） setApplicationDestinationPrefixes(&quot;/web-socket&quot;)此方法指定了前端请求的前缀，注意：在消息发送时此前缀必须携带。 enableSimpleBroker()方法指定了后端所有建立Broker的地址，这些地址用于用户的点对点模式或者发布订阅模式。注意：所有的发布订阅或者点对点的地址都需要再次进行注册，否则客户端将无法接收到消息。 接收客户端发送的消息Spring中，可以使用@MessageMapping注解来接收客户端发送的消息，他的用法和@RequestMapping类似，同样支持表达校验和路径参数、路径模糊匹配等: /** * 注意：如果客户端的destination地址为web-socket/stomp/side时, 则会自动映射到注解@MessageMapping的value为stomp/side的方法中去（去掉前缀web-socket中） * 该方法的返回值会自动推送到了/topic/stomp/side的Broker中去，从而实现广播的功能。 * &lt;p&gt; * 注意：1.@SendTO注解会将方法的返回值重定向到指定的broker中，不使用默认的转发规则 * 2.@MessageMapping只会处理前端发送的SENG的请求，不会处理SUBSCRIBE请求 * * @param message 客户端发送的消息 * @return 想要广播的消息 */ @MessageMapping(&quot;stomp/side&quot;) @SendTo(&quot;/web-socket/subscribe/1&quot;) public Message&lt;String&gt; getMessage(Message&lt;String&gt; message, MessageHeaders headers) &#123; log.info(&quot;stomp服务端接收到消息：&#123;&#125;，并将消息转发到destination：[&#123;&#125;]&quot;, message.getPayload(), &quot;/subscribe/1&quot;); return message; &#125; 正如注释中所说，所有注解接收到的消息都会推送至改路径的/topic前缀的消息代理中，并官广播方法的返回值至所有订阅了此topic的客户端。 向客户端发送消息向客户端发送消息可以使用@SendTo或者@SendToUser注解，用于重定向消息的目的地，或者使用SimpMessageTemplate提供的方法手动发送给某个用户或者消息代理： @PostMapping(&quot;/send&quot;) public void sendMessage(@Validated @RequestBody WebSocketMessage message, BindingResult bindingResult) &#123; if (bindingResult.hasErrors()) &#123; return; &#125; String destination = &quot;/web-socket/subscribe/&quot; + message.getTopicSuffix(); log.info(&quot;向[&#123;&#125;]发送消息：[&#123;&#125;]&quot;, destination, message.getMessage()); //手动将消息发送至指定的topic中去，路径必要匹配（客户端的订阅地址需要添加前缀web-socket） simpMessagingTemplate.convertAndSend(destination, message.getMessage()); &#125; WebSocket客户端事件监听心跳和握手发布订阅模式点对点模式","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"WebSocket","slug":"WebSocket","permalink":"https://super-aviator.github.io/tags/WebSocket/"}],"author":"熊乾坤"},{"title":"循环了一天的歌","slug":"环了一天的歌","date":"2020-05-17T13:02:00.000Z","updated":"2021-02-23T13:00:08.000Z","comments":true,"path":"2020/05/17/环了一天的歌/","link":"","permalink":"https://super-aviator.github.io/2020/05/17/%E7%8E%AF%E4%BA%86%E4%B8%80%E5%A4%A9%E7%9A%84%E6%AD%8C/","excerpt":"","text":"循环了一天的歌曲","categories":[],"tags":[],"author":"熊乾坤"},{"title":"Docker中搭建Mysql开发环境","slug":"Docker中搭建Mysql开发环境","date":"2020-05-06T10:03:00.000Z","updated":"2021-02-23T13:00:12.000Z","comments":true,"path":"2020/05/06/Docker中搭建Mysql开发环境/","link":"","permalink":"https://super-aviator.github.io/2020/05/06/Docker%E4%B8%AD%E6%90%AD%E5%BB%BAMysql%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"Docker中搭建Mysql开发环境","categories":[{"name":"Database","slug":"Database","permalink":"https://super-aviator.github.io/categories/Database/"}],"tags":[],"author":"熊乾坤"},{"title":"滴水湖、南汇新城海滩","slug":"滴水湖、南汇新城海滩","date":"2020-05-05T11:36:00.000Z","updated":"2021-02-23T13:00:12.000Z","comments":true,"path":"2020/05/05/滴水湖、南汇新城海滩/","link":"","permalink":"https://super-aviator.github.io/2020/05/05/%E6%BB%B4%E6%B0%B4%E6%B9%96%E3%80%81%E5%8D%97%E6%B1%87%E6%96%B0%E5%9F%8E%E6%B5%B7%E6%BB%A9/","excerpt":"","text":"滴水湖、南汇新城海滩","categories":[{"name":"Daily","slug":"Daily","permalink":"https://super-aviator.github.io/categories/Daily/"}],"tags":[],"author":"熊乾坤"},{"title":"国庆骑行","slug":"国庆骑行","date":"2020-05-02T11:08:00.000Z","updated":"2021-02-23T13:00:12.000Z","comments":true,"path":"2020/05/02/国庆骑行/","link":"","permalink":"https://super-aviator.github.io/2020/05/02/%E5%9B%BD%E5%BA%86%E9%AA%91%E8%A1%8C/","excerpt":"","text":"国庆骑行","categories":[{"name":"Daily","slug":"Daily","permalink":"https://super-aviator.github.io/categories/Daily/"}],"tags":[],"author":"熊乾坤"},{"title":"Docker中搭建Redis环境","slug":"Docker中搭建Redis环境","date":"2020-04-30T08:14:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2020/04/30/Docker中搭建Redis环境/","link":"","permalink":"https://super-aviator.github.io/2020/04/30/Docker%E4%B8%AD%E6%90%AD%E5%BB%BARedis%E7%8E%AF%E5%A2%83/","excerpt":"","text":"Docker中搭建Redis环境","categories":[{"name":"Database","slug":"Database","permalink":"https://super-aviator.github.io/categories/Database/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://super-aviator.github.io/tags/Redis/"}],"author":"熊乾坤"},{"title":"Spring中@Async和@Scheduled注解自定义线程池","slug":"Spring中-Async和-Scheduled注解自定义线程池","date":"2020-04-25T07:56:29.000Z","updated":"2021-02-23T13:00:02.000Z","comments":true,"path":"2020/04/25/Spring中-Async和-Scheduled注解自定义线程池/","link":"","permalink":"https://super-aviator.github.io/2020/04/25/Spring%E4%B8%AD-Async%E5%92%8C-Scheduled%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"Spring中@Async和@Scheduled注解自定义线程池","categories":[],"tags":[],"author":"熊乾坤"},{"title":"第一个一年计划-Java中的静态、JDK动态、CGLIB代理","slug":"第一个一年计划-Java中的静态、动态、cglib代理","date":"2020-02-05T03:51:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2020/02/05/第一个一年计划-Java中的静态、动态、cglib代理/","link":"","permalink":"https://super-aviator.github.io/2020/02/05/%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%80%E5%B9%B4%E8%AE%A1%E5%88%92-Java%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E3%80%81%E5%8A%A8%E6%80%81%E3%80%81cglib%E4%BB%A3%E7%90%86/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Proxy","slug":"Proxy","permalink":"https://super-aviator.github.io/tags/Proxy/"}],"author":"熊乾坤"},{"title":"2019-01-10(公司年会)","slug":"2019-01-10","date":"2020-01-17T11:30:00.000Z","updated":"2021-04-03T12:10:52.307Z","comments":true,"path":"2020/01/17/2019-01-10/","link":"","permalink":"https://super-aviator.github.io/2020/01/17/2019-01-10/","excerpt":"","text":"第一次参加年会惹，刚入职公司的我，有幸成为了年会的一位工作人员，苏州的同事也坐大巴过来参加了年会，好吧，反正我是一个都不认识哈哈哈。年会的当天中午去布置了场地，墙上粘贴了各种气球。。。中途还和助理去快递快递公司拿剩下的抱枕，累个半死，出门下雨还忘了带伞，回来裤子湿了半头，不知道的还以为尿裤子了，电梯还被堵了，提着一大袋快递，被几十人围观，尴尬死了。不过年会的过程还是很开心的，我主要负责游戏道具，比较简单，但是中途掉了一次链子，领导上来抖乒乓球的时候，因为领导腰太粗，我系腰带没有系紧，一开场领导的腰带就松了，盒子直接掉了下来。我心里一凉。在被开除的边缘徘徊（手动滑稽）；游戏过程中抖掉的乒乓球还得一个一个捡起来，我承认此刻我的身份从臭逼敲代码的转变为蹲在地上手忙脚乱傻逼捡乒乓球的。。。 事后助理请所有的工作人员吃了大餐，一人一个超级大红包，去唱了歌（好吧，人生第二次）。我也展现了自己的超低音，强行把五月天的《私奔到月球》一首欢快的情歌唱成了男低音的风格。我佛了，嗓子没救了。 最后放几张拍的图片，明年就不会是以工作人员的身份参加了，而会是坐在下面的观众。还是有点舍不得。 整个会场 抽奖时五个人我们组竟然有两个(抽奖后台有没有漏洞.jpg) ![post-35.png](https://resource-1259322763.cos.ap-guangzhou.myqcloud.com/hexo-client/2021/04/03/87c33cb1-0b60-443c-ae38-baf114e4a5fd.png) 最后放一个最近看到的逗比表情，每次看到都想笑","categories":[{"name":"Daily","slug":"Daily","permalink":"https://super-aviator.github.io/categories/Daily/"}],"tags":[],"author":"熊乾坤"},{"title":"元旦快乐","slug":"元旦快乐","date":"2019-12-31T11:57:00.000Z","updated":"2021-02-27T03:19:34.000Z","comments":true,"path":"2019/12/31/元旦快乐/","link":"","permalink":"https://super-aviator.github.io/2019/12/31/%E5%85%83%E6%97%A6%E5%BF%AB%E4%B9%90/","excerpt":"","text":"生活啊，我热爱着你啊，请给我点时间，我在努力呀！ 还有几个小时2020年就要到了，给爸妈打完了电话，明天大姨要卖柑橘，他们明天得赶早过去帮忙摘柑橘。 感觉最近越来越不想说话，内心却有着很多很多的想法，长时间面对电脑，让我习惯了与电脑进行各种不包含任何感情的交互，对于那些无法表达的事和感情，就让它永远埋藏在心中吧。 2019年从象牙塔到职场人，经济开始独立，离开了学校,告别了曾经一起的同学，遇到了一群友爱的同事，一切都慢慢的向好的方向发展。 在2020年即将到来之际，我双手合十，衷心的向老天许愿，虽然我心中已无数次这样想，但是在这个特殊的日子里，我依旧想说：希望老天能够赐给我一个女孩子，她不太会化妆打扮，自然样貌也非倾国倾城，但是却有着一颗细腻的心，温柔体贴、单纯善良，和她在一起时没有任何距离感，我起床时第一个会想起她，睡觉前最后想起的也会是她，她也做着相同的事情，我们遇到任何事都会第一个想起对方；周末我们趟在佘山公园门口的草坪上，彼此诉说着最近遇到的开心和不开心的事，太阳慢慢落下了山，我们慢悠悠的骑着共享单车回到了各自的家，然后我会给她发微信说：我到家了，你呢？不久，收到了她回信：嗯，我也到了，晚安。我回：嗯，晚安； 更新几张最近拍的照片，最后想对自己说：元旦快乐呀你。","categories":[{"name":"Daily","slug":"Daily","permalink":"https://super-aviator.github.io/categories/Daily/"}],"tags":[],"author":"熊乾坤"},{"title":"[转载]MySQL中较大offset值的LIMIT操作的优化","slug":"转载-MySQL中LIMIT较大offset值的优化","date":"2019-12-18T05:41:00.000Z","updated":"2021-02-23T13:00:10.000Z","comments":true,"path":"2019/12/18/转载-MySQL中LIMIT较大offset值的优化/","link":"","permalink":"https://super-aviator.github.io/2019/12/18/%E8%BD%AC%E8%BD%BD-MySQL%E4%B8%ADLIMIT%E8%BE%83%E5%A4%A7offset%E5%80%BC%E7%9A%84%E4%BC%98%E5%8C%96/","excerpt":"","text":"原文地址 优化的主要思路是：因为索引中只保存了行数据的id，没有保存val的值，为了达到过滤不满足WHERE条件的行，MySQL需要根据索引中的id去查val字段，多做了很多不必要的查询，可以先拿到属于LIMIT范围的id，再用id去查想要的数据。 首先说明一下MySQL的版本： mysql&gt; select version(); +-----------+ | version() | +-----------+ | 5.7.17 | +-----------+ 1 row in set (0.00 sec) 表结构： mysql&gt; desc test; +--------+---------------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +--------+---------------------+------+-----+---------+----------------+ | id | bigint(20) unsigned | NO | PRI | NULL | auto_increment | | val | int(10) unsigned | NO | MUL | 0 | | | source | int(10) unsigned | NO | | 0 | | +--------+---------------------+------+-----+---------+----------------+ 3 rows in set (0.00 sec) id为自增主键，val为非唯一索引。 灌入大量数据，共500万： mysql&gt; select count(*) from test; +----------+ | count(*) | +----------+ | 5242882 | +----------+ 1 row in set (4.25 sec) 我们知道，当limit offset rows中的offset很大时，会出现效率问题： mysql&gt; select * from test where val=4 limit 300000,5; +---------+-----+--------+ | id | val | source | +---------+-----+--------+ | 3327622 | 4 | 4 | | 3327632 | 4 | 4 | | 3327642 | 4 | 4 | | 3327652 | 4 | 4 | | 3327662 | 4 | 4 | +---------+-----+--------+ 5 rows in set (15.98 sec) 为了达到相同的目的，我们一般会改写成如下语句： mysql&gt; select * from test a inner join (select id from test where val=4 limit 300000,5) b on a.id=b.id; +---------+-----+--------+---------+ | id | val | source | id | +---------+-----+--------+---------+ | 3327622 | 4 | 4 | 3327622 | | 3327632 | 4 | 4 | 3327632 | | 3327642 | 4 | 4 | 3327642 | | 3327652 | 4 | 4 | 3327652 | | 3327662 | 4 | 4 | 3327662 | +---------+-----+--------+---------+ 5 rows in set (0.38 sec) 时间相差很明显。 为什么会出现上面的结果？我们看一下select * from test where val=4 limit 300000,5;的查询过程： 查询到索引叶子节点数据。根据叶子节点上的主键值去聚簇索引上查询需要的全部字段值。 类似于下面这张图： 像上面这样，需要查询300005次索引节点，查询300005次聚簇索引的数据，最后再将结果过滤掉前300000条，取出最后5条。MySQL耗费了大量随机I/O在查询聚簇索引的数据上，而有300000次随机I/O查询到的数据是不会出现在结果集当中的。 肯定会有人问：既然一开始是利用索引的，为什么不先沿着索引叶子节点查询到最后需要的5个节点，然后再去聚簇索引中查询实际数据。这样只需要5次随机I/O，类似于下面图片的过程： 下面我们实际操作一下来证实上述的推论：为了证实select * from test where val=4 limit 300000,5是扫描300005个索引节点和300005个聚簇索引上的数据节点，我们需要知道MySQL有没有办法统计在一个sql中通过索引节点查询数据节点的次数。我先试了Handler_read_*系列，很遗憾没有一个变量能满足条件。 我只能通过间接的方式来证实： InnoDB中有buffer pool。里面存有最近访问过的数据页，包括数据页和索引页。所以我们需要运行两个sql，来比较buffer pool中的数据页的数量。 预测结果是运行select * from test a inner join (select id from test where val=4 limit 300000,5) b&gt;之后，buffer pool中的数据页的数量远远少于select * from test where val=4 limit 300000,5;对应的数量，因为前一个sql只访问5次数据页，而后一个sql访问300005次数据页。 select * from test where val=4 limit 300000,5 mysql&gt; select index_name,count(*) from information_schema.INNODB_BUFFER_PAGE where INDEX_NAME in(&#39;val&#39;,&#39;primary&#39;) and TABLE_NAME like &#39;%test%&#39; group by index_name; Empty set (0.04 sec) 可以看出，目前buffer pool中没有关于test表的数据页。 mysql&gt; select * from test where val=4 limit 300000,5; +---------+-----+--------+ | id | val | source | +---------+-----+--------+ | 3327622 | 4 | 4 | | 3327632 | 4 | 4 | | 3327642 | 4 | 4 | | 3327652 | 4 | 4 | | 3327662 | 4 | 4 | +---------+-----+--------+ 5 rows in set (26.19 sec) mysql&gt; select index_name,count(*) from information_schema.INNODB_BUFFER_PAGE where INDEX_NAME in(&#39;val&#39;,&#39;primary&#39;) and TABLE_NAME like &#39;%test%&#39; group by index_name; +------------+----------+ | index_name | count(*) | +------------+----------+ | PRIMARY | 4098 | | val | 208 | +------------+----------+ 2 rows in set (0.04 sec) 可以看出，此时buffer pool中关于test表有4098个数据页，208个索引页。select * from test a inner join (select id from test where val=4 limit 300000,5) b&gt;为了防止上次试验的影响，我们需要清空buffer pool，重启mysql。 mysqladmin shutdown /usr/local/bin/mysqld_safe &amp; mysql&gt; select index_name,count(*) from information_schema.INNODB_BUFFER_PAGE where INDEX_NAME in(&#39;val&#39;,&#39;primary&#39;) and TABLE_NAME like &#39;%test%&#39; group by index_name; Empty set (0.03 sec) 运行sql： mysql&gt; select * from test a inner join (select id from test where val=4 limit 300000,5) b on a.id=b.id; +---------+-----+--------+---------+ | id | val | source | id | +---------+-----+--------+---------+ | 3327622 | 4 | 4 | 3327622 | | 3327632 | 4 | 4 | 3327632 | | 3327642 | 4 | 4 | 3327642 | | 3327652 | 4 | 4 | 3327652 | | 3327662 | 4 | 4 | 3327662 | +---------+-----+--------+---------+ 5 rows in set (0.09 sec) mysql&gt; select index_name,count(*) from information_schema.INNODB_BUFFER_PAGE where INDEX_NAME in(&#39;val&#39;,&#39;primary&#39;) and TABLE_NAME like &#39;%test%&#39; group by index_name; +------------+----------+ | index_name | count(*) | +------------+----------+ | PRIMARY | 5 | | val | 390 | +------------+----------+ 2 rows in set (0.03 sec) 我们可以看明显的看出两者的差别：第一个sql加载了4098个数据页到buffer pool，而第二个sql只加载了5个数据页到buffer pool。符合我们的预测。也证实了为什么第一个sql会慢：读取大量的无用数据行（300000），最后却抛弃掉。 而且这会造成一个问题：加载了很多热点不是很高的数据页到buffer pool，会造成buffer pool的污染，占用buffer pool的空间。 遇到的问题 为了在每次重启时确保清空buffer pool，我们需要关闭innodb_buffer_pool_dump_at_shutdown和innodb_buffer_pool_load_at_startup，这两个选项能够控制数据库关闭时dump出buffer pool中的数据和在数据库开启时载入在磁盘上备份buffer pool的数据。","categories":[{"name":"Database","slug":"Database","permalink":"https://super-aviator.github.io/categories/Database/"}],"tags":[],"author":"熊乾坤"},{"title":"2019-12-17","slug":"2019-12-17","date":"2019-12-17T04:01:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2019/12/17/2019-12-17/","link":"","permalink":"https://super-aviator.github.io/2019/12/17/2019-12-17/","excerpt":"","text":"今天中午一个人出去吃饭，去的路上就感觉脖子不太舒服，老是感觉有人在后面拽我衣服。 吃完饭回来的路上，不经意用手摸了摸卫衣，才发现喵了个咪的衣服穿反了。。。哈哈哈，可能是早上起太猛了。","categories":[{"name":"Daily","slug":"Daily","permalink":"https://super-aviator.github.io/categories/Daily/"}],"tags":[],"author":"熊乾坤"},{"title":"2019-12-16","slug":"2019-12-16","date":"2019-12-16T11:49:00.000Z","updated":"2021-02-23T13:00:04.000Z","comments":true,"path":"2019/12/16/2019-12-16/","link":"","permalink":"https://super-aviator.github.io/2019/12/16/2019-12-16/","excerpt":"","text":"作者：匿名用户链接：https://www.zhihu.com/question/313056223/answer/880375432来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ①自卑 这真的是农村穷人家的悲哀，能上大学基本上算懂事的吧。高中每个月200生活费父母嘴上说着别省，别省，可是 只有那么多。你剩下了10快20的他们真的很高兴。你不够了他们会问好几遍这个月怎么不够呢？怎么会不够呢？其实就是怕你乱花。 到了大学，五湖四海的朋友。同宿舍的一双鞋是你两个月的生活费，懂事的你会有什么样的想法？你兼职挣点 ，同学聚会，宿舍聚会去还是不去，同学理解你，不让你出钱，你心里什么感受？父母每次打电话都会告诉你别省。然而你的钱只够自己吃饭的悲哀吗？ 回家给弟弟妹妹买不到5块钱的零食，看着他们雀跃的样子，你心里好像有了一丝安慰。是不是很想早点工作赚钱？ 最悲哀的是毕业了，不是什么985，211。急需一份稳定的工作。不是不敢闯，根本不会去想好吗？一说农村人很多人都喜欢说胆量，自信，魄力。真的非常可笑好吗？ ②从恋爱上面谈。 （智能机之前的年代）农村的大学生首先就是从小乡村学校。一般高中到县城，大学到城市。不富裕的家庭。恋爱是要被鄙视甚至挨打的。真的是很耻辱的一件事。可笑的是到大学家人180度的转折，催你找个好人家。 毕业了，一无所有。 家里借钱盖了新房，希望你找个好姑娘。 你夜里独自流泪，玩着三年没换的小米手机。 翻啊，翻啊…… 好像根本没把这件事放在心上。","categories":[{"name":"Daily","slug":"Daily","permalink":"https://super-aviator.github.io/categories/Daily/"}],"tags":[],"author":"熊乾坤"},{"title":"2019-12-15","slug":"2019-10-15","date":"2019-12-15T14:08:00.000Z","updated":"2021-04-03T12:08:46.098Z","comments":true,"path":"2019/12/15/2019-10-15/","link":"","permalink":"https://super-aviator.github.io/2019/12/15/2019-10-15/","excerpt":"","text":"这周末和张威去了东佘山，本来打算一个人去的，不过和好朋友的一起也会很开心啊。 更新几张拍的图片。 东佘山的观景台，如果没有树的话会好很多啊。 一个人的公园草坪，蚂蚁视角QAQ。 西佘山的教堂和一对老夫妻。 东佘山的两座小山包。。 妈妈，我第一次这么近距离看到直升机。 你用那流不完的眼泪，将我击退。 ![post-22.png](https://resource-1259322763.cos.ap-guangzhou.myqcloud.com/hexo-client/2021/04/03/3a1f764f-d9e2-46d3-be98-01178fb47524.png) 带摄影家 还有什么能够比冬天吃火锅还要爽的事情吗？","categories":[{"name":"Daily","slug":"Daily","permalink":"https://super-aviator.github.io/categories/Daily/"}],"tags":[],"author":"熊乾坤"},{"title":"2019-12-08","slug":"2019-12-15","date":"2019-12-15T12:38:00.000Z","updated":"2021-04-03T12:05:42.652Z","comments":true,"path":"2019/12/15/2019-12-15/","link":"","permalink":"https://super-aviator.github.io/2019/12/15/2019-12-15/","excerpt":"","text":"最近两周的周末和小伙伴们去佘山森林公园玩了几次，爬山、骑车、滑冰（摔了几跤，喵了个咪的屁股现在还在痛T_T。。。），还认识了几个好朋友，虽然他们岁数都比我大很多，但是还是非常感谢他们能够带着我出去玩耍，让我慢慢的走出自闭，发现生活不止眼前的代码，还有田野和远方；不知道下次还有没有机会和他们再见。 更新几张他们拍照片，没有原图，只有压缩以后的图，凑合看吧，记住当时的感觉更加重要，我总是这么安慰自己。。 各方面都很完美的一张图，旁边的张威有点出戏哦，哈哈哈，可爱的剪刀手女孩，特意从宝山区赶过来。对会画画的女孩子没有抵抗力啊啊啊啊，何况还这么文静、可爱，已经毕业了6年了，希望以后能够有缘再相见。 2019-12-08.png)很友好的老外，几次尝试用英语和我沟通后无(T_T)。书到用时方恨少。 落日下的骑行，是我逝去的青春。 我们在上海有房子啦啦啦 emmmm 离她更近一些了呢；你说爱情需要距离，你说等待是一种美丽，我同意。 从田野里跑出的两只小狗，让伙伴们高兴了很久。 完美。 美好的心情从那天开始，大家有缘再见啦，我爱你们。","categories":[{"name":"Daily","slug":"Daily","permalink":"https://super-aviator.github.io/categories/Daily/"}],"tags":[],"author":"熊乾坤"},{"title":"博客转载-颖诺","slug":"客转载","date":"2019-12-07T09:10:00.000Z","updated":"2021-04-03T12:19:08.255Z","comments":true,"path":"2019/12/07/客转载/","link":"","permalink":"https://super-aviator.github.io/2019/12/07/%E5%AE%A2%E8%BD%AC%E8%BD%BD/","excerpt":"","text":"分开的往昔谷底，是谁，又在轻声呼唤。想起了她。想起了她。让我，仍会想起了她。想起了她。想起了她。是谁，让我想起了她。南边的风依然的湿，暖暖地掠过这溪底。装满我这一刻落寂。又回头时候，迷离。想起了她。想起了她。是谁，让我想起了她。想起了她。想起了她。让我，又会想起了她。你飞。啦啦哩咧哩。。别回头，在心口，这纷纷扰扰。你飞。哩哩咧哩咧。。别去。争吵抱歉的槐树。想起了她。想起了她。我，又在想起了她。想起了她。想起了她。是谁，让我想起了她。 《想起了她》 最近在网上不经意间看到了一个写很好的博客，记录了大学和工作发生的事情，每一篇博客读的时候都有种莫名的感动和共鸣，也许是处境相同的原因吧，每一篇文章我都会认真看，如果以后找女朋友的话一定要找博客里面这种心思细腻的小女生，哈哈。 博客已经2015年停止了更新，趁着今天周六有时间，想把它们转载过来，没事看一看，再也不用仍受手机上新浪博客蛋疼的网速了，虽然没有经过博主的同意，但是相信那么可爱善良喜欢自由的她会同意的，博客里面还有一些她画的漫画，我也会一并拿过来，由于她当时应该是初学，所以画的不是那么细腻，但是真的画的很用心，是我喜欢的卡通类型，很像高中时候很喜欢看的《儿童文学》杂志里面的插画，那些涉及到私人的照片的话就不转了吧。（电脑存一份比较好。以后看。T_T） 颖诺的博客 路我们谁也不能承诺些什么，抹去以往的蓝色和灰色，让自己从新面对生活….玫瑰是美丽的，爱情或许也是美丽的，但我感觉却是一种无形的伤害…….让我们永远在一起，我再也不要听你说这话了…..一切都是谎言….不管什么也要让自己每天开开心心，对着自己笑一下….原谅……….我要学会一个人好好生活…. 这有一种思念会让我们失魂落魄，总有一种灵魂指引我们方向，总有一支歌即使唱了千万遍却还是那么让人伤感，总有一种梦永远不成醒来，总有一种爱说不清楚……每件事情的发生都是有它原因的，不要想太多，没必要把自己搞得失魂落魄，只要自己开心就好，水随风去，山还在。想让自己不再迷茫，可曾经的天使已不再等待….我告诉自己要坚强，可太坚强心也会累….一直记得一句话：千万不要为不能为你哭泣的任何东西哭泣。哦….我茫然了….只要天空还记得我们的存在，就无所谓爱与不爱…..幸福有时候只是一种感觉….. 亲爱的朋友，我爱你们亲爱的朋友们，好想你们，好想好想你们。好想我们在一起走过的路，我们在一起开心的笑。轻轻的翻开岁月的照片，一页页，留下了我们了最珍贵的记忆，看着当时的我们，好开心，好幸福。我们一起去英雄山，一起去植物园，一起去雁翅山，泉城广场，还有武汉的黄鹤楼，东湖，植物园…..每一次都充满了太多的美好记忆。…… 每次去爬山都是我第一个到达山顶，然后得意的向你们招手，你们笑我，我好开心。每次为了拍出搞笑的照片，我可以摆出各种好玩的动作和招牌动作，你们就在笑，但我从来都无所谓，只要大家在一起开心就好。你们总说有我的地方就少不了欢笑，有我的地方就从来不会有烦恼。记得有一次，和萧，晴我们一起去爬雁翅山，为了在山上体验夜晚的天空景色，我们一直在山顶待到七点多。天黑了，我们好害怕，想象着一切可能发生的恐怖事情。我们匆忙的跑到山下，却发现山下入口的门已经锁了。我们好害怕，怎么办？？出不去了….突然惊奇的发现门旁有一洞，大概可以钻出一人。我兴奋得说:”有狗洞！”晴说:”我们钻狗洞吧!”但那里有好多水，萧说：“我们再找找吧，看还有出口吗？”三个女生手牵手在黑暗中摸索，最终凭借我们的智慧历尽重重困难一个多小时后我们从山上走了下来拍拍衣服上的灰尘，我们开心的笑了……我们学会了野外生存。 有一次刘滨，真，晴，冲我们一起去英雄山玩，那天我们有好多新的发现。那一带我们走过了马鞍山，五里山，六里山，最终到达英雄山。我们在山顶野餐，因为路途太远，大家都没带多少食物，除了简单的面包可乐之外。我们好开心。记得晴拍了一张照片是两手抓吊环，我们都说像是在上吊，然后大家就笑。还有秋，虽然我经常和刘滨他们一起出去玩秋有时不去，但我总能时时想着她，想着她在干嘛，她说不见我也一直在想我，我们总是那么的心灵相通。还有薛金征他们，和他们在一起总是那么的开心。 还有江南，美术考完他连觉都没睡陪我在植物园玩了一天，我们钻鬼屋，去城堡，海盗船，天翻地覆，天旋地转，我们玩了好多，开心的去喂鸽子，看着它们那么贪婪，我开心极了。还有马腾，张铭玺，燕姐，小文，王文龙，刘全义，守利，小马，sailei他们，我们在一起经历了那么多的开心和不开心，大家都对我很好，在那里我总是好感动。 在二中，刘滨，王双，老朱，奎子，大盛，大振，樊腾，小婉小跃……他们，他们总能逗我开心。大家都说我是班里的开心果，有了我们，就总是那么的活跃。 后来我和秋，萧，老胡我们四人去了嘉祥一中，那是我高中学习最紧张的一年，那里的一切对我们来说都是那么的陌生，那么的严厉和苛刻，我们无能为力，只能适应。但我们还是在不知不觉中违了好多在我们眼里不是规定的规定。银娃（我们班主任那老头）老是找我，我无所谓，我本来就喜欢自由，不过还是尽量避免啦。我们四人在一起总能够有开不完的玩笑，说不完的话；老胡总喜欢贬低我，我们也喜欢扁他，他说因为我好玩，他总叫我小孩。我说看在银娃教导的份上不和你计较，我们说完就笑，在一起最多的就是开心，就是笑。在那里我也认识了好多新朋友，拉拉，莹子，春梅，刘然，还有小妮子…..他们都对我好好，给了我很多帮助，很感谢她们。后来高考到来了，我们四个人也没感觉到有什么特别，考场上答案也传来传去，那是我们在一起探讨了几天的计划和高超技艺。数学好难，考完之后我们班学生都哭了。但我们好像什么也没发生，跑到草地上去玩我们的，我们打打闹闹说说笑笑，好开心。班主任银娃看到了好无奈。 他看到我们班学生都在哭不吃饭就大肆训斥起来：“你们要像张爽学习她那心态，但也不要只玩忘了学习！”我无语…..@@ 后来成绩下来了，我数学奇迹的考了99分，那是高三以来最高的一次，也是唯一及格的一次。 暑假过去了，我们就分开了，都来到了各自的大学。我到了湖北大学，在这里有认识了好多新的朋友，他们都很好；还有我们寝室一群动物们（都有自己的动物名字），大家子一起永远都好开心 &amp; 。 因为快期末考试了，今天在图书馆看书，突然的发现我是那么的害怕孤独，好怕好怕。但记得出去学画画时语文老师意味深长的告诉我：“一个人想要有所作为，你就要耐得住孤独和寂寞。历史上有好多伟人的例子。”我一遍遍的告诉自己：“我是张爽，我要学会不怕孤独！我是最坚强的女生！为自己加油！”为我最亲爱的朋友加油！我爱你们！！！ 宁静我喜欢独自漫步在校园里，一个人的宁静，一个人的潇洒….看着身边匆匆忙忙的人们，想停止想象自己也在忙碌什么，，喜欢这种宁静，喜欢这种漫步，喜欢这种一个人的世界，脑子是白色的，纸一样的纯净。 我喜欢一个人的漫步，体验内心的片刻宁静，没有浮华，没有喧嚣，只有一个人的浪漫，只有一个人的空间。我喜欢这种漫步，这是自我内心的对白，这是心灵深处的沉思。 我喜欢这种一个人的遐想，那么唯美，那么单纯…..感觉自己飘渺了，和空气化为一体，随风飘动，自由迷茫，去寻找白云蓝天，想象着自己可以飘向云端，去摘取那凝结的露珠，化作最甜的甘露，浇灌饥渴的像我一样的心田；想象着自己可以飘向月亮，去抚摸嫦娥的玉兔，安慰她思念的灵魂。喜欢这种一个人的潇洒，没有拘束，没有任何忧虑….看，一枚枫叶从树上飘飘落下，那么轻盈，那么洒脱，我轻轻走过去，又怕惊醒她的梦，悄悄把它捡起，慢慢的画上了半颗心，然后把它放飞到远方，去寻找另一半的心…… 好想小Q，好想我们一起走过的日子，我们在一起的八年，一秒一秒的放映在了脑海里，我们一起嬉戏，一起欢笑，一起无聊，无聊的有聊，不管发生什么事，我们总是开心的….那时好美好，一切都是美丽的，一切都是浪漫的。我一直把小Q当做姐姐，，不管发生了什么，我们总是坚强的笑着一起走过。还记得，我们一起吃饭，一起逃课，一起网吧通宵，一起想办法找理由怎么欺骗当时的老班（那个可爱的老头），虽然在当时是不对的，但那也是生命韵律线上的美丽跳动的音符…..好想我们大学还能在一个学校，但这已不是一个现实…….所有的一切只能是一个记忆…美好的回忆…..永远的心心相惜…… 愿我的朋友永远快乐幸福，愿我们的未来更加美好！！！………. 2010年02月05日 突然的抬头仰望， 天空是不是随时都在变换着它的色彩， 总让我迷失在蓝紫色的梦幻， 漠然的回首， 发现却还是迷失的尽头， 多么希望一个人坚强的走到最后， 世间却又没有自己想象的那么简单， 繁杂的世俗还要我们去面对， 有些的无理取闹， 让我们感觉好无奈， 时间的长大， 好多事情总要我们自己一个人去解决， 有些无聊，有些无奈， 却又一遍遍的告诉自己要坚强， 坚强也需要代价， 代价却又包含着太多的故事， 经历让我们成长， 有时有些迷茫，有时有些感伤， 幻想着美丽天使的再次出现， 指引我方向。。。 2010年02月28日每次看到你信息，感觉都有一种触动心弦的力量，像柔软的针，带着你那我再也感受不到的温柔，在心底摇曳，你的身影又浮现在我的眼前，我不想再想起那身影，因为那已不再属于我…… 时间确实可以证明一切，你的复杂我的简单，一切的一切都伴随着我们的分开而走上了自己的轨迹…..笑过了，想过了，爱过了，痛过了，思过了，哭过了，一切也都伴随着泪水和笑声结束了……天水相依处的许诺也已在涟漪中稀释的无影无踪，只留下一道华丽的伤疤，或许有一天时间也会把它冲淡……我不想想了….. 无处的飞翔 春天似乎终于打败了寒气袭人的冬天迟迟的来了 来的那么突然 来的那么缓慢 一个人静静地走过校园 抬头看那西边的落日 想去寻找心灵的足迹 才发现一切都是那么茫然 所有的遐想都好像乌云 藏在惬意的背后 只想一个人安静的思考 只想一个人安静的漫步 我看到了四叶草在对我微笑 我知道它是幸福美好幸运的象征 想把它摘下让它带着我的梦去飞翔 可我不想让它哭泣 我只想一个人去追逐梦想 站在风的源头迎风飘摇 我不知会飘向哪里 我只想曾经自由的飞过 我听到了小鸟的笑声 我看到了星星的微笑 我只记得曾经自由的飞过 武汉的夜晚依旧是忧郁的蓝色 校园里也少了一些白日的喧闹 却多了阵阵冷风的抚伴 只想一个人坐在草地上安静的遐想 昨天，今天，明天 思绪是迷乱的乐章 奏响杂乱的年华 我想起了你们 想起了曾经的我们 曾经的那个教室 曾经的那些快乐与悲伤 我们曾经那么自由的开心着 突然的发现我们都要长大了 要变得成熟了，沉稳了，圆滑了 破碎的彩色球依旧耀眼的发着光 听着自己内心那个竭力的呐喊声我不想长大 单纯的我们将要飘向哪里 我不想想了 抬头仰望 迎着风的方向 一个人坚强的去飞翔。。。 2010年04月07日 好想静下心来好好画一下画， 却发现自己是那么的聒噪不安 浮华的尘世吹拂着浮华的梦 依旧是未知的归路 每个人都有一个自己的世界 在那里奔跑欢笑 我想逃离自己了。。。 2010年05月13日 画了一张魔兔山，它蕴含着一种超粒子能量，当人类走进时，它可净化人的心灵，也可以使人变得更加的邪恶… 这是第一张上色的PS画， 2010年05月13日喜欢上了一种阳光的味道，安静中带着追求唯美。喜欢走在那条被人已忽略的小路，倾听它的声音，我们彼此诉说着自己的快乐知远方的飞碟什么时候降落，我只想静静的等待，等待你的出现远方的小鸟怎么飞走了，我还没来的及给你说声再见呢小花也再眉梢微笑了… 2010年05月21日真不敢相信自己马上就要大三了，一直以为自己的大一还没过完，时间在行走，我却没有和它同步，多想它能驻足等我一下。 多少次，望着窗外，一个人静静地发呆，看飘来飘去的白云，伸出合十的双手，许下一个个小小愿望。 只想一个人静静地站在雨中，静静地听着雨滴打在手中小伞上声音，在内心深处卷起阵阵涟漪，看形色匆匆的人群，一个人沉浸着。 打开电脑，看着它的屏幕，一阵的沉默，却又茫然的不知做什么好，看着未完成的画，还是继续吧，画画也是一个人的浪漫。 一个人安静的听着悲伤地音乐，一个人陶醉在自己的舞蹈中，面对着舞蹈房的镜子还是开心的笑着。 曾经无数次的擦肩而过，依旧是擦肩而过，想着在下一个路口我们会相见，却每次只是想象，一个人的世界，一个人悲伤着又快乐着。 好像静下心来去做一件有意义的事情，即使身心疲惫，我也会开心。。。 2010年05月21日 蒲公英的爱喜欢你的轻盈，喜欢你的洒脱，把我的梦带去和你同行，飞到更远的地方。。。。 小爽加油！！！嗯，小坤你也加油！！！ 片栖喜欢一个人的遐想。。。 喜欢一个人的世界。。。 喜欢一个人的疯狂。。。 喜欢一个人的安静。。。 喜欢一个人的无聊。。. 喜欢一个人的微笑。。。 青春的记忆突然间感觉周围人都在长大，而我却依然是个孩子，小白说是因为别人都在变的沉稳而我却疯疯癫癫， 曾经不止一次的想过我要做个淑女，但事实证明这条路对我行不通， 好想让自己变的沉稳一些，却又改变不了爱吵爱闹的性格， 总是真心的对待身边的每一个人，以为我们都是真心，却有时伤害的也是自己， 好想让自己变的成熟一些，在我的字典里它却是那么的朦胧， 好想让自己静下心来思考一下，却发现时间在一分一秒的流逝，赶紧跑到工作室打开电脑继续ps，3D,maya, 好想和朋友一起去happy，大家有时也同样好忙， 好想找个蓝颜知己，像高中时候的朋友一样去玩，互相畅谈，却发现现在的自己，大学过的好悲哀， 好现在大学谈一场轰轰烈烈真正的恋爱，却没有一个真正喜欢的人，有时会安静的走过学校的每一个路口，纵使无数次的擦肩而过却没有一次回眸， 经常听朋友告诉我，没有男生会无缘无故对你好，他们都是有目的的，让我感觉好恐怖，是不是我们到了这个年龄就是为谈恋爱而谈恋爱， 为什么别人都在长大，我却还像个小孩子一样，小猴子说我太单纯，单纯是什么， 好想一个人去旅行，放下一切繁琐事情的压抑， 好吧，我食言了，这会是有且仅有的一张，sorry 许还是做回真正的自己吧，像小时候一样抱着大熊去小北湖旁吹蒲公英，我吹着，它看着，我和它的梦一起飞向远方，化成一副美丽的水彩画， 2010年07月09日暑假已经开始一个多星期了，这几天基本上都是晚上3点睡觉，早晨或八点或九点或十点的样子起床，看来要改变一下我的休息时间了 ，在这样下去就崩溃了啊， 喜欢每天画下小画，做下简单的小动画，虽然生活过的很简单，但感觉还是很开心， 就喜欢这样简简单单，自由自在，喜欢和你一起出去玩，喜欢拍拍小照片， 感觉自己就像一个长不大的孩子，那就不要长大吧，只要每天开心一点就好， 武汉的天气好热，热的我好有回家的冲动， 画画 画画 2010年07月20日 那一天我们玩的好开心， 那一年我们过得好匆忙， 昨晚夜色很美，却没有你们的陪伴， 我一个人独享着， 星星你为什么叫星星， 月亮你为什么叫月亮， 我一遍遍追问着自己这幼稚的问题， 它们也调皮的向我眨下眼睛， 我好想你们，我最亲爱的朋友们。 好想我们在一起的日子， 那时我们单纯，我们快乐， 不管遇到什么， 总是会笑的肆无忌惮， 可是现在我们飘向了全国的各个角落， 大家马上就要面临了毕业， 原来我们都长大了。。。 想到我们再也不能像以前那样每天在一起， 总是玩的那么疯狂， 哎，我们总要长大了， 未来还等着我们去探索， 亲爱的朋友们让我们一起加油！ 大学里的你们，我亲爱的朋友们， 和你们在一起我总是那么的快乐， 两年里， 你们教会了我太多太多， 谢谢你们，你们总是对我那么好， 时间总是那么的不嫌累， 转眼间两年走完了，好佩服时间大哥啊。。。 时间能不能让我不再想起你， 一个人走在夜色下的操场上， 感觉一切停止了呼吸， 真让自己永远的跑下去，没有终点，没有思虑， 但我没有，只是想让自己安静一下， 我不想再想起你， 现在每次和你在一起， 我总不能让自己安静下来， 因为一安静我脑海里全是你， 我会在那瞬间强迫自己清醒， 我不知道有一种什么的感觉冲刺着我的全身， 我好害怕自己再次陷进这种没有结局的游戏， 因为一切都已结束。。。 一个人站在拥挤的公交车上， 让我总是随着公车倒来倒去， 其实我总想起你， 如果你在，我就不用抓着扶手， 你总会用你的手臂保护着我， 让我依偎着你，忘掉一切， 只是那一瞬间突然有些想你， 我会让自己不再去想， 或者我就会有一种想吐的感觉， 那天回来的路上和你坐在一起， 因为昨晚没睡好，我困死了， 只是不敢让自己闭上眼睛， 我很怕会在梦中看到你， 我只想让自己清醒下去。。。 2010年07月20日蓝天下我们那么的疯狂。。。。一个人陶醉在阳光下。。。好开心。。。亲爱的小兔子。。。 2010年07月20日 那天晚上我来到了精灵国，我看到了精灵公主和精灵王子，我一直飞呀，飞呀。。。 直到第二天来了~ 哈哈精灵国真的好漂亮~ ~ 2010年08月11日那天我看到了好多萤火虫，我站在原地静静地观看着他们，那么唯美，黑暗中闪耀着点点光晕，那么的自由自在，真怀疑他们是不是外星来的小生物。。。 放下了，一切都放下了，，，只是当我看到那一幕的时候我的心还是有种说不出的悲凉。。。 平静，快平静下来，，，让我找到我的方向。。。 有时候自己还是那么的任性，是到我们该长大的时候了~~ 有时候自己突然失去了一切动力，不知道要做些什么，是乎总需要有人在背后鞭策一下，提醒一下。。。 喜欢玩，即使在户外在游乐场晒得像熊猫一样，也还怡然自得~~ 哎 我要好好思考一下了。。。 2010年08月11日喜欢用照片记录生命中的每一个时刻，，，即使有人说我疯狂，，，有时人是要活在自己的生活中一下，，，这是心灵的对白，，， 不知道想说什么，，，一个人的日子总是那么淡淡的忧伤，，，每天一个人呆在工作室总有些凄凉，，， 一个人在上海打拼总有些孤单，，， 哎呀呀 2010年08月12日 2010年09月03日 2010年09月13日 每个人心中都有一颗小太阳, 即使乌云暂时遮蔽了它, 但它的光芒依然照亮了世界. 每天都有太多的想象, 迫不及待的去寻找答案, 却总是把路的方向忘记. 有时心情异常聒噪, 就来寻找寄托, 寄托心情的萤火虫却已飞的无影无踪. 2010年09月19日 异我偷偷藏在了草丛的背后，想永远的躲避，躲避那些繁杂。。。 2010年09月20日 为 mv拍摄的图片~~我们寝室的 熊爸爸 熊妈妈 熊宝宝~~ 沙湖的两条船~ 喜欢 么么 ~ 沙湖旁的风景~ 唯美的说 学校沙湖旁的花~ 很美呢 ~ 沙湖旁的一棵长的挺有感觉的树~ ~ 沙湖水~ ~ 一个人喜欢去的地方~ ~ 和念姐~ 么么 ~ 喜欢的即将沉没的两条小船~ ~ 我的loves~ ~ 记忆~ ~ 为 mv拍摄的图片~~自拍桌面背景图片么么","categories":[{"name":"Daily","slug":"Daily","permalink":"https://super-aviator.github.io/categories/Daily/"}],"tags":[],"author":"熊乾坤"},{"title":"2019-12-7","slug":"2019-12-7","date":"2019-12-07T09:06:00.000Z","updated":"2021-02-23T13:00:10.000Z","comments":true,"path":"2019/12/07/2019-12-7/","link":"","permalink":"https://super-aviator.github.io/2019/12/07/2019-12-7/","excerpt":"","text":"最近两周的生活和工作的状态很差，仿佛一切人和事都失去了意义，人生一望到头，生死已经看淡；这种感觉以前偶尔会有，但是在最近却又卷土重来，每天被一些悲伤、负面的情绪所吞噬，耳机里一首悲伤的歌曲能够循环一整天。 尝试着听一些积极向上的歌曲，做一些让自己兴奋的事，想把自己从痛苦的深渊里面拽回来，但是都无济于事。 但是我始终相信这种状态是暂时的，时间会改变一切，一切都会好起来，每天带上面具去生活也不是不可以，慢慢习惯了不就好了，人总需要学会成长。 以后会话更多的时间记录一下生活相关的东西，虽然就像我和别人说的，自己文笔很差，写出来的句子都读不通。但是我觉得只要是掏心窝子的话，自己以后会看懂。 过两周会面临自己人生中的第一次出差，人生会有许多美妙的第一次，加油啊你。","categories":[{"name":"Daily","slug":"Daily","permalink":"https://super-aviator.github.io/categories/Daily/"}],"tags":[],"author":"熊乾坤"},{"title":"第一个一年计划-Spring Data Jpa中使用Example和Specification构建动态查询SQL语句","slug":"第一个一年计划-Spring-Data-Jpa中使用Example和Specification构建动态查询语句","date":"2019-11-16T10:39:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2019/11/16/第一个一年计划-Spring-Data-Jpa中使用Example和Specification构建动态查询语句/","link":"","permalink":"https://super-aviator.github.io/2019/11/16/%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%80%E5%B9%B4%E8%AE%A1%E5%88%92-Spring-Data-Jpa%E4%B8%AD%E4%BD%BF%E7%94%A8Example%E5%92%8CSpecification%E6%9E%84%E5%BB%BA%E5%8A%A8%E6%80%81%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"在知乎中看到了这样一篇关于Spring Data Jpa和Mybatis优缺点总结：Spring Data Jpa在查询时做的一塌糊涂，而Mybatis在插入时做的一塌糊涂；今天晚上抽空来学习一下JPA中，如果去构建动态查询语句，看一看JPA如何去构建动态查询。正好下周的1.5版本的迭代任务会用到差不多7个查询参数的动态SQL查询的需求，为了到时候能够完美的完成开发任务，一定要好好了解一下惹。 定义实体类和Repository学习的过程中，还是使用以前建立的User实体类，所有的测试都在User实体类上执行，对应的实体类和Repository代码如下： import com.fasterxml.jackson.annotation.JsonIgnoreProperties; import com.xqk.learn.springboot.data.jpa.common.Gender; import lombok.Data; import javax.persistence.*; import java.util.Date; import java.util.Set; /** * The type User. * * @author Aviator */ @Data @Entity @Table(name = &quot;USER&quot;) @NamedEntityGraph( name = &quot;UserEntity&quot;, attributeNodes = &#123; @NamedAttributeNode(&quot;userDetail&quot;), @NamedAttributeNode(&quot;userFriends&quot;), @NamedAttributeNode(&quot;teachers&quot;), &#125; ) public class User &#123; @Id @GeneratedValue private Long id; /** * 使用version字段实现乐观锁，乐观锁的测试代码在OptimisticLockTest类中 */ @Version @Column(name = &quot;version&quot;) private Long version; @Column(name = &quot;NAME&quot;) private String name; @Column(name = &quot;EMAIL&quot;) private String email; @Column(name = &quot;ADDRESS&quot;) private String address; @Enumerated(EnumType.STRING) @Column(name = &quot;GENDER&quot;) private Gender gender; @Column(name = &quot;SCORE&quot;) private Integer score; @Column(name = &quot;BIRTHDAY&quot;) private Date birthday; &#125; 对应的Repository就不展示了吧。 Example构建动态查询语句在了解Example之前，先学习一下其缺点，只有知道了能实现什么，不能实现什么，就能够进行有目标性的学习： 支持动态查询。即支持查询条件个数不固定的情况，如：客户列表中有多个过滤条件，用户使用时在“地址”查询框中输入了值，就需要按地址进行过滤，如果没有输入值，就忽略这个过滤条件。对应的实现是，在构建查询条件Customer对象时，将address属性值设置为具体的条件值或设置为null。 不支持过滤条件分组。即不支持过滤条件用or（或）来连接，所有的过滤查件，都是简单一层的用and（并且）连接。如firstname = ?0 or (firstname = ?1 and lastname = ?2)。 仅支持字符串的开始/包含/结束/正则表达式匹配和其他属性类型的精确匹配。查询时，对一个要进行匹配的属性（如：姓名name），只能传入一个过滤条件值，如以Customer为例，要查询姓“刘”的客户，“刘”这个条件值就存储在表示条件对象的Customer对象的name属性中，针对于“姓名”的过滤也只有这么一个存储过滤值的位置，没办法同时传入两个过滤值。正是由于这个限制，有些查询是没办法支持的，例如要查询某个时间段内添加的客户，对应的属性是addTime，需要传入“开始时间”和“结束时间”两个条件值，而这种查询方式没有存两个值的位置，所以就没办法完成这样的查询。 构成一个Example对象由一个probe,一个ExampleMatcher构成。可以从下面Example的源码中知道： public interface Example&lt;T&gt; &#123; /** * Create a new &#123;@link Example&#125; including all non-null properties by default. * * @param probe must not be &#123;@literal null&#125;. * @return */ static &lt;T&gt; Example&lt;T&gt; of(T probe) &#123; return new TypedExample&lt;&gt;(probe, ExampleMatcher.matching()); &#125; /** * Create a new &#123;@link Example&#125; using the given &#123;@link ExampleMatcher&#125;. * * @param probe must not be &#123;@literal null&#125;. * @param matcher must not be &#123;@literal null&#125;. * @return */ static &lt;T&gt; Example&lt;T&gt; of(T probe, ExampleMatcher matcher) &#123; return new TypedExample&lt;&gt;(probe, matcher); &#125; &#125; 而probe就是数据库表对应的实体类，这个实体类中装载着我们想要配置的值。而ExampleMatcher则定义了这些值对应的匹配规则，构建ExampleMatcher时需要考虑到如下几点： Null值的处理。当某个条件值为Null时，是应当忽略这个过滤条件呢，还是应当去匹配数据库表中该字段值是Null的记录？Null值处理方式：默认值是IGNORE（忽略），即当条件值为null时，则忽略此过滤条件，一般业务也是采用这种方式就可满足。当需100要查询数据库表中属性为null的记录时，可将值设为INCLUDE，这时，对于不需要参与查询的属性，都必须添加到忽略列表（ignoredPaths）中，否则会出现查不到数据的情况。 基本类型的处理。如客户Customer对象中的年龄age是int型的，当页面不传入条件值时，它默认是0，是有值的，那是否参与查询呢？关于基本数据类型处理方式：实体对象中，避免使用基本数据类型，采用包装器类型。如果已经采用了基本类型，而这个属性查询时不需要进行过滤，则把它添加到忽略列表（ignoredPaths）中。 忽略某些属性值。一个实体对象，有许多个属性，是否每个属性都参与过滤？是否可以忽略某些属性？ignoredPaths：虽然某些字段里面有值或者设置了其他匹配规则，只要放在ignoredPaths中，就会忽略此字段的，不作为过滤条件。 不同的过滤方式。同样是作为String值，可能“姓名”希望精确匹配，“地址”希望模糊匹配，如何做到？默认配置和特殊配置混合使用：默认创建匹配器时，字符串采用的是精确匹配、不忽略大小写，可以通过操作方法改变这种默认匹配，以满足大多数查询条件的需要，如将“字符串匹配方式”改为CONTAINING（包含，模糊匹配），这是比较常用的情况。对于个别属性需要特定的查询方式，可以通过配置“属性特定查询方式”来满足要求，设置propertySpecifiers的值即可。 大小写匹配。字符串匹配时，有时可能希望忽略大小写，有时则不忽略，如何做到？defaultIgnoreCase：忽略大小写的生效与否，是依赖于数据库的。例如MySQL数据库中，默认创建表结构时，字段是已经忽略大小写的，所以这个配置与否，都是忽略的。如果业务需要严格区分大小写，可以改变数据库表结构属性来实现。 ExampleMatcher默认是忽略null值的，如果有想要查询值为null的情况，则需要使用ExampleMatcher.withNullHandler(ExampleMatcher.NullHandler.IGNORE)的方式开启null的匹配。上面的方式是将实体类总的所有字段都开启null匹配。 完整的示例代码如下： import com.xqk.learn.springboot.data.jpa.entity.User; import com.xqk.learn.springboot.data.jpa.repository.UserJpaRepository; import org.springframework.data.domain.Example; import org.springframework.data.domain.ExampleMatcher; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.List; import java.util.Optional; /** * @author Aviator */ @RestController @RequestMapping(&quot;exam&quot;) public class ExampleController &#123; private final UserJpaRepository userJpaRepository; public ExampleController(UserJpaRepository userJpaRepository) &#123; this.userJpaRepository = userJpaRepository; &#125; @GetMapping(&quot;findUser&quot;) public List&lt;User&gt; findByExample(User user) &#123; ExampleMatcher exampleMatcher = ExampleMatcher //查询条件之间使用and拼接 .matching() //查询条件之间使用or拼接 //.matchingAny() //忽略null值，即为null的字段不参与查询 //.withNullHandler(ExampleMatcher.NullHandler.IGNORE) .withNullHandler(ExampleMatcher.NullHandler.IGNORE) //User类的字符串字段匹配规则为containing .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING) //email字段使用全值匹配的方式进行匹配 .withMatcher(&quot;email&quot;, ExampleMatcher.GenericPropertyMatcher.of(ExampleMatcher.StringMatcher.EXACT, true)) //.withMatcher(&quot;address&quot;,ExampleMatcher.GenericPropertyMatcher.of(ExampleMatcher.StringMatcher.EXACT,true ).transform(Optional::ofNullable)) //忽略如下字段的匹配 .withIgnorePaths(&quot;version&quot;); Example&lt;User&gt; userExample = Example.of(user, exampleMatcher); return userJpaRepository.findAll(userExample); &#125; &#125; Specification构建动态查询语句首先看一下Spring Data JPA中提供的Specification接口，接口中只有一个方法： public interface Specification&lt;T&gt; extends Serializable &#123; Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, ` CriteriaBuilder criteriaBuilder); &#125; Specification是Spring对JPA的封装，最终要的还是看一下构建动态查询语句会用到的三个对象： RootRoot对象保存了数据库表中的字段，可以理解为如果想要获取到某张表的字段，则需要首先构建一个这张表的Root对象，然后使用get方法，将实体列中的字段名作为参数，获取到该字段的Path对象。 Root对象可以使用Criterial.from(Class)方法来获取，例如： Root&lt;User&gt; userRoot = query.from(User.class); query.groupBy(userRoot.get(&quot;score&quot;)); 上面的代码中，groupBy需要User表中某个字段，可以使用get方法来获取到该字段。 CriteriaQueryCriteriaQuery对象可以理解为整个SQL语句的主体框架，可以使用此对象，来构建查询语句中例如SELECT、WHERE、ORDER BY、HAVING等，是构建查询语句最重要的对象。 CriteriaQuery对象可以通过CriterialBuilder.createQuery方法来获取： CriteriaQuery&lt;FindUser&gt; query = builder.createQuery(FindUser.class); 值得注意的是，CriterialQuery中的泛型参数不一定必须是实体类，如果想要SQL语句返回某种类型的对象，则其泛型参数就必须该对象。后面在实战的时候再去理解。 CriterialBuilderCriterialBuilder对象用来构建查询语句中的谓词，对于SQL中的LIKE、=、&gt;=，&lt;=，此对象都有对象的方法来实现。 CritierBuilder对象可以直接从EntityManager对象的getCriteriaBuilder方法获取，正因为他不是泛型的，表明它和对象或实体类没有关系，只是一个工具类，用来构建谓词或其他的Criterial对象。 为了加深对着三个对象的理解，可以看一下下面这个图，只需要记住对象在一个SQL语句中的职责，构建动态查询是非常简单的。 实战在介绍完三个重要的对象后，来学习一下如何构建稍微复杂一点的SQL语句作为结束。更加深入的研究还得靠以后的使用过程中去慢慢进行。 SELECT NAME,GROUP_CONCAT(ADDRESS) AS ADDRESS_CONCAT,SUM(SCORE) AS SUM_SOCRE,ENROLLMENT_DATE FROM user AS A INNER JOIN user_detail AS B ON A.ID=B.ID WHERE NAME LIKE &#39;%1%&#39; GROUP BY SCORE HAVING SUM_SOCRE &gt; 1; 上面的SQL中，使用到了分组和过滤，同时使用到了两个聚合函数。和表连接，还算是比较的复杂。看一下如何去使用JPA去实现这样的SQL语句和自己在学习中的慢慢摸索的思路。 首先SQL使用到了两张表，User和UserDetail，并且返回的列并不是一个完整的实体类，但是在Spring Data JPA中封装的Specificaion接口里面，三个Criterial对象的泛型参数都是统一的entity实体类，查询的结果也是单个实体类或集合，所以这时候不能够使用Spring Data JPA去实现，要使用原生的方式去做。 在开始之前，首先需要创建一个类，用于接收查询参数： import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; /** * @author 熊乾坤 * @since 2019-11-24 13:41 */ @Data @AllArgsConstructor @NoArgsConstructor public class UserRequest &#123; private String name; private Long scoreSum; &#125; 然后需要使用EntityManager对象创建一个CriterialBuider对象，此对象用于构建其他两个需要用到的查询对象CriteriaQuery、Root。 private final EntityManager entityManager; public SpecificationController(EntityManager entityManager) &#123; this.entityManager = entityManager; &#125; CriteriaBuilder builder = entityManager.getCriteriaBuilder(); 在上面说到，CriterialQuery中的泛型参数的类型是整个SQL语句返回的对象类型，可以是实体类或其他用于接收参数结果的类，所以，首先需要创建一个类，用于接收SQL语句中返回的参数，根据SQL中的元素类型，个数，顺序，创建下面这个类： import com.xqk.learn.springboot.data.jpa.entity.User; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.util.Date; /** * @author 熊乾坤 * @since 2019-11-24 13:41 */ @Data @NoArgsConstructor @AllArgsConstructor public class FindUser &#123; private String name; private Long sumScore; private Date enrollmentDate; private String addressConcat; &#125; 需要注意的是，该类的成员变量和SQL语句中返回的字段的名称，类型，顺序必须一致，并且创建一个对应的构造器去接收参数。 然后使用这个对象构建一个CriterialQuery对象，使用此对象构建最终的查询语句： CriteriaBuilder builder = entityManager.getCriteriaBuilder(); CriteriaQuery&lt;FindUser&gt; query = builder.createQuery(FindUser.class); 其次，因为用到了User和UserDetail两个表的字段，所需要构建一个User的Root对象，然后去关联UserDetail对象，从而获取对应的字段： Root&lt;User&gt; userRoot = query.from(User.class); 因为用到了表连接，所以需要使用CriteriaQuery来将User表和UserDetail表进行连接： Join&lt;User, UserDetail&gt; userDetailJoin = userRoot.join(&quot;userDetail&quot;, JoinType.INNER); 完成上面的工作，最重要的就是函数和结果的封装，对于查询的结果，可以使用CriterialQuery中的multiSelect方法来进行接收： query .multiselect(userRoot.get(&quot;name&quot;), sumExpression , userDetailJoin.get(&quot;enrollmentDate&quot;),groupConcatExpression) 因为CriterialQuery中的泛型参数是FindUser，select方法中字段值就会会被自动使用构造函数填充进FindUser对象中去。 最后是函数的问题，SUM函数属于标准函数，不要进行特殊处理就可以直接在builder中使用，但是GROUP_CONCAT函数不是非标准函数，必须使用方言去注册后使用，方法如下： import org.hibernate.dialect.MySQL8Dialect; import org.hibernate.dialect.function.SQLFunctionTemplate; import org.hibernate.type.StandardBasicTypes; /** * 配置数据库方言，目前使用的场景为新增函数，例如group_concat函数在JPA中需要使用方言去注册进去 * 需要自定义类继承自MySQLXDialect类，X类为当前数据库使用的版本。 * 然后在yml文件中spring.jpa.property.hibernate.dialect指定此处定义的类。 * * @author 熊乾坤 * @since 2019-11-24 16:42 */ @SuppressWarnings(&quot;unused&quot;) public class MyDialect extends MySQL8Dialect&#123; public MyDialect() &#123; super(); registerFunction(&quot;group_concat&quot;, new SQLFunctionTemplate(StandardBasicTypes.STRING, &quot;group_concat(?1)&quot;)); &#125; &#125; 值得注意的是，不同的版本有不同的Dialect，但是根据版本的提升都是继承关系，在自定义方言中，使用的不同版本的MySQL需要继承自不同的Dialect。 然后在yml配置文件中，指定我们自己设定的Dialect类： spring: jpa: show-sql: true #打印jpa的sql语句 properties: hibernate: dialect: com.xqk.learn.springboot.data.jpa.config.MyDialect 这样在注册完以后，就可以直接使用GROUP_CONCAT函数啦啦啦。 总结在下周迭代的精准打击模块中，涉及到7个查询参数的动态SQL语句的构建，同时涉及到MySQL中的标准和非标准的函数的使用，比较棘手，作为ORM框架的新手来说，上手难度还是比较大的，花了两天时间去学习了一下。但是你知道的，自制力比较差，每次学个几分钟就去干别的事情了，静下心来学习的时间可能不到几小时，这个问题一直存在，自己也很早就意识到了，但是一直没有去改变，在接下来的几周内准备改掉这个坏毛病，过程可能会很痛苦，但是带来的益处无疑会非常多。","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Spring Data Jpa","slug":"Spring-Data-Jpa","permalink":"https://super-aviator.github.io/tags/Spring-Data-Jpa/"}],"author":"熊乾坤"},{"title":"第一个一年计划-JDK源码中大数比较的编码技巧[转载]","slug":"第一个一年计划-JDK源码中大数比较的编码技巧","date":"2019-11-07T01:05:00.000Z","updated":"2021-02-23T13:00:12.000Z","comments":true,"path":"2019/11/07/第一个一年计划-JDK源码中大数比较的编码技巧/","link":"","permalink":"https://super-aviator.github.io/2019/11/07/%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%80%E5%B9%B4%E8%AE%A1%E5%88%92-JDK%E6%BA%90%E7%A0%81%E4%B8%AD%E5%A4%A7%E6%95%B0%E6%AF%94%E8%BE%83%E7%9A%84%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/","excerpt":"","text":"BAT面试必问：a减b小于0与a小于b什么区别？溢出感知代码？","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"编码技巧","slug":"编码技巧","permalink":"https://super-aviator.github.io/tags/%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/"}],"author":"熊乾坤"},{"title":"第一个一年计划-Arrays工具类","slug":"第一个一年计划-Arrays工具类","date":"2019-11-04T12:56:00.000Z","updated":"2021-02-23T13:00:02.000Z","comments":true,"path":"2019/11/04/第一个一年计划-Arrays工具类/","link":"","permalink":"https://super-aviator.github.io/2019/11/04/%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%80%E5%B9%B4%E8%AE%A1%E5%88%92-Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"Arrays类是一个非常重要的工具类，也是集合框架和数组之间的桥梁，学习一下Arrays类的常用的方法： copyOf方法copOf方法的主要作用就是进行数组的拷贝，是一个非常常用的方法，有许多重载的版本，对于所有的基本类型，都有一个对应的copyOf方法的重载版本，我们主要来看一下泛型的版本，源代码如下： public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings(&quot;unchecked&quot;) T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; &#125; 拷贝的时候做了判断，如果需要拷贝的对象是Object数组，那么直接使用new的方式来创建新的指定长度的数组，因为既然是Object数组，没有泛型的话是可以直接创建素组的，但是如果不是Object数组的话，就不能使用new的方式来创建了，因为我们知道，泛型数组的创建是需要使用特殊的方式来创建的。创建泛型数组一种常用的方式就是用上面源码中的反射的方式来创建数组，即Array.newInstance方法。注意，参数中的[Class.getComponent方法是获取数组Class对象的单个元素的Class对象，比较拗口。在创建完数组之后，就可以使用System.arrayCopy方法来将原数组中的数据拷贝到新数组中去了。","categories":[{"name":"SourceCode","slug":"SourceCode","permalink":"https://super-aviator.github.io/categories/SourceCode/"}],"tags":[],"author":"熊乾坤"},{"title":"第一个一年计划-Springboot表单校验","slug":"第一个一年计划-Springboot表单校验","date":"2019-11-02T07:08:00.000Z","updated":"2021-02-23T13:00:00.000Z","comments":true,"path":"2019/11/02/第一个一年计划-Springboot表单校验/","link":"","permalink":"https://super-aviator.github.io/2019/11/02/%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%80%E5%B9%B4%E8%AE%A1%E5%88%92-Springboot%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C/","excerpt":"","text":"在几个月的工作中，发现表单校验是非常重要并且是必不可少的，但是对于Spring提供的几个表单校验的使用方法总是没有好好系统的学习一下，今天来看一看Spring中的几个表单校验的直接的详细使用方法： 常用注解@Null此注解表示VO类中的字段必须为null,和@NotNull字段是相反的。 @NotNull这个注解是最常用的，在VO类中使用的话，标识这个字段前端必须传递，如果该字段没有传值，则Spring会将VO类的字段值默认为null，此时表单校验就会不通过。注意：使用此注解，前端传递的空字符串是可以通过校验的。 @NotBlank此注解表示后台接收的字符串类型的数据不能为null并且不能为空字符串。 @NotEmpty次注解标识接收的集合必须不为null，并且集合的长度不能为0，即集合的isEmpty必须为false。 @Size次注解指定CharSequence、Map、Collection、Array类型的元素个数咋指定范围内，但是可以为null。 @PositiveOrZero此注解指定BigDecimal，BigInteger，byte，short，int，long，float，double以及其包类型,必须为正数或者0。但是可以为null。 @NegativeOrZero此注解指定BigDecimal，BigInteger，byte，short，int，long，float，double以及其包类型,必须为负数或者0。但是可以为null。 Negative此注解指定字段必须为负数 Positive此注解指定字段必须为正数 @Digit分组校验在开发过程中，常常会遇到这么一种使用场景：两个接口复用的一个VO类，但是不同的是，其中一个接口只需要校验VO类的部分字段，而另外一个接口则需要教养另外部分字段，对于这种动态校验字段的情况，可以使用分组校验的方式来解决，避免编写重复的代码：首先，在VO类中使用注解对表单字段进行校验,并为注解指定一个分组，代码如下： @Data private static class GroupValidVO &#123; @NotBlank(groups = TEST1.class,message = &quot;name不能为空&quot;) private String name; @Max(value =100,groups = TEST2.class,message = &quot;年龄大于100岁&quot;) private Long age; @Size(min = 1,groups = TEST2.class,message = &quot;朋友id不能为空&quot;) private List&lt;Long&gt; friendIds; //不指定分组 @NotNull(message=&quot;性别不能为空&quot;) private Integer gender; private interface TEST1&#123;&#125; private interface TEST2&#123;&#125; &#125; 注意VO类的最下面定义的接口，一个接口对应一个分组。 在Controller层，使用Spring提供的@Validated注解来对表单对象进行校验，并指定分组： @RestController @RequestMapping(&quot;/formValid&quot;) public class FormValidController &#123; @GetMapping(&quot;/test2&quot;) public ResponseMessage validTest2(@Validated(GroupValidVO.TEST1.class) FormValidController.GroupValidVO groupValidVO, BindingResult bindingResult)&#123; if(bindingResult.hasErrors())&#123; return ResponseMessage.error(bindingResult.getFieldError().getDefaultMessage()); &#125; return ResponseMessage.ok(&quot;表单校验通过&quot;); &#125; @GetMapping(&quot;/test3&quot;) public ResponseMessage validTest3(@Validated(&#123;GroupValidVO.TEST2.class&#125;) FormValidController.GroupValidVO groupValidVO, BindingResult bindingResult)&#123; if(bindingResult.hasErrors())&#123; return ResponseMessage.error(bindingResult.getFieldError().getDefaultMessage()); &#125; return ResponseMessage.ok(&quot;表单校验通过&quot;); &#125; &#125; 上面的代码中，第一个接口只会校验GroupValidVO类的name字段，而第二个接口只会校验GroupValidVO类的age和friendIds字段。测试结果如下： 可以看出test2接口只对name字段进行了校验。 可以看出test3接口只对age字段进行了校验。 注意 对于未加分组的字段gender，在@Validated注解指定分组时，不会进行校验。故上面的test2和test3接口都不会对gender进行校验。","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://super-aviator.github.io/tags/Spring/"}],"author":"熊乾坤"},{"title":"第一个一年计划-ArrayList集合","slug":"从菜鸟到菜逼-ArrayList源码学习","date":"2019-10-23T11:55:00.000Z","updated":"2021-02-23T13:00:10.000Z","comments":true,"path":"2019/10/23/从菜鸟到菜逼-ArrayList源码学习/","link":"","permalink":"https://super-aviator.github.io/2019/10/23/%E4%BB%8E%E8%8F%9C%E9%B8%9F%E5%88%B0%E8%8F%9C%E9%80%BC-ArrayList%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"参考地址： 搞懂 Java ArrayList 源码 继承关系public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 从上面的集成关系可以得知，ArrayList支持浅拷贝，同时支持序列化，RandomAccess接口是一个标记接口，指明ArrayList的随机访问的时间复杂度为O(1)。 初始化ArrayList的构造函数中如果不传入初始值，并不是直接初始化为长度为10的Object数组，而是指向内部的静态成员变量private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;。当有元素初次插入时，才会初始化为默认的长度10。 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;表明List最长的长度。 拷贝构造器中，有一个对toArray()方法的bug的兼容： public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 对这个bug的解释可以看下面这段代码： @Test public void testToArray()&#123; List&lt;String&gt; strings1=new ArrayList&lt;&gt;(); strings1.add(&quot;Hello&quot;); strings1.add(&quot;World&quot;); Object[] objects1=strings1.toArray(); System.out.println(objects1.getClass()); //输出class [Ljava.lang.Object; List&lt;String&gt; strings2= Arrays.asList(&quot;Hello&quot;,&quot;World&quot;); System.out.println(strings2.getClass()); //输出class java.util.Arrays$ArrayList Object[] objects2=strings2.toArray(); //objects2[0]=new Object(); 代码会有ArrayStorageException异常 System.out.println(objects2.getClass()); //输出class [Ljava.lang.String; //使用Arrays.copyOf的第三个参数，将String数组转换为Object数组 objects2=Arrays.copyOf(objects2,2,Object[].class); objects2[0]=new Object(); System.out.println(objects2.getClass()); //输出class [Ljava.lang.Object; &#125; 对于toArray方法返回不是Object[]数组时，需要使用Arrays.copyOf方法，使用第三个参数将数组转换为Object数组。 在Arrays类内部的ArrayList源码中，可以看到如下代码： @Override public Object[] toArray() &#123; return a.clone(); &#125; 因为clone方法不会改变元素的类型，如果保存的是String类型，返回的仍然是String类型的数组，而数组是协变类型，可以转换为String的父类Object数组，导致返回了错误的类型编译也可以通过。 成员方法indexOf public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 从indexOf方法可以看出，ArrayList是支持存储null值的,并且可以存储多个null值，当方法中需要匹配的值是null时，使用elementData[i]==null的方式进行判断，否则使用quuals方法进行判断，原因是如果直接在null上调用equals方法会有空指针异常。 toArray对于方法toArray，重点看一下带泛型的版本： public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a&#39;s runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; 从代码中得知，如果参数的长度小于ArrayList中的元素的长度，则使用Arrays.copyOf方法新建一个和elementData相同的数组返回，否则，使用参数中的数组保存elementData中的元素，并且将最后一个数组的值设置为null,例如：elementData为[1,2,3]，而参数中的数组a为[a,b,c,d,e],则执行ArrayList.toArray(a)以后，a中的结果为：[1,2,3,null,e]。示例程序如下： @Test public void testToArray2()&#123; ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;(); list.add(&quot;1&quot;); list.add(&quot;2&quot;); list.add(&quot;3&quot;); String[] arr=&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;&#125;; System.out.println(Arrays.toString(list.toArray(arr))); &#125; 输出结果为：[1, 2, 3, null, e]注意：此方法的泛型参数和定义ArrayList时指定的泛型参数是不同的，如果使用toArray方法传入的参数和定义ArrayList时指定的泛型参数不同，则会抛出java.lang.ArrayStoreException异常。 rangeCheck方法rangeCheck方法是一个内部私有的方法，在对下标进行操作时，都会调用这个方法进行下标检查，但是查看代码的过程中有产生了一个疑问： private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; 马虎的我一直搞不懂既然对检查了是否大于size，但是为什么不检查是否小于0呢，后来通过网上查询得知，判断index是否大于size的原因是，elementData数组的length和size一个是数组的长度，一个是当前元素的个数，而size可能是小于length的,所以需要对index进行判断，此时index的上限是size-1，而非length-1,而index小于0时，数字自动会抛出IndexOutofBoundsException异常,所以不需要进行判断。 增长策略ArrayList在每次增加元素时，都会显式的调用ensureCapacityernal方法来判断当前数组的大小是否能够容纳对应的元素，所以需要了解一下ArrayList的扩容机制。 private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; 在EnsureCapacity方法的开始，判断elementData是否是静态成员变量DEFAULTCAPACITY_EMPTY_ELEMENTDATA（只有使用new ArrayList()构造方法时，才会将内部的elementData赋值为此成员变量），如果是的话，将minCapacty赋值为默认的大小10,然后调用ensureExplicitCapacity方法进行更加精确的扩容操作。 private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; ensureExplicitCapacity方法内部，只有当想要增长的元素长度大于elementData数组的长度时，才会进行增长操作，真正增长的策略则在grow方法中。 总结 最大容量","categories":[{"name":"SourceCode","slug":"SourceCode","permalink":"https://super-aviator.github.io/categories/SourceCode/"}],"tags":[],"author":"熊乾坤"},{"title":"第一个一年计划","slug":"第一个一年计划","date":"2019-10-21T12:54:44.000Z","updated":"2021-04-03T12:22:00.068Z","comments":true,"path":"2019/10/21/第一个一年计划/","link":"","permalink":"https://super-aviator.github.io/2019/10/21/%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%80%E5%B9%B4%E8%AE%A1%E5%88%92/","excerpt":"","text":"希望一年后的自己，也能说出下面那句话： 如果再来一遍，我也许做不到这样 ![upload successful](images/cat1.png)","categories":[],"tags":[],"author":"熊乾坤"},{"title":"自定义消息转换器、自定义校验器","slug":"Spring表单校验注解、自定义消息转换器、自定义校验器","date":"2019-10-17T06:53:00.000Z","updated":"2021-02-23T13:00:02.000Z","comments":true,"path":"2019/10/17/Spring表单校验注解、自定义消息转换器、自定义校验器/","link":"","permalink":"https://super-aviator.github.io/2019/10/17/Spring%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E5%99%A8/","excerpt":"","text":"","categories":[{"name":"Spring","slug":"Spring","permalink":"https://super-aviator.github.io/categories/Spring/"}],"tags":[],"author":"熊乾坤"},{"title":"EvaElf-相遇","slug":"温柔","date":"2019-10-10T08:52:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2019/10/10/温柔/","link":"","permalink":"https://super-aviator.github.io/2019/10/10/%E6%B8%A9%E6%9F%94/","excerpt":"","text":"那爱情的绮丽，总是在孤单里，再把我的最好的爱给你 —《温柔》 你画的插图虽然是偏儿童风格，但是我真的喜欢,和我以前喜欢看的《儿童文学》杂志的插画风格很像,同时也非常感谢昨天你给我推荐的房子。 你说你希望房间的桌子能够尽量大一些，这样才能放下一台电脑，一个手绘板。 看了你的朋友圈,那些你出国旅行的照片,你自己做的关于旅拍的公众号；让我想起了高中，一次月考结束，好朋友班上第一名，我倒数第三名。 生活很残酷，现实很残酷。 6点了，下班了吗？ 吃完饭我要回去继续加班啦，嗯，再见啦，祝你早日找到满意的房子。","categories":[{"name":"Daily","slug":"Daily","permalink":"https://super-aviator.github.io/categories/Daily/"}],"tags":[],"author":"熊乾坤"},{"title":"SpringBoot中大文件上传时的连接超时问题","slug":"SpringBoot中大文件上传时的连接超时问题","date":"2019-09-18T07:51:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2019/09/18/SpringBoot中大文件上传时的连接超时问题/","link":"","permalink":"https://super-aviator.github.io/2019/09/18/SpringBoot%E4%B8%AD%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%97%B6%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/","excerpt":"","text":"这次迭代的开发任务中，又踩了一个坑，虽然说是一个坑，但是总的原因还是因为自己技术太垃圾以及编码时的粗心大意所造成的，本来可以写到采坑的专题中，但是阴差阳错还是拿出来单独记录吧。 问题的场景很简单，就是使用springboot内置的tomcat时，如果上传大文件，有时会上传失败，浏览器控制台会有如下错误：链接的Status有时会是failed或者是canceled。而且在上传比较大的文件的时候会特别容易触发。 后台抛出的异常是SocketTimeoutException，所以猜测是链接超时的问题。 最开始我还怀疑是前端的问题，跑去和前端一顿讨论（日常坑前端一把T_T），讨论无果之后又一顿百度，加了各种配置，还是没有用。。。 最后偶然在网上看到了两个配置 server: connection-timeout: 30000 #设置链接超时时间为30秒 spring: mvc: async: request-timeout：60000 #设置restful的api超时时间为60秒 第一个配置是控制tomcat的链接的超时时间，第一次尝试设置这个值的时候，老眼一花，看成了单位是秒，所以给了一个60，问题不但没解决，反而越来越容易触发。。。后来又尝试第二个配置，还是没用。 经过后来自己的琢磨，更换了第一个配置的单位，上传文件时就不会超时了，文件也能够正常的上传。所以当网络比较差或者文件比较大时，可以讲第一个配置适当调大一点，然后如果接口的响应时比较长而导致接口超时时，可以适当将第二个配置的值调大。 解决这个bug的过程饶了很多的弯路，因为错误移位单位是秒，导致设置的值太小，从而错过了解决问题的方法，好在后来及时发现了错误。 在编写代码之前，需要思考思考再思考，在编写代码时，需要仔细仔细再仔细。在检查代码时，需要重复重复再重复。","categories":[],"tags":[],"author":"熊乾坤"},{"title":"SpringBoot中定义定时执行的任务的两种方式","slug":"Springboot中定义定时执行的任务的两种方式","date":"2019-09-15T06:25:00.000Z","updated":"2021-02-23T13:00:12.000Z","comments":true,"path":"2019/09/15/Springboot中定义定时执行的任务的两种方式/","link":"","permalink":"https://super-aviator.github.io/2019/09/15/Springboot%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"项目里面经常要执行定时任务，当然了，作为CRUD程序员的我还没遇见过T_T，前几天在知乎看到了这片文章，照着（fu）学(zhi)习一下。 通过Spring注解的方式实现定时任务最简单的方式是通过注解@Scheduled来实现定时任务，首先需要在配置类上使用注解@EnableScheduling开启定时任务。 @EnableScheduling @Configuration public class ScheduleTaskConfig &#123; &#125; 然后需要在方法上添加@Scheduled注解： @Component @Slf4j public class ScheduleTask &#123; @Scheduled(fixedDelay = 5000) public void execute()&#123; log.info(&quot;schedule task with fixedDelay----&gt;&#123;&#125; milliseconds&quot;,5000); &#125; &#125; @Scheduled注解中，有一个fixedDelay属性，表示执行的间隔为多少毫秒，上面的方法每5秒执行一次：@Scheduled注解还有许多元素，可以指定任务的不同的执行方式： fixedDelay指定两个任务执行之间的时间间隔，单位为毫秒。与fixedRate不同的时，fixedDelay是前一次任务执行完毕至后一次任务执行开始之前的间隔。 fixedRate指定两个任务执行之间的时间间隔，单位为毫秒。与fixedDelay不同的是，fixedRate是前一次任务执行开始至后一次任务执行开始之间的间隔。 initialDelay该属性指定该定时任务在应用启动之后多少毫秒以后执行，例如将其设置为10000，则该定时任务将在应用启动10秒之后开始执行。fixedDelay和fixedRate都可以配合该属性进行使用。 注意：当同时指定fixedDelay和fixedRate两个属性时，会启动失败。 @Scheduled注解配合cron表达式@Scheduled注解有个非常强大的属性，他支持cron表达式，可以指定任何时间对定时任务进行周期性的控制，首先来学习一下cron表达式的使用，也可以使用在线cron生成表达式生成cron表达式： cron表达式的格式：{秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)} 每个字段的允许值字段 允许值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 小时 0-23 , - * / 日期 1-31 , - * ? / L W C 月份 1-12 或者 JAN-DEC , - * / 星期 1-7 或者 SUN-SAT , - * ? / L C # 年（可选） 留空, 1970-2099 , - * / 允许值的意思：Seconds (秒) ：可以用数字0－59 表示， Minutes(分) ：可以用数字0－59 表示， Hours(时) ：可以用数字0-23表示, Day-of-Month(天) ：可以用数字1-31 中的任一一个值，但要注意一些特别的月份 Month(月) ：可以用0-11 或用字符串 “JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV and DEC” 表示 Day-of-Week(每周)：可以用数字1-7表示（1 ＝ 星期日）或用字符口串“SUN, MON, TUE, WED, THU, FRI and SAT”表示 每个符号的意义：* ：表示所有值； ? ： 表示未说明的值，即不关心它为何值； - ： 表示一个指定的范围； , ： 表示附加一个可能值； / ：符号前表示开始时间，符号后表示每次递增的值； L ：(“last”) (“last”) “L” 用在day-of-month字段意思是 “这个月最后一天”；用在 day-of-week字段, 它简单意思是 “7” or “SAT”。 如果在day-of-week字段里和数字联合使用，它的意思就是 “这个月的最后一个星期几” – 例如： “6L” means “这个月的最后一个星期五”. 当我们用“L”时，不指明一个列表值或者范围是很重要的，不然的话，我们会得到一些意想不到的结果。 W ：(“weekday”) 只能用在day-of-month字段。用来描叙最接近指定天的工作日（周一到周五）。例如：在day-of-month字段用“15W”指“最接近这个 月第15天的工作日”，即如果这个月第15天是周六，那么触发器将会在这个月第14天即周五触发；如果这个月第15天是周日，那么触发器将会在这个月第 16天即周一触发；如果这个月第15天是周二，那么就在触发器这天触发。注意一点：这个用法只会在当前月计算值，不会越过当前月。“W”字符仅能在 day-of-month指明一天，不能是一个范围或列表。也可以用“LW”来指定这个月的最后一个工作日。 # : 只能用在day-of-week字段。用来指定这个月的第几个周几。例：在day-of-week字段用”6#3”指这个月第3个周五（6指周五，3指第3个）。如果指定的日期不存在，触发器就不会触发。 C 指和calendar联系后计算过的值。例：在day-of-month 字段用“5C”指在这个月第5天或之后包括calendar的第一天；在day-of-week字段用“1C”指在这周日或之后包括calendar的第一天。 一些cron表达式案例*/5 * * * * ? 每隔5秒执行一次0 */1 * * * ? 每隔1分钟执行一次0 0 5-15 * * ? 每天5-15点整点触发0 0/3 * * * ? 每三分钟触发一次0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 0 0 12 ? * WED 表示每个星期三中午12点0 0 17 ? * TUES,THUR,SAT 每周二、四、六下午五点0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 0 15 10 ? * MON-FRI 周一至周五的上午10:15触发0 0 23 L * ? 每月最后一天23点执行一次0 15 10 L * ? 每月最后一日的上午10:15触发 0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 0 15 10 * * ? 2005 2005年的每天上午10:15触发 0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发 “30 * * * * ?” 每半分钟触发任务“30 10 * * * ?” 每小时的10分30秒触发任务“30 10 1 * * ?” 每天1点10分30秒触发任务“30 10 1 20 * ?” 每月20号1点10分30秒触发任务“30 10 1 20 10 ? *” 每年10月20号1点10分30秒触发任务“30 10 1 20 10 ? 2011” 2011年10月20号1点10分30秒触发任务“30 10 1 ? 10 * 2011” 2011年10月每天1点10分30秒触发任务“30 10 1 ? 10 SUN 2011” 2011年10月每周日1点10分30秒触发任务“15,30,45 * * * * ?” 每15秒，30秒，45秒时触发任务“15-45 * * * * ?” 15到45秒内，每秒都触发任务“15/5 * * * * ?” 每分钟的每15秒开始触发，每隔5秒触发一次“15-30/5 * * * * ?” 每分钟的15秒到30秒之间开始触发，每隔5秒触发一次“0 0/3 * * * ?” 每小时的第0分0秒开始，每三分钟触发一次“0 15 10 ? * MON-FRI” 星期一到星期五的10点15分0秒触发任务“0 15 10 L * ?” 每个月最后一天的10点15分0秒触发任务“0 15 10 LW * ?” 每个月最后一个工作日的10点15分0秒触发任务“0 15 10 ? * 5L” 每个月最后一个星期四的10点15分0秒触发任务“0 15 10 ? * 5#3” 每个月第三周的星期四的10点15分0秒触发任务 参考地址： 在Spring Boot中优雅的实现定时任务 cron表达式详解，cron表达式写法，cron表达式例子","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://super-aviator.github.io/tags/Spring/"}],"author":"熊乾坤"},{"title":"那些你在工作中的踩过的坑（持续更新）","slug":"那些你在工作中的踩过的坑（持续更新）","date":"2019-09-11T02:42:00.000Z","updated":"2021-02-23T13:00:10.000Z","comments":true,"path":"2019/09/11/那些你在工作中的踩过的坑（持续更新）/","link":"","permalink":"https://super-aviator.github.io/2019/09/11/%E9%82%A3%E4%BA%9B%E4%BD%A0%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/","excerpt":"","text":"上周项目上线之后，遭受了无数次空指针异常的狂扁之后，这周新增的需求中又被类型转换错误狠狠的教训了一顿。（这可能就是上天对菜逼的惩罚），感觉组长已经对我的代码中这种异常产生了强大的免疫力了。。。 刚刚改完bug之后，决定开个坑，记录一下工作中踩过的坑，有点绕口惹。。。主要的目的是要保证犯过的错误不能再犯第二次。 NullPointerException基本类型的包装类的类型转换org.springframework.web.HttpMediaTypeNotAcceptableException: Could not find acceptable representation异常在新的需求的代码中，需要前端批量上传图片和视频，本来完美的解决方案是将图片和视频保存在本地，然后通过公司的海豚品台的nginx去代理图片的访问，但是我们的项目里面他喵的海豚没有挂在nginx，所以所有的图片和视频只能通过项目中的接口去访问，后台直接返回二进制流。海豚真是含棒棒惹。 在访问图片和视频的接口中，我脑子进水一般的，在同一个接口中同时返回了JSON和二进制流的数据格式，分别对应的MediaType是application/json、application/octet-stream。Controller层返回了Json对象： @GetMapping(value = &quot;/&#123;fileName:\\\\S+\\\\.\\\\S+&#125;&quot;) public ResponseMessage updateTextMaterial(@PathVariable(&quot;fileName&quot;) String file, HttpServletResponse response)&#123; return materialService.getMaterialFileStream(file, response); &#125; Service层向HttpServletResponse层直接写入了二进制流： try (InputStream in = new FileInputStream(materialFile)) &#123; //文件拷贝时，使用16kb的缓冲区大小 IOUtils.copy(in, response.getOutputStream(), 16 * 1024); &#125; catch (IOException e) &#123; log.error(&quot;文件写入时异常&quot;, e); return ResponseMessage.error(&quot;文件写入时异常&quot;); &#125; 但是当时我并不知道不能这样写，刚开始还以为是前端没有加上Accept头部的原因，跑去和前端沟通，结果前端当然是加不了头部的，因为他们是直接将连接放在&lt; image&gt;标签中的；所以现在前端每访问一次接口，都会抛出这个异常。 解决方法是只返回二进制流的数据，不用返回json格式的数据: @GetMapping(value = &quot;/&#123;fileName:\\\\S+\\\\.\\\\S+&#125;&quot;) public void updateTextMaterial(@PathVariable(&quot;fileName&quot;) String fileName, HttpServletResponse response) &#123; materialService.getMaterialFileStream(fileName, response); &#125; 使用@ComponentScan排除指定的包上次启动项目时，会有kstp和kidp包里面的RedisService冲突了，所以需要配置取消某个包的扫描，可以通过注解@ComponentScan来实现： @EnableWebSecurity @SpringBootApplication @ComponentScan(basePackages = &#123;&quot;com.xqk.learn.springboot.*&quot;&#125;,excludeFilters = @ComponentScan.Filter(type = FilterType.ASPECTJ,pattern = &#123;&quot;com.xqk.learn.springboot.base.schedule.tasks.*&quot;&#125;)) public class LearnApplication &#123; /** * The entry point of application. * * @param args the input arguments */ public static void main(String[] args) &#123; //最常规的启动方式，使用静态方法的方式 SpringApplication.run(LearnApplication.class, args); &#125; 需要指定FilterType的类型为ASPECTJ，pattern指定包的名称，想要排除某个包下面的所有包，后面使用*通配符即可。 也可以通过类型去排除： @EnableWebSecurity @SpringBootApplication @ComponentScan(basePackages = &#123;&quot;com.xqk.learn.springboot.*&quot;&#125;, excludeFilters = @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE,classes = &#123;ScheduleTask.class&#125;)) public class LearnApplication &#123; public static void main(String[] args) &#123; //最常规的启动方式，使用静态方法的方式 SpringApplication.run(LearnApplication.class, args); &#125; maven下载包超时有时候在pom文件里面,新增了依赖,却发现项目中并没有下载相对应的包,而pom文件中也会报错,表示无法解析对应的依赖.首先可以去.m2文件夹中,找到对应的依赖的文件夹,里买有一个文件,后缀是lastUpdate,用记事本打开该文件,如果里面的原因是read timeout ,则说明是链接超时,可以配置国内的镜像来解决:找到maven安装目录下的conf文件夹,在settings.xml文件中,新增镜像: &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; 然后在.m2中间价中删除对应依赖的文件夹,在idea中使用重新导入按钮,重新下载依赖就ok了. 项目启动时链接数据库时，出现的Public Key Retrieval is not allowed错误搜索了一下StackOverflow中的相关答案，在MySQL中，url的所有属性：MySQL ConnectionString Options在上面的文档中，可以看到，AllowPublicKeyRetrieval, 字段的描述使用谷歌翻译结果如下： 如果用户帐户使用sha256_password身份验证，则在传输过程中必须保护 密码。 TLS是实现此目的的首选机制，但是如果它不可用，则将使用RSA公钥加密。 要指定服务器的RSA公钥，请使用ServerRSAPublicKeyFile连接字符串设置，或设置AllowPublicKeyRetrieval = True以允许客户端自动从服务器请求公钥。 请注意，AllowPublicKeyRetrieval = True可能允许恶意代理执行MITM攻击以获取纯文本密码，因此默认情况下为False，必须明确启用它。 暂时还没搞懂什么原因，写上去再说吧。 springboot启动出现Access to DialectResolutionInfo cannot be null when ‘hibernate.dialect’ not set出现这个异常，首先应该检查MySQL数据库中的表是否已经创建，例如，连接到jpa这个数据库，但是jpa数据库中，项目启动所需要的表并没有创建，则会抛出这个异常。 项目引入common-server包之后，报elasticsearch包不兼容一般不需要引入elasticserach包，但是如果有些情况需要引入的话，需要注意以下问题： flyway数据库脚本不兼容因为flyway的sql脚本存放地址和common-server包的sql地址一样，需要修改本项目里面flyway脚本的地址： 最下面的地址是sql脚本存放的地址。和common-server中脚本存放的地址不同即可。 2.elasticsearch的jar包不兼容对于jar不兼容的问题，需要引入如下的依赖，折腾了两天，最后在后端大佬的帮助下才解决。 &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-elasticsearch&lt;/artifactId&gt; &lt;version&gt;2.2.3.0-RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;5.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.plugin&lt;/groupId&gt; &lt;artifactId&gt;transport-netty4-client&lt;/artifactId&gt; &lt;version&gt;5.6.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;transport&lt;/artifactId&gt; &lt;version&gt;5.6.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.elasticsearch.plugin&lt;/groupId&gt; &lt;artifactId&gt;transport-netty4-client&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;","categories":[{"name":"Daily","slug":"Daily","permalink":"https://super-aviator.github.io/categories/Daily/"}],"tags":[],"author":"熊乾坤"},{"title":"浅入浅出Logback（T_T）","slug":"浅入浅出Logback（T-T）","date":"2019-09-10T14:59:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2019/09/10/浅入浅出Logback（T-T）/","link":"","permalink":"https://super-aviator.github.io/2019/09/10/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BALogback%EF%BC%88T-T%EF%BC%89/","excerpt":"","text":"这周主要学习了Logback的一下基础知识，看的是Logback的官方手册，讲的非常详细，粗略的看一看，记录一下比较重要的知识点吧。下周准备看一下SpringFramgewor5的官方文档，先开个坑再说。 Logback基础知识几种常用的AppenderSpring中的Logback","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Logback","slug":"Logback","permalink":"https://super-aviator.github.io/tags/Logback/"}],"author":"熊乾坤"},{"title":"Spring中基于类或者接口的两种不同的代理方式","slug":"Spring中基于类和基于接口的Bean装配","date":"2019-09-10T14:00:00.000Z","updated":"2021-02-23T12:59:58.000Z","comments":true,"path":"2019/09/10/Spring中基于类和基于接口的Bean装配/","link":"","permalink":"https://super-aviator.github.io/2019/09/10/Spring%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%92%8C%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%9A%84Bean%E8%A3%85%E9%85%8D/","excerpt":"","text":"今天在公司的项目中出现了Bean装配的问题，折腾了一晚上，最后在后端大腿的帮助下在解决了问题。。。 问题的主要原因是园区开发人员封装的RedisService服务和上海研究所自己封装的RedisService服务名称重复了，其中上海这边的RedisService服务是使用类名上使用@Servive注解直接在类中定义的bean，而非接口的方式，项目启动时会报下面的错误： //TODO 网上一顿百度之后，说是Spring代理方式的原因，因为默认使用的是JDK的动态代理，不支持类的直接装配，而需要使用接口的方式进行装配，需要强制使用GCLIB的方式。反正我是一脸懵逼，为了下次遇到这种Bean冲突或者装配失败能够快速解决，学习一下Bean装备这方面的知识吧。 基于接口的Bean装配基于类的Bean装配解决Bean装配过程中的冲突","categories":[{"name":"Spring","slug":"Spring","permalink":"https://super-aviator.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://super-aviator.github.io/tags/Spring/"}],"author":"熊乾坤"},{"title":"在JPA中使用SQL语句构建动态查询语句","slug":"常见的SQL中判断NULL的函数","date":"2019-09-08T08:08:00.000Z","updated":"2021-02-23T13:00:12.000Z","comments":true,"path":"2019/09/08/常见的SQL中判断NULL的函数/","link":"","permalink":"https://super-aviator.github.io/2019/09/08/%E5%B8%B8%E8%A7%81%E7%9A%84SQL%E4%B8%AD%E5%88%A4%E6%96%ADNULL%E7%9A%84%E5%87%BD%E6%95%B0/","excerpt":"","text":"上次做项目的过程中，需要根据参数是否为NULL去动态构建语句，因为JPA是使用的是JpaSpecificationExecutor等去使用编程的方式去构建动态语句，当时没有去学习，当然了，现在任然没有学习T_T，等把logback学完之后，一定要好好看一下JPA里面的动态查询的实现，不然连基本的CRUD都完不成的话就太废了。当时想到的方法是使用SQL函数的方式去实现，那天晚上又是百度谷歌一顿搜，最后终于还是实现了，今天刚睡完午觉，状态很好，结合网上的博客和Mysql文档，记录一下。后面还得学习一下常见的SQL函数，感觉太有用了，能解决很多开发过程中的问题。 COALESCE(A,B,C…) 描述：Returns the first non-NULL value in the list, or NULL if there are no non-NULL values. 总的来说，COALESCE函数有多个参数，函数会返回从左至右第一个不为NULL的参数，并且会使用短路的方法去判断。使用方法如下： SELECT COALESCE(NULL,1); 1 --------- SELECT COALESCE(NULL,NULL,NULL); NULL --------- SELECT COALESCE(NULL,1,&#39;ABC&#39;); 1 根据函数的特性，如果在参数列表中，可以通过指定最后一个参数的值的方式，来指定当所有参数都为NULL时函数返回的默认值： SELECT COALESCE(NULL,NULL,&#39;ABC&#39;); &#39;ABC&#39; ISNULL(A)ISNULL函数顾名思义就是检查参数是否是NULL，与关键字IS NULL 用法相同，如果是NULL，则返回1，否则返回0，但是和COALESCE相比，ISNULL参数只支持一个，使用方法如下： SELECT ISNULL(NULL); 1 --------- SELECT ISNULL(&#39;a&#39;); 0 IFNULL(A,B)IFNULL是ISNULL函数的升级版本，ISNULL函数只能返回0、1，而IFNULL则可以自定义返回结果，如果第一个参数不为NULL,则返回第一个参数,如果第一个参数为NULL，则返回第二个参数： SELECT IFNULL(NULL,123); 123 --------- SELECT IFNULL(&#39;ABC&#39;,123); &#39;ABC&#39; JPA中使用SQL语句构建动态查询语句项目开发中，常常需要根据参数是否为NULL来动态构建查询语句，例如如下的查询语句：SELECT * FROM USER WHERE NAME=&#39;熊乾坤&#39;;，如果NAME为NULL，则不执行过滤条件，查询语句会变成：SELECT * FROM USER;，JPA中如果想要实现这种动态构造查询语句的方式，可以使用JPASpecificationExecutor这种通过编程的方式实现，我还没有学过。。。第二种方式是退而求其次，使用SQL语句来构建动态查询语句，会将上面的语句装换为SELECT * FROM USER WHERE ? IS NULL OR NAME = ?;,当参数为NULL时，因为短路的原则，OR表达式直接为TRUE，则不执行过滤，当不为NULL时，OR左边为false，则会判断OR右边的语句，进行对查询结果过滤，达到动态查询的效果。先来学习一下第二种方式。 数据库表结构如下； 一个参数首先实验一下当查询单数为一个时，如果去写：在Repository层新建查询语句： /** * 是否IS NULL OR 构建动态SQL语句 * @param name 姓名 * @return User列表 */ @Query(value= &quot;SELECT t FROM User AS t &quot; + &quot;WHERE ?1 IS NULL OR t.name=?1 &quot;) @EntityGraph(&quot;UserEntity&quot;) List&lt;User&gt; getUserWithDynamicSql(String name); 在Controller层调用该方法进行测试： @GetMapping(&quot;/DynamicSql&quot;) public List&lt;User&gt; getUserByDynamicSql(String name)&#123; return userRepository.getUserWithDynamicSql(name); &#125; 使用http请求工具测试结果如下； 当查询参数为name=’熊乾坤是个人’时，查询结果为1条数据； 当查询参数中不带name时，查询结果为14条数据，即全部数据； 控制台打印的sql语句如下： select user0_.id as id1_2_0_, userdetail1_.id as id1_3_1_, teacher3_.id as id1_0_2_, userfriend4_.id as id1_4_3_, user0_.address as address2_2_0_, user0_.email as email3_2_0_, user0_.gender as gender4_2_0_, user0_.name as name5_2_0_, user0_.score as score6_2_0_, user0_.version as version7_2_0_, userdetail1_.credit as credit2_3_1_, userdetail1_.enrollment_date as enrollme3_3_1_, userdetail1_.user_id as user_id4_3_1_, teacher3_.name as name2_0_2_, teachers2_.user_id as user_id3_1_0__, teachers2_.teacher_id as teacher_4_1_0__, userfriend4_.friend_id as friend_i2_4_3_, userfriend4_.user_id as user_id3_4_3_, userfriend4_.user_id as user_id3_4_1__, userfriend4_.id as id1_4_1__ from user user0_ left outer join user_detail userdetail1_ on user0_.id=userdetail1_.id left outer join teacher_user_relation teachers2_ on user0_.id=teachers2_.user_id left outer join jpa.teacher teacher3_ on teachers2_.teacher_id=teacher3_.id left outer join user_friend userfriend4_ on user0_.id=userfriend4_.user_id where ? is null or user0_.name=? order by userfriend4_.friend_id asc SQL语句中，WHERE查询条件中加入了IS NULL OR语句，当查询参数为NULL时，OR语句会直接为true，则不会判断后面的name是否相等的条件，而查询参数不为NULL时，才会判断后面的查询条件是否为NULL。不过这样不知道会不会带来性能的问题还有待研究，如果采用编程的方式来实现的话应该会好一点，SQL语句在编译时就已经确定，不会在每次查询时都执行NULL判断。 多个查询参数当查询参数一个key对应以逗号分隔的多个value时，value一般会以集合或者数据的形式进行保存。在JPQL中，会将List集合中的数据以逗号分隔的方式，添加到SQL语句中，例如WHERE COALESCE(?)语句中，当？为字符串类型的List：’A’,’B’,’C’时，会转换为WHERE COALESCE(&#39;A&#39;,&#39;B&#39;,&#39;C&#39;)的形式，而数组则不会进行转换，所以当有多个查询参数时，需要将参数包装在List中作为参数传递给JPQL语句，并在SQL语句的查询条件中使用IN关键字，如下所示：在Repository中编写JPQL语句： /** * 是否IS NULL OR 构建动态SQL语句 * @param name 姓名 * @return User列表 */ @Query(value= &quot;SELECT t FROM User AS t &quot; + &quot;WHERE COALESCE(?1,NULL) IS NULL OR t.name IN ?1 &quot;) @EntityGraph(&quot;UserEntity&quot;) List&lt;User&gt; getUserWithDynamicSql(List&lt;String&gt; name); 和单个参数形式一样，只不过使用COALESCE函数对参数是否为NULL进行判断。注意 如果使用的原生的SQL，需要在 IN 关键字后面加上括号：IN (?1)，血的教训。 Controller层进行调用： @GetMapping(&quot;/DynamicSqlWithArgsArr&quot;) public List&lt;User&gt; getUserByDynamicSqlWithArgsArr(String[] name)&#123; return userRepository.getUserWithDynamicSql(Objects.isNull(name)?null:Arrays.asList(name)); &#125; Spring中只能用数组去接受一个key对应的多个value的数据，所以需要显示的将数组装换为List的形式，特殊情况当name参数为NULL时，需要直接将NULL传入JPQL中。 完成了上面的工作，经过测试，将name=’xqk’,’熊乾坤’作为查询参数时，能够查询到相应的结果，当查询参数中没有name字段时，查询到了数据库中的所有的数据。 总结使用SQL语句去实现动态查询是一个不太美观、不太高效的解决方案，更加正确的做法是使用编程的方式去控制，根据参数的值去动态生成SQL语句，这样在查询时，能够避免做很多没必要的判断。","categories":[{"name":"Database","slug":"Database","permalink":"https://super-aviator.github.io/categories/Database/"}],"tags":[{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"https://super-aviator.github.io/tags/Spring-Data-JPA/"}],"author":"熊乾坤"},{"title":"桐庐之旅","slug":"桐庐之旅","date":"2019-09-08T02:28:00.000Z","updated":"2021-02-23T13:00:04.000Z","comments":true,"path":"2019/09/08/桐庐之旅/","link":"","permalink":"https://super-aviator.github.io/2019/09/08/%E6%A1%90%E5%BA%90%E4%B9%8B%E6%97%85/","excerpt":"","text":"第一次旅游，第一次去酒店，第一次坐竹筏，第一次打水仗…一生中充满了各种美妙的第一次，尽管我只是一个来自湖北农村的没见过世面的大傻逼。 感谢一起的小伙伴 夜色太暗了，快回家吧，别让她为你担心啊 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;别像我，错失了爱情，一个人，一夜夜伤心 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---------《夜》李志 天色要亮了，别回了，就让她随意寂寞吧 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像我，无所谓爱情，一个人，一夜也开心 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---------《日》李志 ![upload successful](/images/she.png) 回来的大巴上想的都是你 感谢科达","categories":[{"name":"Daily","slug":"Daily","permalink":"https://super-aviator.github.io/categories/Daily/"}],"tags":[],"author":"熊乾坤"},{"title":"一次令人崩溃的租房经历","slug":"一次宁人崩溃的租房经历","date":"2019-09-01T06:28:00.000Z","updated":"2021-02-23T13:00:00.000Z","comments":true,"path":"2019/09/01/一次宁人崩溃的租房经历/","link":"","permalink":"https://super-aviator.github.io/2019/09/01/%E4%B8%80%E6%AC%A1%E5%AE%81%E4%BA%BA%E5%B4%A9%E6%BA%83%E7%9A%84%E7%A7%9F%E6%88%BF%E7%BB%8F%E5%8E%86/","excerpt":"","text":"昨天是2019年8月31号，房子9月1号到期，所以昨天去佘山那边找了一天的房子，抱着用1300左右的价格，租一间带阳台和厨房的房子的幻想，提前预约了咸鱼上的几个中介就去佘山了，一天下来绕着新凯一期和新凯二期转了几圈，租房的中介见了差不多五六个，没有一个合适的，也没有一个实际看的房子和咸鱼上的图片一样的，最后还去了洞泾那边，结果房价更贵。。。 一方面是我的预算太低，符合要求的大多价位是1500左右的，另一方面新凯的房子户型很特殊，有阳台的都是厅卧，厅卧其实就是带阳台的大一点的隔间，由于现在住的就是隔间，深知隔间又很多不方便的地方，比如噪音啊，隐私啥的。当然了，预算太低才是关键，其他的都是次要的。 看的所有的房子里面，有一个非常特殊的房子，房源就在步行街的商店的上面，房东听说我要去看房，特意从七宝赶回来，房子是属于没有装修过的那种，整个房间都是黑乎乎的一片，有点恐怖。厨房也是零时搭建起来的。不过价格还是挺低的，1100包水电。由于环境实在是有点差，没有做过多考虑。 看的所有的房子里面，带厨房的稍微便宜点的房子有两个，一个是次卧1250，一个是主卧1300，我留了中介的号码之后晚上就回去了，想着明天把押金拿到手了明天就可以去签约了。 精疲力尽的回到家，给房东打电话叫他明天来看房子，结果重头戏来了，他以没有提前一个月通知他为由，拒绝退还押金，我听到这话当时就懵逼了，合同快到期不是房东提醒租户的吗，我咋还要提前给房东打招呼啊，然后就和他微信语音各种理论，不了了之，甚至最后微信电话都不接了。。。屋漏偏逢连夜雨，船迟又遇打头风，这时中介打电话过来，说下午看的房子都被租掉了。。。当时真的感觉快崩溃了，躺在床上眼泪止不住的流啊。 第二天早早起来，又去泗泾看了一套房子，是在zuber上看的，手机上看地图以为离地铁站不会很远，结果下地铁才发现步行过去要差不多半个小时。。。而且房间的厨房就在客厅里零时搭建的一个台子，放了个电磁炉，一桌子的油渍，加上油烟熏的很不溜秋的墙面，不忍直视，不过房间还是很不错的，有个阳台，房子空间也很大。最后一问价格，季付1300，月付1400，水费30，网费40，告辞了(liao)。 后来又去了新凯一期，叫上了昨天那个巴乐兔的中介小哥，去看了一个1300的房子，各方面都很完美，唯一不足的是房子是真滴小，和我现在住的隔间大小有的一拼。 没办法，只能跑回来了，押金的是还没解决，也不敢贸然的签约。回来收拾了一下东西就给房东打电话，问他什么时候能过来，表示想和他商量一下推押金的事，电话里它依旧咬定我没有提前和他说，我说首先你没有在合同到期之前提前通知我，我是第一次租房，不知道要提前说，其次你合同上也没有写明，结果他直接说你中途转租过房子，合同现在根本不起作用，一听他说合同没用，当时我火冒三丈，当初换房子后我催了他三四次叫他过来换合同，结果他每次都说有事，来不了，乱七八糟的各种理由，没办法，我后来直接不催了，催了也没用，以前厕所的门锁怀了叫他来修，嘴上答应的很好，门到现在还是坏的,说话就像放屁一样；我当时心里就想着钱可以不要，气必须出，所以语气也比较重，我直接和他说：你就说给还是不给吧。他直接挂了电话。 之后我姐还在打电话指导我，房东终于过来了，他可能猜到我如果走的话会搞破坏，进门就瞄了一下家具啥的。我只好又和他有理有据的理论，最后提出了一个解决方案：我再住一个月，这一个月的房租用押金去抵扣，这一个月内他再找新的租户，等我10月1日搬走，新租客再住进来。因为实在是没办法了，只能再住一个月了，明天就要上班了，房子还没有看好，等一个月之后找房子的时间也能够宽裕一点，最重要的是还能拿到押金。一千多块呢。相信一个月后我能租到合适的房子，找房子的过程中不会再像这次一样落魄。 经历了上面的一些事，我觉得有些东西应该记下来，虽然很心酸，很无赖，但是却有很多收货，记得当时找房子的时候，坐在新凯一期步行街的树下面，望着来来往往有说有笑的人群，眼泪在眼眶里打转，想起了郭德纲的那句话；天下之大，何处才是我的安身之所，其实我很害怕各种不确定，做任何事要提前准备好了才会去做，这次租房却充满了各种不确定因素；不过在经历了这些事情之后，对想要人前显贵，必先人后受罪有了更深刻的理解，虽然租房子不是关于技术方面的事情，但是确实是日常生活中必不可缺的事情，相信这些苦难的日子会成为以后的一笔财富，嗯，确信。 总结一下吧，就像平时写技术博客那样： 出了社会，真正关心你的只有家人，记得好好爱他们ଘ(੭ˊᵕˋ)੭ 做一个正直善良的人，不贪图蝇头小利，有些东西是你的永远都是你的，不是你的就别想着占有，当然，你管不了别人，你只需要做好你自己 要努力、奋斗，多挣钱才是王道，钱不能解决所有问题，但是能解决大部分问题 金钱充足的情况下租房尽量选择大平台，有保障，省时省力 租房子一分价钱一分货；别想着房东直租这种不切实际的东西 房子快到期了最好和房东提前说一下，防止再次遇到这种事情 努力、奋斗 [图片摄于2019年8月11号，上海经历了台风之后]","categories":[{"name":"Daily","slug":"Daily","permalink":"https://super-aviator.github.io/categories/Daily/"}],"tags":[],"author":"熊乾坤"},{"title":"Spring中的@RequestBody注解与常规的HTTP方法的传值方式","slug":"Spring中的-RequestBody注解","date":"2019-08-30T02:31:00.000Z","updated":"2021-02-23T13:00:00.000Z","comments":true,"path":"2019/08/30/Spring中的-RequestBody注解/","link":"","permalink":"https://super-aviator.github.io/2019/08/30/Spring%E4%B8%AD%E7%9A%84-RequestBody%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"上周进行项目开发的时候，发现前端的含有文件的表单数据时后台接收报错，异常的大致意思是表单类型不支持，我也是有点蒙逼，以前也遇到过这种问题，加上@RequestBody就可以，所以这次我也加上了@RequestBody注解，结果还是报错，这时前端发消息过来，告诉我不能加@RequestBody,我去掉之后果然好了，好吧。一直没弄明白什么时候要加@RequestBody什么时候不要加，趁着这个迭代的任务很轻松，学习一下Spring中@RequestBody注解和后端如何接收常用的HTTP方法传过来的数据，结合PostMan对结果进行测试。 @RequestBody注解 @RequestBody注解常用来处理POST请求，并且content-type不是默认的application/x-www-form-urlcoded编码的内容，比如说：application/json或者是application/xml等。一般情况下来说常用其来处理application/json类型。 @RequestMapping注解的方法的参数中包含了@RequestBody注解，那么Spring会首先查看请求中的Content-Type头部，然后根据Content-Type头部去查找合适的HttpMessageConverter 例如，如果客户端发送的Spittle数据是JSON表述形式，那 么Content-Type头部信息可能就会是“application/json”。在 这种情况下，DispatcherServlet会查找能够将JSON转换为Java 对象的消息转换器。如果Jackson 2库在类路径中，那 么MappingJackson2HttpMessageConverter将会担此重任，将 JSON表述转换为Spittle，然后传递到saveSpittle()方法中。 这个方法还使用了@ResponseBody注解，因此方法返回的Spittle 对象将会转换为某种资源表述，发送给客户端。 在《Spring 实战》中，表明了@RequestBody注解的含义和使用方式：用来解析请求体（可能是POST,PUT,DELETE,GET请求）中Content-Type为application/json类型的请求，利用消息转换器将其转换为对应的java对象（必须使用VO对象去接收），那么什么类型的消息能够加上@RequestBody，什么类型的消息不能加呢？ 表单类型 MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。Content-Type头部后面可以追加;charset=UTF-8指定编码格式,例如：Content-Type:x-www-from-urlencoded;charset=UTF-8 Content-Type字段表明了请求的请求体类型，可以是如下几种常见的类型：常见媒体格式如下: text/html ： HTML格式 text/plain ：纯文本格式 text/xml ： XML格式 image/gif ：gif图片格式 image/jpeg ：jpg图片格式 image/png：png图片格式 multipart/form-data：（体数据被编码为一条消息，页上的每个控件对应消息中的一个部分，这个一般文件上传时用） 以application开头的媒体格式类型： application/xhtml+xml ：XHTML格式 application/xml ： XML数据格式 application/atom+xml ：Atom XML聚合格式 application/json ： JSON数据格式 application/pdf ：pdf格式 application/msword ： Word文档格式 application/octet-stream ： 二进制流数据（如常见的文件下载） application/x-www-form-urlencoded ： 中默认的encType,form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） 下面是常见的表单提交的Content-Type的取值： application/x-www-form-urlencoded 如果使用的是GET请求，浏览器用x-www-form-urlencoded的编码方式把form数据转换成一个字串（name1=value1&amp;name2=value2…），然后把这个字串append到url后面，用?分割，加载这个新的url。 如果使用的是POST请求，会采用类似GET的字符串拼接的方式，将拼接的key-value字段放到body里面，而非url的后面,所以POST请求的url长度是没有限制的，因为拼接的url请求参数都存放在body里面,如下 POST HTTP/1.1 Host: 127.0.0.1:8000 Content-Type: application/x-www-form-urlencoded Cache-Control: no-cache Postman-Token: e8c31d7a-fd52-cbf2-2741-07d73cb1101b keyword=panda&amp;author=zane 注意：使用application/x-www-form-urlencoded编码方式的请求会对所有非ASCII的字符使用%HH的方式进行转换，所以一个非ASCII字符会由三个字符去表示，当非ASCII非常多时，会增加大约三倍的带宽，这无疑是一种浪费。 multipart/form-data如果没有type=file的控件，用默认的application/x-www-form-urlencoded就可以了。 但是如果有type=file的话，Content-Type就会升级使用multipart/form-data类型。浏览器会把整个表单以控件为单位分割，**并为每个部分加上Content-Disposition(form-data或者file),Content-Type(默认为text/plain),name(控件的name，即字段名)等信息，并加上分割符(boundary)**，例如： POST / HTTP/1.1 Host: 127.0.0.1:8000 Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW Cache-Control: no-cache Postman-Token: 090df52c-d103-279b-1479-50e6a7fef58b ------WebKitFormBoundary7MA4YWxkTrZu0gW Content-Disposition: form-data; name=&quot;keyword&quot; panda ------WebKitFormBoundary7MA4YWxkTrZu0gW Content-Disposition: form-data; name=&quot;author&quot; zane ------WebKitFormBoundary7MA4YWxkTrZu0gW 上面的请求中，keyword键对应的值为panda,author键对应的值为zane。 首先我们看请求头的 Content-Type 它除了正常的 multipart/form-data 外还多了一个 boundary ，这个 boundary 的意思和字面意思一样就是分界线，通过分界线将每个键值对用 boundary 分割开来以示区别,这个分界线是特殊选择出来的，以便该boundary不会出现在任何有效负载中。现在我们看请求体，我们注意到boundary 将键值对分割后的每一部分都有 Content-Disposition 字段，实际上该字段的值必须为 form-data 而且后面必须加上 name 指定这部分的键名，然后是一行空行，空行之后便是提交数据的内容。 之所以要弄的这么复杂是因为 multipart/form-data 要支持文件上传。 注意：使用multipart/form-data编码方式的请求不会对非ASCII字符进行转码，所以也就不会有消耗，但是对于简短的字母数字值(与大多数web表单一样)，添加所有MIME头的开销将大大超过更有效的二进制编码所节省的开销。 application/json数据以纯文本形式(text/json/xml/html)进行编码，POST方法使用这种方式会把表单的键值对以一个JSON字符串的方式放到HTTP的body里面。例如如下的postman中的请求示例：? 注意：当非post请求的请求体中也含有JSON字符串时，依旧可以使用@RequestBody拿到请求体中的数据。 Postman测试下面使用Postman来测试一下什么时候要加@Requestbody，什么时候不用加@RequestBody注解：首先是Controller中的代码，有个方法，一个使用了@RequestBody注解，一个没有使用： @RestController @RequestMapping(&quot;/requestBody&quot;) @Slf4j public class RequestBodyController &#123; @NoArgsConstructor @AllArgsConstructor @Getter @Setter private static class Request&#123; private String name; private Integer age; @JSONField(serialize = false,deserialize = false) private MultipartFile avatar; &#125; @PostMapping(&quot;/request&quot;) public HttpEntity&lt;Request&gt; generalRequest(Request request) &#123; log.info(&quot;generalRequest-&#123;&#125;&quot;,JSON.toJSONString(request)); return new HttpEntity&lt;&gt;(request); &#125; @PostMapping(&quot;/requestBody&quot;) public HttpEntity&lt;Request&gt; generalRequestBody(@RequestBody Request request) &#123; log.info(&quot;generalRequest-&#123;&#125;&quot;,JSON.toJSONString(request)); return new HttpEntity&lt;&gt;(request); &#125; &#125; 当请求中的ContentType分别为一下三种类型时，结果如下： 否加上注解\\ContentType x-www-form-urlencoded form-data application/json 不加@RequestBody注解 能接收 能接收 不能接收 加上@RequestBody注解 不能接收 不能接收 能接收 @RequestBody使用总结@RequestBody用于需要触发HttpMessageConverter的场景： 当HTTP请求的Content-Type头部为application/json时，需要加上@RequestBody注解，并使用默认的HttpMessageConverter或者自定义的HttpMessageConverter对请求的body中的json字符串转换为java对象。 当Content-Type头部的值为application/x-www-form-urlencoded或者multipart/form-data时，表名此请求是一个常规的表单请求，不能使用@RequestBody注解。 注意：使用@RequestBody注解的参数必须使用VO对象的方式去接收，否则会接收不到参数 参考地址: Spring之RequestBody的使用姿势小结 HTML 表单之不得不知 ENCTYPE Stackoverflow上大神的回答","categories":[{"name":"Spring","slug":"Spring","permalink":"https://super-aviator.github.io/categories/Spring/"}],"tags":[{"name":"Java Web","slug":"Java-Web","permalink":"https://super-aviator.github.io/tags/Java-Web/"}],"author":"熊乾坤"},{"title":"在云服务器上搭建Hexo之一顿百度加谷歌","slug":"Untitled","date":"2019-08-24T07:46:00.000Z","updated":"2021-02-23T13:00:10.000Z","comments":true,"path":"2019/08/24/Untitled/","link":"","permalink":"https://super-aviator.github.io/2019/08/24/Untitled/","excerpt":"","text":"今天周六，没啥事干，看书也看不进去T_T，华农兄弟：这样下去不行的。刚好前几天跟风买了个阿里云1H2G1M的云服务器，一年114块，肉疼。。，想着把电脑里面的Hexo乱七八糟的都搬到云服务器上去，这样在公司也可以瞎鸡儿写点东西了，建站的话目前还不想弄，放到GitHub上既稳定，又省力。 现在使用的Hexo是便携版的，安装没有什么技术含量，一键安装，这次想试一试使用完整版的Hexo,如果失败了再用便携版；文字编辑使用的是知乎上搜到的hexo-admin插件，非常好用，也不用敲太多命令行，直接点击就可以发布，很方便，但是唯一的缺点就是不能在线编辑，所以在公司精力十足的时候想记录一点学到的东西，但是只能写到别的地方，回来再使用hexo发布，很不方便，同时回到家就想洗了睡，根本不想打开电脑，所以如果能够在公司和家里都能记录，想想都很开心。 因为hexo-admin会打开本地的4000端口，用浏览器访问localhost:4000就可以直接开始用，所以我目前的想法是把hexo部署到阿里云的主机上，安装上admin的插件，然后把服务器的4000端口打开，再安装一个nginx对外面的访问进行代理，这样在外网上输入云服务器的ip+4000端口就可以访问了，按道理是可行的，如果再设置一下hosts文件，那岂不是和家里使用一模一样了，所以想试一试。成功了就去楼下网吧玩几个小时放松一下嘤嘤嘤。 由于linux命令行只会一点皮毛的皮毛的皮毛的皮毛的皮毛的皮毛的皮毛的皮毛的皮毛的皮毛的皮毛（吃了没有文化的亏.jpg）,所以只能一边百度一边弄。开始了开始了。 安装必须的乱七八糟的软件搭建Hexo需要以下东西，一个一个来。 Git NodeJs Hexo 参考地址： 让你的Hexo博客支持远程编辑！ 安装Git首先凭印象敲，使用yum install git,过一会儿提示安装完成，使用git --version 查看git的版本为1.8.3.1，网上说版本太老了，所以要安装新版本的git，yum里面的版本太老了。 使用yum remove git删除旧版本的git。 然后把最新版本的git下载到/usr/local/software文件夹下tar -zxvf name解压。 安装编译所需的组件yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker，这个过程会安装yum上的git,所以还需要删除旧版本的git。 使用make prefix=/usr/local/git执行编译，并制定编译之后的文件夹路径 使用make prefix=/usr/local/git安装git到指定文件夹 使用git --version查看是否安装成功，对于文章中的倒数第二步的设置环境变量我没有做，不晓得行不行。 参考地址： CentOS安装git 安装NodeJS我直接使用yum install nodejsyum安装nodejs，hexo要求nodejs必须6.9以后的版本，yum中的版本是6.17，满足要求就OK了。使用node --version查看当前安装的版本是否符合要求 安装hexo这步就直接使用hexo文档上的说明进行安装： npm install -g hexo-cli 安装完成使用hexo -version查看版本 安装hexo-admin插件在安装插件之前，需要初始化博客，步骤如下： cd进入你想要的文件夹下，例如：cd /usr/local/hexo/ 初始化博客hexo init blog这回创建一个blog文件夹 执行cd blog之后再执行npm install 这里需要删除hexo默认的文章rm source/_posts/hello-world.md,然后执行rm -rf themes/landscape删除默认的主体 初始化博客之后，就可以安装hexo-admin插件插件了，这个部分可以使用hexo-admin官网上的教程进行安装 npm install --save hexo-admin 安装完成后，使用hexo c、hexo s、hexo g、hexo d 命令开始使用了。以前使用便携版时，命令行简化了server，直接使用hexo -s就可以使用。因为以前的文章都在本地的电脑中，需要将source.post文件夹下的文件拷贝到云服务器上，配置文件和主题也可以考过去，省的重新配置麻烦。 注意，如果这个时候执行hexo d进行部署，会提示: ERROR Deployer not found: git 按照网上搜索的，首先需要安装一个插件： npm install --save hexo-deployer-git 然后使用hexo d命令会提示需要设置git邮箱和用户名，所以按照提示的命令，对git邮箱和名字进行设置： git config --global user.email &quot;邮箱&quot; git config --global user.name &quot;名字&quot; 然后就可以使用hexo d进行部署了 然而在使用hexo-admin插件总的Deploy功能部署时，会提示： Error: Config value &quot;admin.deployCommand&quot; not found 需要创建一个脚本，然后点击发布按钮时，会执行这个脚本，步骤如下： 在_config.yml里面填写好deployCommand的存储路径之后，在该路径下生成脚本； touch deploy.sh; vim deploy.sh; 输入以下内容 #!/usr/bin/env sh hexo g hexo d 保存退出，并赋予执行权限： chmod +x deploy.sh 修改配置文件,在hexo的配置文件_config.yml文件中的admin配置下面加入下面的配置，指定脚本的位置： admin: deployCommand: &#39;./hexo-publish.sh&#39; 但是这时候如果使用hexo-admin自带的Deploy按钮进行部署，会发现依旧是部署不成功的，这时，需要配置一下云服务器上的git的SSH，然后需要在hexo的配置文件_config.yml文件中，使用SSH的仓库地址而非https的，具体步骤如下： 查看是否已经有了ssh密钥：cd ~/.ssh如果没有密钥则不会有此文件夹，有则备份删除 生成密钥： ssh-keygen -t rsa -C &quot;gudujianjsk@gmail.com&quot; 按3个回车，密码为空这里一般不使用密钥。最后得到了两个文件：id_rsa和id_rsa.pub 在github上添加ssh密钥，这要添加的是“id_rsa.pub”里面的公钥。打开http://github.com，登陆。 进入github设置页面，添加新的key。 修改hexo的配置文件_config.yml，将其中的repo仓库地址更换为SSH的地址，而非HTTPS的地址： 上面的步骤中第五步非常重要，否则使用Deploy功能时依旧会报错:could not read Password for...,必须使用SSH类型的仓库地址，这样的话hexo d命令也不需要输入密码了。很省力的。 参考地址： 为你的git添加SSH 弄完上面的步骤之后，就可以进行编辑和发布了，日常的功能算式满足了。开心，部署的时候会提示下面的错误，但是不用管，这是nodejs版本的问题： WARN =============================================================== WARN ========================= ATTENTION! ========================== WARN =============================================================== WARN NexT repository is moving here: https://github.com/theme-next WARN =============================================================== WARN It&#39;s rebase to v6.0.0 and future maintenance will resume there WARN =============================================================== fatal: could not read Password for &#39;https://super-aviator@github.com&#39;: No such device or address FATAL Something&#39;s wrong. you can find the solution here: https://hexo.io/docs/troubleshooting.html Error: Spawn failed at ChildProcess.&lt;anonymous&gt; (/usr/local/hexo/blog/node_modules/hexo-util/lib/spawn.js:52:19) at emitTwo (events.js:106:13) at ChildProcess.emit (events.js:191:7) at Process.ChildProcess._handle.onexit (internal/child_process.js:219:12) 如果搜索功能不能用的话，需要重新安装搜索的插件： npm install hexo-generator-searchdb --save 安装nginx安装nginx也可以使用yum中的bginx,使用yum install -y nginx 或者yum install nginx安装ngingx，前者与后者的区别是不用手动输入y。。。 安装之后的nginx的默认目录为： Nginx配置路径：/etc/nginx/ PID目录：/var/run/nginx.pid 错误日志：/var/log/nginx/error.log 访问日志：/var/log/nginx/access.log 默认站点目录：/usr/share/nginx/html 最重要的是配置文件的目录为/etc/nginx/nginx.conf,默认端口为80 可以使用netstat -ntulp |grep 80查看80端口下是否有进程占用 可以使用ps -ef|grep nginx查看进程的进程号 使用kill -QUIT 2072停止进程号的进程 使用nginx启动nginx 使用nginx -t检查配置文件语法 使用nginx -s reload重启nginx 参考地址： CentOS下安装nginx CentOS7下的nginx安装 配置nginx到这一步，我已经完成了大部分的安装工作，接下来就需要配置nginx了，因为hexo的命令hexo g会在public文件夹下面生成所有网页的.html文件，所以需要把nginx的root目录指向public文件夹，根目录/设置为index.html，这样当浏览器访问到ip的80端口时，就可以直接进入index.html主页。 修改etc/nginx/nginx.conf文件，在80端口配置一下： server &#123; listen 80 default_server; listen [::]:80 default_server; server_name xqk; root /usr/local/hexo/blog/public; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; index index.html index.htm; &#125; &#125; 在这之前，需要开启云服务器的端口80和4000，开启的时候，值得注意的是，授权对象里面，如果填写0.0.0.0/0则表示允许所有人访问。 按照上面的操作之后，如果在浏览器直接数据ip地址，就可以访问到hexo -g生成的文章了。 但是需要注意的是，这个生成的文章不是动态的，在admin页面编辑的文章在这里是不能动态改变的，还是得需要到4000端口去访问，是不是瞬间感觉有点鸡肋了呢。。。 升级nodejs和hexo的版本在hexo-admin的说明文档中，我发现hexo-admin是支持直接粘贴图片的，沃德天，那么帅，这不正是我一直想要的功能吗？结果在新搭建的hexo中使用hexo-admin插件编辑文章的时候并不能粘贴图片，what？？？，长得丑就不能粘贴了吗？ 一顿百度加谷歌之后，还是百思不得姐啊，但是我一直怀疑是hexo版本太低的原因，第三天之后，也就是2019-8-27，我升级了一下hexo的版本，发现竟然可以粘贴图片了。耶耶耶。 首先升级nodejs的版本，需要使用n模块去升级，至于n模块是什么我也不知道，我也不敢问。。。 使用下面的命令安装n模块npm install-g n 升级node.js到最新稳定版n stable npm常用地址： npm -v #显示版本，检查npm 是否正确安装。 npm install express #安装express模块 npm install -g express #全局安装express模块 npm list #列出已安装模块 npm show express #显示模块详情 npm update #升级当前目录下的项目的所有模块 npm update express #升级当前目录下的项目的指定模块 npm update -g express #升级全局安装的express模块 npm uninstall express #删除指定的模块 参考地址：升级nodejs 当前的hexo版本可使用hexo --version 去查看：现在的版本是2.0.0,确实是有点太低了，又一顿百度加谷歌之后，我学会了升级hexo，步骤如下： cd进入你的博客目录下，例如：cd /usr/local/hexo/blog 执行命令npm update过一段时候之后，你在该目录下执行hexo –version就会发现hexo的版本已经更新了。 回到hexo-admin中，体验一下markdown中复制粘贴图片所带来的乐趣吧。如果粘贴图片发现不能正常显示的话，尝试点击一下这个按钮:然后再切换回来编辑页面，图片就可以正常显示啦。 后台运行hexo命令因为目前是在远程终端中执行的hexo -s命令，所以当终端断开的时候命令也就终止执行了，那么就需要将命令放在后台执行，这样就可以将hexo的命令脱离终端来运行了，网查又又是一顿查，发现可以使用nohup命令来实现，具体操作的步骤如下： nohup的使用方式是nohup [command] &amp;，末尾的&amp;也可以不加，加上&amp;表示后台执行。然后命令就会脱离终端自己去撒丫子运行，这时候如果重新登录终端，会发现命令依旧在执行。例如，在云服务器中执行如下命令（别忘了cd进入博客文件夹内部执行）： nohup hexo s &amp; 然后退出终端再次登录终端，注意，退出终端需要使用exit命令的方式去退出，否则nohup不能在后台运行。重新登录终端后，使用 ps aux |grep hexo 会发现hexo进程在后台执行： 使用下面的命令提取hexo进程的pid： ps -aux|grep hexo| grep -v grep | awk &#39;&#123;print $2&#125;&#39; 得到hexo进程的pid之后，如果想要终止该进程，可以使用下面的命令去终止掉该PID对应的进程: kill -9 PID 好了，启动和终止都学会了，可以满足最基本的需求了嘤嘤嘤。 参考地址：nohup 命令解析 总结零零散散弄了三四五六天终于算是完成了，以后也可以在公司也能记东西啦，美滋滋。 唯一遗憾的是当初买云服务器的时候没有选择轻量应用服务器,选择的是ESC，但是ESC带宽只有1M，所以加载文章列表的时候太慢了，下载速度只有128kb/s，8M大小的文章列表要等一分钟左右才能全部加载完毕。。。轻量应用服务器有5M的峰值带宽，加载的时候会快很多。有点后悔啊，失算失算。","categories":[{"name":"Daily","slug":"Daily","permalink":"https://super-aviator.github.io/categories/Daily/"}],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://super-aviator.github.io/tags/Hexo%E5%8D%9A%E5%AE%A2/"}],"author":"熊乾坤"},{"title":"MySQL常用的数据类型与表设计要点","slug":"ySQL数据类型","date":"2019-07-23T14:12:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2019/07/23/ySQL数据类型/","link":"","permalink":"https://super-aviator.github.io/2019/07/23/ySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"写这篇东西的起因是今天在公司的接口评审会时，组里的成员提了一个问，她看见组里开发人员设计的表中，有的主键使用的数据类型是INT(11)，而有的使用的是INT(15),有的使用的是BIGINT(16)啥的，所以她问可不可能存在数值溢出的情况，这是我想起来以前看的一篇博客，说括号里的数字并不是代表能够存储的范围，而是为了填充零，所以我和她说表示的数据范围是不变的，都是INT都是四字节，但是组里的大佬们一致认为INT（11）表示的是能够存储的最大数字位数为11位，能够满足业务需求，在大佬们的一再强调下我他喵的动摇了。。。开始自闭。 所以只知识不能是一知半解滴，so，结合《深入浅出MySQL》这本书，来了解一下MySQL的数据类型吧，同时因为最近在写的接口需要自己设计表结构，所以结合前几天看的孤独烟的关于表设计要点的博客，总结一下设计表的一些要点。 MySQL常见的数据类型整型MySQL中的整型包括TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT。他们各自表示的范围如下:需要注意的是，整型也可以后面加上数据，例如int(10)，表示存储的数值小于多少10位时，在数值的左侧使用零填充，需要配合ZEROFILL和UNSIGNED关键字使用(ZEROFILL域自动是UNSIGNED的)，而不是表示能存储多少位的数字。 小数类型MySQL中的小数类型包括浮点数和定点数，浮点数包括FLOAT（单精度浮点数）,DOUBLE（双精度浮点数），定点数包括DECIMAL(也叫作NUMERIC),他们对应的长度如下：浮点数和定点数都可以使用非标准用法：[FLOAT|DOUBLE|DECIMAL]（M,D）的方式使用，M称为精度，D称为标度，表示的是可以存储M为数字，其中包括D位小数，所以在创建小数类型的字段时需要保证M&gt;=D（当M==D时，只能存储D位小数，数值大小不能大于1），值得注意的是，不使用精度和标度时，FLOAT和DOUBLE按存储的位数进行保存，而DECIMAL默认整数为10位，小数为0位，即（10,0）,同时非标准用法可移植性差，在需要迁移的数据库中不应该使用，当存入的数的小数部分的位数多于指定的标度D时，数据库会对数据进行自动四舍五入。 FLOAT和DOUBLE由于计算机存储方式的原因，精度会有损失，而DECIMAL不会，所以在存储货币等精度要求高的数据时需要使用DECIMAL类型 时间类型MySQL中有以下四种时间类型，使用时需要根据业务区决定： 当插入的时间超出给定的范围时，插入的数据会变成零值。 其中，值得注意的是TIMESTAMP类型会跟着数据库的时区进行变化，所以不同时区多对应的TIMESTAMP类型的数据是不一样的。还需要注意的是，一张表中，最多可以有一列数据可以为CURRENT_TIMESTAMP类型，即如果该列插入null值，则数据库会自动将其设置为当前时间，注意，每个数据库最多只能有一列拥有CURRENT_TIMESTAMP属性。 字符串类型JSON类型Mysql5.7中新增了JSON数据格式，专门用于保存JSON字符串，结合官方文档，来看一下这种数据格式相对于TEXT有什么优势以及几个常用的用于处理JSON字符串的JSON函数吧： 上面的文字表名JSON格式存储的大小和LONGBOB、LONGTEXT格式的大小差不多，同时长度的最大保存大小为系统变量max_allowed_packet的值，当在内存操作时，可能会大于这个值。同时，JSON格式的数据不能是NOT-NULL的，经过我的测试证实了这一点，即JSON格式的数据默认是NULL的。，MySQL内部使用utf8mb4字符集和utf8mb4_bin排序规则处理JSON上下文中使用的字符串。 其他字符集中的字符串将根据需要转换为utf8mb4。（对于ascii或utf8字符集中的字符串，不需要转换，因为ascii和utf8是utf8mb4的子集。） 注意：当插入的JSON对象字符串的键重复时，只会保留最后一个该键的键值对，例如： CREATE TABLE t1 (c1 JSON); INSERT INTO t1 VALUES(&#39;&#123;&quot;x&quot;: 17, &quot;x&quot;: &quot;red&quot;&#125;&#39;),(&#39;&#123;&quot;x&quot;: 17, &quot;x&quot;: &quot;red&quot;, &quot;x&quot;: [3, 5, 7]&#125;&#39;); SELECT c1 FROM t1; &gt;+-----------+ | c1 | +-----------+ | &#123;&quot;x&quot;: 17&#125; | | &#123;&quot;x&quot;: 17&#125; | +-----------+ Mysql中常用的JSON函数 JSON_VALIDJSON_VALID用于判断参数中的JSON字符串是否是合法的，如果合法返回1，如果非法，返回0，如果参数为空，则报错。 SELECT JSON_VALID(&#39;[&quot;KEY&quot;:1]&#39;); &gt; 1 SELECT JSON_VALID(&#39;[&quot;KEY&quot;:1&#39;); &gt; 0 SELECT JSON_VALID(); error - JSON_TYPE JSON_TYPE()函数返回参数中JSON字符串的类型，如果参数为空或者不是JSON类型的字符串，则报错： ```sql SELECT JSON_TYPE(&quot;[1,2,3]&quot;); &gt; ARRRAY SELECT JSON_TYPE(&#39;&#123;&quot;k1&quot;:23&#125;&#39;); &gt; OBJECT SELECT JSON_TYPE(); &gt; Error Code: 1582. Incorrect parameter count in the call to native function &#39;JSON_TYPE&#39; 0.000 sec SELECT JSON_TYPE(&quot;[1,2,3]&quot;)=&#39;ARRAY&#39;; &gt; 1 JSON_ARRAYJSON_ARRAY会返回包含所有参数的JSON数组字符串，当参数为空时返回空JSON数组，当参数不为JSON字符串格式时报错。SELECT JSON_ARRAY(&#39;A&#39;,23,45.3); &gt; [&quot;A&quot;, 23, 45.3] SELECT JSON_ARRAY(); [] - JSON_OBJECT JSON_OBJECT函数和JSON_ARRAY函数类似，返回参数对构成的JSON对象，**JSON要求键必须是字符串类型。** ```sql SELECT JSON_OBJECT(&#39;key1&#39;,1,&#39;key2&#39;,&#39;hello&#39;); &gt; &#123;&quot;key1&quot;: 1, &quot;key2&quot;: &quot;hello&quot;&#125; SELECT JSON_OBJECT(); &gt; &#123;&#125; JSON_MERGEJSON_MERGE函数返回两个或多个JSON字符串拼接之后的字符串,当参数都是JSON对象时，拼接之后结果的JSON_TYPE为OBJECT,当参数含有JSON数组时，返回结果的JSON_TYPE为JSON数组。当拼接的JSON对象中包含有相同的键时，该键对应的值会以数组的形式保存。，当拼接的参数是单个数值而非JSON字符串或者单个字母时，该函数的结果相当于JSON_ARRAY。首先会将单个的数字用[]包围，然后对其进行合并 SELECT JSON_MERGE(&#39;&#123;&quot;key1&quot;:1,&quot;key2&quot;:&quot;hello&quot;&#125;&#39;,&#39;[1,2,3]&#39;); &gt; [&#123;&quot;key1&quot;: 1, &quot;key2&quot;: &quot;hello&quot;&#125;, 1, 2, 3] SELECT JSON_MERGE(‘{“key1”:1,”key2”:”hello”}’,’{“key3”:123}’); {“key1”: 1, “key2”: “hello”, “key3”: 123} SELECT JSON_MERGE(‘{“a”:1}’,’{“a”:2}’,’[“A”]’); [{“a”: [1, 2]}, “A”] 所有的JSON函数的返回结果都可以使用变量进行保存，方便以后使用，例如： ```sql SET @J = JSON_MERGE(&#39;1&#39;,&#39;2&#39;); SELECT @J; &gt; [1, 2] MySQL表设计的要点日常的开发过程中需要自己设计表，但是自己太菜了，设计的时候毫不隐晦的说，都是瞎鸡儿设计的。。。（如果组长看到了，会不会过来捶我，哈哈哈）；今天下班比较早，根据知乎上的文章，学习一下MySQL表的设计要点，后面如果有新的知识点继续补充。 问题1:为什么一定要设一个主键？回答:因为你不设主键的情况下，innodb也会帮你生成一个隐藏列，作为自增主键。所以啦，反正都要生成一个主键，那你还不如自己指定一个主键，在有些情况下，就能显式的用上主键索引，提高查询效率！ 问题2:主键是用自增还是UUID?回答:肯定答自增啊。innodb 中的主键是聚簇索引。如果主键是自增的，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果不是自增主键，那么可能会在中间插入，就会引发页的分裂，产生很多表碎片！。 上面那句话看不懂没事，大白话一句就是:用自增插入性能好！另外，附一个测试表给你们，表名带uuid的就是用uuid作为主键。大家看一下就知道性能差距了:如上图所示，当主键是UUID的时候，插入时间更长，而且占用空间更大！额，大家千万不要忘了，当你回答自增主键后，想一下自增主键用完该怎么办？ ps：这个问题，你要是能把UUID讲出合理的理由也行。 问题3:主键为什么不推荐有业务含义?回答:有如下两个原因(1)因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。主键一旦发生变更，该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。(2)带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面插入数据的主键一定比前面的数据大。如果出现了，后面插入数据的主键比前面的小，就有可能引发页分裂，产生空间碎片。 问题4:表示枚举的字段为什么不用enum类型？回答:在工作中表示枚举的字段，一般用tinyint类型。 那为什么不用enum类型呢？下面两个原因 ENUM类型的ORDER BY操作效率低，需要额外操作 语法中，查询枚举值应该是字符串类型，所以需要格外注意 问题5:货币字段用什么类型?回答:如果货币单位是分，可以用Int类型。如果坚持用元，用Decimal。 千万不要答float和double，因为float和double是以二进制存储的，所以有一定的误差。 打个比方，你建一个列如下 CREATE TABLE `t` ( `price` float(10,2) DEFAULT NULL, ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 然后insert给price列一个数据为1234567.23，你会发现显示出来的数据变为1234567.25，精度失准！ 问题6:时间字段用什么类型?回答:此题无固定答案，应结合自己项目背景来答！把理由讲清楚就行！ varchar，如果用varchar类型来存时间，优点在于显示直观。但是坑的地方也是挺多的。比如，插入的数据没有校验，你可能某天就发现一条数据为2013111的数据，请问这是代表2013年1月11日，还是2013年11月1日？ 其次，做时间比较运算，你需要用STR_TO_DATE等函数将其转化为时间类型，你会发现这么写是无法命中索引的。数据量一大，是个坑！ timestamp，该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。2038年以后的时间，是无法用timestamp类型存储的。 但是它有一个优势，timestamp类型是带有时区信息的。一旦你系统中的时区发生改变，例如你修改了时区 SET TIME_ZONE = &quot;america/new_york&quot;; 你会发现，项目中的该字段的值自己会发生变更。这个特性用来做一些国际化大项目，跨时区的应用时，特别注意！ datetime，datetime储存占用8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显然，存储时间范围更大。但是它坑的地方在于，他存储的是时间绝对值，不带有时区信息。如果你改变数据库的时区，该项的值不会自己发生变更！ bigint，也是8个字节，自己维护一个时间戳，表示范围比timestamp大多了，就是要自己维护，不大方便。 问题7:为什么不直接存储图片、音频、视频等大容量内容?回答:我们在实际应用中，都是用HDFS来存储文件。然后mysql中，只存文件的存放路径。mysql中有两个字段类型被用来设计存放大容量文件，也就是text和blob类型。但是，我们在生产中，基本不用这两个类型！ 主要原因有如下两点 Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。导致查询效率缓慢 binlog内容太多。因为你数据内容比较大，就会造成binlog内容比较多。大家也知道，主从同步是靠binlog进行同步，binlog太大了，就会导致主从同步效率问题！ 因此，不推荐使用text和blob类型！ 问题8:字段为什么要定义为NOT NULL?回答:OK，这问题从两个角度来答 (1)索引性能不好 Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。 —— 出自《高性能mysql第二版》 (2)查询会出现一些不可预料的结果 这里举一个例子，大家就懂了。假设，表结构如下 create table table_2 ( `id` INT (11) NOT NULL, name varchar(20) NULL ) 表数据是这样的你执行语句select count(name) from table_2;你会发现结果为2，但是实际上是有四条数据的！ 类似的查询问题，其实有很多，不一一列举。 记住，因为null列的存在，会出现很多出人意料的结果，从而浪费开发时间去排查Bug. COUNT(1)、COUNT(*)、COUNT(FILE)的区别COUNT(1)与COUNT(*)的执行效果、性能是一样的，会统计数据库表中所有数据的函数（包括NULL的情况），而COUNT(FILE)则只会统计该字段的非NULL的数据的行数，执行效率上也会比前两者慢很多倍。 参考地址：MySQL表设计要点","categories":[{"name":"Database","slug":"Database","permalink":"https://super-aviator.github.io/categories/Database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://super-aviator.github.io/tags/MySQL/"}],"author":"熊乾坤"},{"title":"本地Redis集群的搭建与SpringBoot中JedisCluster客户端的使用","slug":"本地Redis集群的搭建与SpringBoot中Jedis集群客户端的使用","date":"2019-07-08T14:30:00.000Z","updated":"2021-02-23T13:00:04.000Z","comments":true,"path":"2019/07/08/本地Redis集群的搭建与SpringBoot中Jedis集群客户端的使用/","link":"","permalink":"https://super-aviator.github.io/2019/07/08/%E6%9C%AC%E5%9C%B0Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8ESpringBoot%E4%B8%ADJedis%E9%9B%86%E7%BE%A4%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"最近在学习《Redis开发与运维》这本书，没有很仔细的看，主要讲解的运维，也包含有开发的部分，重点看了开发的部分，感觉这本书写的是真的好，整本书没有一点废话（Thinking In Java退出群聊QAQ ），全部是干货，昨天跟着书本在电脑上搭建了一个Redis集群，公司的Redis也是集群的方式，所以学习一下集群中的Redis和单机的区别，同时熟悉一下Redis集群的搭建的步骤和SpringBoot中对Redis Cluster的整合，不过我是在Windows下搭建的，命令都是一样的，没什么区别。 Redis集群搭建的步骤和槽的概念Redis集群搭建主要分为一下几个步骤： 准备节点(启动Redis服务) 节点握手 分配槽 为主节点分配从结点 在开始搭建之前复习一下Redis的槽的知识： Redis Cluser采用虚拟槽分区，所有的键根据哈希函数映射到0~16383整数槽内，计算公式：slot=CRC16（key）&amp;16383。每一个节点负责维护一部 分槽以及槽所映射的键值数据，如图10-5所示。 Redis集群的限制需要注意的是，集群的Redis和单节点的Redis相比，有很多的局限： key批量操作支持有限。如mset、mget，目前只支持具有相同slot值的key执行批量操作。对于映射为不同slot值的key由于执行mget、mget等操可 能存在于多个节点上因此不被支持。 key事务操作支持有限。同理只支持多key在同一节点上的事务操作，当多个key分布在不同的节点上时无法使用事务功能。 key作为数据分区的最小粒度，因此不能将一个大的键值对象如hash、list等映射到不同的节点。 不支持多数据库空间。单机下的Redis可以支持16个数据库，集群模式下只能使用一个数据库空间，即db0。 复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。 开始搭建Redis集群一般由多个节点组成，节点数量至少为6个才能保证组成完整高可用的集群。在windows下将redis文件夹拷贝6份，如图所示： 运行服务然后为每个redis服务，都要使用如下的配置，根据端口号的不同进行区分。每个节点需要开启配置cluster-enabled yes，让Redis运行在集群模式下。建议为集群内所有节点统一目录，一般划分三个目录：conf、 data、log，分别存放配置、数据和日志相关文件。把6个节点配置统一放在 conf目录下，集群相关配置如下： #节点端口 port 7000 # 开启集群模式 cluster-enabled yes # 节点超时时间，单位毫秒 cluster-node-timeout 15000 # 集群内部配置文件 cluster-config-file &quot;nodes-7000.conf&quot; 然后使用下面的命令开启Redis服务： redis-server conf/redis-&#123;port&#125;.conf # port为该端口对应的配置文件 集群中每一个节点都有一个配置文件，保存了集群信息，集群配置文件由服务自动生成，不需要手动去修改，以免出现错误。 节点间握手现在开启了六个Redis服务，但是他们是彼此分离的，还没有组合成一个集群，所以需要使用命令让他们握手，形成一个能够互相感知的集群。 登录某一个结点，然后分别使用下面的命令去和每一个节点握手： cluster meet&#123;ip&#125;&#123;port&#125; 也可以使用Redis Shell命令去执行，例如 redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1:7001 redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1:7002 ... 需要注意的是，只需要在一个结点上执行握手命令，握手信息会在集群中自动传播。这样其他节点会自动发现新节点并发起握手流程。最后执行cluster nodes命令确认6个节点都彼此感知并组成集群。 可以使用cluster nodes查看集群结点的状态： 089f76372aa3f9373f72850ebb5909c978665c3b 127.0.0.1:7001 master - 0 1562679329399 1 connected 5462-10922 605773c926b468fb079cfacf021bdeea2ecc1747 127.0.0.1:7002 myself,master - 0 0 5 connected 10923-16383 c8f0ae93b339311acb74807bdaead7cbf6eb5738 127.0.0.1:7004 slave 089f76372aa3f9373f72850ebb5909c978665c3b 0 1562679330363 1 connected 551693dbe8904405e925ec1fab859051597905d4 127.0.0.1:7003 slave 53613c8c8c7e0f060de44a36c94e0abf35d8cee0 0 1562679329297 3 connected c8317c12ddb83e22c3b0244d21e1ea53c7a56e00 127.0.0.1:7005 slave 605773c926b468fb079cfacf021bdeea2ecc1747 0 1562679327174 5 connected 53613c8c8c7e0f060de44a36c94e0abf35d8cee0 127.0.0.1:7000 master - 0 1562679331423 2 connected 0-5461 上面是槽点分配完成的结点。可以使用cluster info查看集群状态： cluster_state:down cluster_slots_assigned:o cluster_slots_ok:0 cluster_slots_pfail:0 cluster_slots_fail:0 cluster_known_nodes:6 cluster_size:3 cluster_current_epoch:5 cluster_my_epoch:5 cluster_stats_messages_sent:82521 cluster_stats_messages_received:82273 从中可以看出集群中共有六个节点，并已近互相感知了对方的存在。此时集群状态为down,表示不可用。 分配槽点Redis集群中，数据保存的位置是通过key的映射的槽点来决定的，Redis集群把所有的数据映射到16384个槽中（0-16383）。每个key会映射为一个固定的槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。通过 cluster addslots命令为节点分配槽。这里利用bash特性批量设置槽（slots）， 命令如下： redis-cli -h 127.0.0.1 -p 6379 cluster addslots &#123;0...5461&#125; redis-cli -h 127.0.0.1 -p 6380 cluster addslots &#123;5462...10922&#125; redis-cli -h 127.0.0.1 -p 6381 cluster addslots &#123;10923...16383&#125; 不过windows下不支持节点批量操作，只能手动去添加，可以手动写一个脚本去自动添加结点，windows平台下，可以新建一个bat脚本，然后复制如下代码（脚本是网上照着别人的100求和的脚本改的，执行的慢的很。。。）： 7000节点 addslots.bat @echo off setlocal ENABLEDELAYEDEXPANSION for /l %%i in (0,1,5461) do ( redis-cli -h 127.0.0.1 -p 7000 cluster addslots %%i REM echo %%i ) pause 7001节点 addslots.bat @echo off setlocal ENABLEDELAYEDEXPANSION for /l %%i in (5462,1,10922) do ( redis-cli -h 127.0.0.1 -p 7001 cluster addslots %%i REM echo %%i ) pause 7002结点 addslots.bat @echo off setlocal ENABLEDELAYEDEXPANSION for /l %%i in (10923,1,16383) do ( redis-cli -h 127.0.0.1 -p 7002 cluster addslots %%i REM echo %%i ) pause 在等待脚本执行完成之后，所有的槽点都均匀的分配给了三个主节点，集群的状态也从不可用变为可用状态，可以使用cluster info查看集群状态，使用cluster nodes查看槽点的分配。 设置从结点首次启动的节点和被分配槽的 节点都是主节点，从节点负责复制主节点槽信息和相关的数据。使用cluster replicate {nodeId}命令让一个节点成为从节点。其中命令执行必须在对应的 从节点上执行，nodeId是要复制主节点的节点ID，命令如下： 127.0.0.1:7003&gt;cluster replicate cfb28ef1deee4e0fa78da86abe5d24566744411e OK 127.0.0.1:7004&gt;cluster replicate 8e41673d59c9568aa9d29fb174ce733345b3e8f1 OK 127.0.0.1:7005&gt;cluster replicate 40b8d09d44294d2e23c7c768efc8fcd153446746 OK 同样也可以编写脚本添加从结点，例如如下代码将7003节点设置为7000的从结点： 7003 replicate.bat @echo off setlocal ENABLEDELAYEDEXPANSION redis-cli -h 127.0.0.1 -p 7003 cluster replicate 53613c8c8c7e0f060de44a36c94e0abf35d8cee0 pause 目前为止，我们依照Redis协议手动建立一个集群。它由6个节点构成，3个主节点负责处理槽和相关数据，3个从节点负责故障转移。Redis官方推荐使用Ruby的工具Redis-trib.rb来搭建Redis集群，不过这就是运维的事情了。（我主要还是嫌安装Ruby啥的太麻烦了QAQ，懒得弄。） SpringBoot中JedisCluster客户端的使用SpringBoot中，可以会用Spring-Data-Redis对Redis进行操作，所有的Redis操作都被封装在Template模板中。 在application.yml配置文件中，需要指定集群的各个节点的IP、端口号。并且需要指定redis第一次连接到的结点信息。在yml中，配置如下： spring: redis: host: 127.0.0.1 database: 0 ssl: false port: 7000 cluster: # redis集群的ip和端口 nodes: 127.0.0.1:7000,127.0.0.1:7001,127.0.0.1:7002, 127.0.0.1:7003,127.0.0.1:7004,127.0.0.1:7005 max-redirects: 1 #集群最大跳转次数 jedis: pool: max-active: 8 #线程池中最大线程数 min-idle: 2 #最大空闲线程数 timeout: 5000ms #连接超时时间 在集群模式下，Redis接收任何键相关命令时首先计算键对应的槽，再根据槽找出所对应的节点，如果节点是自身，则处理键命令；否则回复 MOVED重定向错误，通知客户端请求正确的节点。这个过程称为MOVED重 定向 redis-cli可以使用-c参数自动帮我们连接到正确的节点执行命令，这个过程是在redis-cli内部维护，实质上是client端接到MOVED信息之后再次发起请求，并不在 Redis节点中完成请求转发 redis-cli -h 127.0.0.1 -p 7000 -c redis客户端执行命令的方式如下： 计算slot并根据slots缓存获取目标节点连接，发送命令。 如果出现连接错误，使用随机连接重新执行键命令，每次命令重试对redi-rections参数减1。 捕获到MOVED重定向错误，使用cluster slots命令更新slots缓存（renewSlotCache方法）。 重复执行1）~3）步，直到命令执行成功，或者当redirections&lt;=0时抛出Jedis ClusterMaxRedirectionsException异常。 上面的配置中，max-redirects指定了集群中的最大跳转次数，如果查找键时跳转的次数超过阈值，就会抛出异常。 SpringDataRedis封装了Redis的操作，所有操作通过RedisTemplate提供相同的模板,使用方式为： @Autowired private RedisTemplate&lt;String,String&gt; StringRedisTemplate; 对于String类型的键和值，RedisTemplat提供了StringRedisTemplate可以直接注入使用。 @Autowired private StringRedisTemplate stringRedisTemplate; 对于所有的非String类型，不能直接使用上面的方式，直接注入指定泛型类型的RedisTemplate，而需要使用下面的方式，配置特定类型的RedisTemplate的键和值的序列化器，才能够注入并使用： /** * 特定类型的RedisTemplate需要自己创建相应的bean才行。 * * @param redisConnectionFactory redis连接池 * @return 指定泛型类型的RedisTemplate */ @Bean public RedisTemplate&lt;String, User&gt; getRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; RedisTemplate&lt;String, User&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(redisConnectionFactory); //设置key的序列化器，非常重要 redisTemplate.setKeySerializer(new StringRedisSerializer()); //设置value的序列化器 redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(User.class)); return redisTemplate; &#125; 值得注意的是，如果不指定键的序列化器，可能会导致redis中存入的键因为编码的方式不同，在RedisTemplate中存入的键，使用命令行的方式查找失败。 上面的值的序列化器有多种选择，最常规的是序列化为JSON字符串进行保存。","categories":[{"name":"Database","slug":"Database","permalink":"https://super-aviator.github.io/categories/Database/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://super-aviator.github.io/tags/Redis/"},{"name":"NoSQL","slug":"NoSQL","permalink":"https://super-aviator.github.io/tags/NoSQL/"}],"author":"熊乾坤"},{"title":"Spring Data JPA中的一对一，一对多，多对多查询","slug":"Spring-Data-JPA中的一对一，一对多，多对多查询","date":"2019-06-22T11:10:00.000Z","updated":"2021-02-23T12:59:58.000Z","comments":true,"path":"2019/06/22/Spring-Data-JPA中的一对一，一对多，多对多查询/","link":"","permalink":"https://super-aviator.github.io/2019/06/22/Spring-Data-JPA%E4%B8%AD%E7%9A%84%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%8C%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"这几天学习一下Spring Data JPA中的一对一、一对多、多对多映射。这些映射还分单向关联和双向关联，在双向关联时还需要考虑对象序列化为JSON字符串时的死循环问题。 单向关联和双向关联 单向关联 单向关联指的是实体类A中有一个实体类B变量，但是实体类B中没有实体类A变量，即为单向关联。 双向关联 双向关联指的是实体类A中有一个实体类B变量，而实体类B中也含有一个实体类A变量，即为双向关联。 值得注意的是：Spring Data JPA中属性的集合需要使用Set来保存，如果使用List会抛出异常。 双向关联中序列化的死循环问题在双向关联时，可能会存在对象序列化成JSON字符创时的死循环问题，因为A中包含B，B中也包含A，序列化A中的B时，因为B也含有A，A又含有B，所以会死循环。 特南克斯首先你要理解这是双向关联，双向关联中你如果从数据库里面查询一个User对象，那么User对象里面有Role，Role里面又有User对象，那么你用syso输出User对象，如果toString方法里面包含有输出User.roles的话，那么是必然会造成死循环的。如果你用sping mvc等框架将后台数据返回给前台也是同理，也会造成返回的JSON数据死循环 使用Jackson时，可以使用@JsonIgnoreProperties注解来解决： @JsonIgnoreProperties(value = &#123; &quot;users&quot; &#125;) @ManyToMany(cascade = CascadeType.ALL,fetch = FetchType.LAZY) @JoinTable( name = &quot;TEACHER_USER_RELATION&quot;, joinColumns = @JoinColumn(name = &quot;UserId&quot;,referencedColumnName = &quot;id&quot;), inverseJoinColumns = @JoinColumn(name = &quot;TeacherId&quot;,referencedColumnName = &quot;id&quot;) ) private Set&lt;Teacher&gt; teachers; @JsonIgnoreProperties(value = { “users” })注解排除了Teacher中的User字段，从而避免了死循环问题。 一对一一对一映射需要@OneToOne注解和@JoinColumn注解配合使用，为了创建测试数据，首先定义一个User实体类，然后定义一个UserDetail实体类，其中User与UserDetail的关系是一对一的关系，即一个User对应一个UserDetail，一个UserDetail对应一个User。具体代码如下： @Data @Entity @Table(name = &quot;USER&quot;) public class User &#123; ... /** * 一对一 */ @JoinColumn(name = &quot;id&quot;,referencedColumnName = &quot;id&quot;) @OneToOne(cascade = &#123;CascadeType.ALL&#125;,fetch = FetchType.LAZY) private UserDetail userDetail; &#125; 在被关联的UserDetail代码如下： @Entity @Data @Table(name = &quot;USER_DETAIL&quot;) public class UserDetail &#123; @Id @GeneratedValue @Column(name = &quot;ID&quot;) private Long id; @Column(name = &quot;CREDIT&quot;) private Float credit; @Column(name = &quot;ENROLLMENT_DATE&quot;) private Date enrollmentDate; @Column(name = &quot;USER_ID&quot;) private Long userId; &#125; UserDetail中没有User类型成员变量，所以User与UserDetail的关联是单向关联，如果UserDetail中也含有一个User类型的变量，则为双向关联；（单向和双向关联只与是否包含对象有关，和是否使用注解无关。） 同时需要在User类型的变量名中增加@OneToOne(mappedBy=”userDetail”)注解，表示两者的关系由User实体去维护，如果配置了Cascade，对User的操作也会影响到UserDetail实体。 上面代码中的@OneToOne注解中，可以定义级联操作，包括级联新建、级联删除、级联更新、级联刷新。 @JoinColumn注解中的name元素为被关联对象的id，即UserDetail类的id，而referencedColumnName则为关联对象的id,即@JoinColumn所在实体类的id。 一对多一对多需要使用@JoinColumn注解和@OneToMany配置使用，如果是双向关联，则还需要在被关联的实体类的成员变量中使用@ManyToOne。 为了创建测试环境，需要新建一个UserFriend实体类，一个User可以有一个或多个UserFriend。 User实体类中需要包含一个集合类型的UserFriend成员变量： @Data @Entity @Table(name = &quot;USER&quot;) public class User &#123; ... /** * 一对多 */ @OneToMany(cascade = &#123;CascadeType.ALL&#125;,fetch = FetchType.LAZY) @JoinColumn(name = &quot;userId&quot;,referencedColumnName = &quot;id&quot;) private Set&lt;UserFriend&gt; userFriends; &#125; @OneToMany注解和@JoinColumn注解需要配合使用，@OneToMany注解中同样可以指定级联操作和加载类型。 @JoinColumn注解中，name元素为被被关联实体类中的id，而referencedColumnName元素为关联实体类中的id,即@JoinColumn所在实体类的id。 UserFriend实体类代码如下： @Entity @Data @Table(name = &quot;USER_FRIEND&quot;) public class UserFriend &#123; @Id @GeneratedValue @Column(name = &quot;ID&quot;) private Long id; private Long userId; @Column(name = &quot;FRIEND_ID&quot;) private Long friendId; &#125; 由于使用的是单向关联，UserFriend实体类没有对应的User成员变量，所以是单向关联，如果需要指定关系的维护方，需要在使用没有@JoinColumn的实体类上使用注解@OneToMany(mappedBy)。 多对多多对多和一对一、一对多不同，需要引入两者之间的关系表，关系表负责维护两者之间的关系，起到至关重要的作用，Spring Data JPA中，需要使用@ManyToMany注解和@JoinTable注解配合使用。 为了创建多对多的测试环境，需要创建一个Teacher实体类： @Entity @Data @Table(name = &quot;TEACHER&quot;) public class Teacher &#123; @Id @GeneratedValue @Column(name = &quot;ID&quot;) private Long id; @Column(name = &quot;NAME&quot;) private String name; @ManyToMany(mappedBy = &quot;teachers&quot;) private List&lt;User&gt; users; &#125; Teacher中，由于也包含User的集合，所以Teacher与User是双向关联，在Teacher中使用@ManyToMany(mappedBy)注解申明User类为双方关系的维护方，即删除User也会删除关联的Teacher和关系表中的数据，但删除Teacher不会删除User表中的数据。 User类中，需要加入@JoinTable和@ManyToMany注解： public class User&#123; ... /** * 多对多 */ @JsonIgnoreProperties(value = &#123; &quot;users&quot; &#125;) @ManyToMany(cascade = CascadeType.ALL,fetch = FetchType.LAZY) @JoinTable( name = &quot;TEACHER_USER_RELATION&quot;, joinColumns = @JoinColumn(name = &quot;UserId&quot;,referencedColumnName = &quot;id&quot;), inverseJoinColumns = @JoinColumn(name = &quot;TeacherId&quot;,referencedColumnName = &quot;id&quot;) ) private Set&lt;Teacher&gt; teachers; &#125; @JoinTable中的name需要填写中间关系表的表明 joinColumns中的name和inverseJoinColumns中的name需要填关系表TEACHER_USER_RELATION的实体的字段名如果关系表TEACHER_USER_RELATION的实体中的字段使用了@Column(name)，那么需要填写注解中指定的名字，即表字段名。referencedColumnName填写的是本实体类中的关联的字段。 使用@OrderBy进行排序在一对多或者多对多映射中，如果想要对得到的集合进行排序，可以使用@OrderBy注解，@OrderBy中只需要指定想要排序的字段以及排序的方向即可： /** * 一对多 */ @OneToMany(cascade = &#123;CascadeType.ALL&#125;,fetch = FetchType.LAZY) @JoinColumn(name = &quot;userId&quot;,referencedColumnName = &quot;id&quot;) @OrderBy(&quot;friend_id DESC&quot;) private Set&lt;UserFriend&gt; userFriends; 上面的代码中，Set中的UserFriend会使用Friend进行倒序排序。 值得注意的是，即使用Set集合也可以保证有序性，在Hibernate内部使用了自定义集合PersistentSet，此集合是有序集合。 mappedBy元素说明@OneToOne、@OneToMany、@ManyToMany中可以使用mappedBy元素定义被关联着和关联着的关系由谁去维护，即关系的操纵权在那一方，同时mappedBy不能和@JoinTable、@JoinColumn注解同时存使用。 使用@EntityGraph和@NamedEntityGraph解决N+1问题在常规的多对多和一对多查询时，会面临N+1问题：N+1问题指的是，如果一个User对应N个Friend，在查询某id的User时，会首先执行一条SQL语句查询该User，然后会执行N条SQL语句查询该User对应的N个Friend,过程中一共使用了N+1条语句，效率会非常低下，正确的做法是使用内连接和外链接，只需要一条语句。 Spring Data JPA中针对N+1问题有相应的优化，使用@EntityGraph和@NamedEntityGraph就可以解决N+1问题。 首先需要在User实体类上使用@NamedEntityGraph注解： @Data @Entity @Table(name = &quot;USER&quot;) @NamedEntityGraph( name = &quot;UserEntity&quot;, attributeNodes = &#123; @NamedAttributeNode(&quot;userDetail&quot;), @NamedAttributeNode(&quot;userFriends&quot;), @NamedAttributeNode(&quot;teachers&quot;), &#125; ) public class User &#123; ... &#125; 上面代码中，name可以随便定义，在@EntityGraph中会对其进行引用，@NamedAttributeNode中的value元素即为需要解决N+1问题的字段。 在Repository中，对需要解决N+1问题的方法上使用的@EntityGraph注解就可以了： public interface UserJpaRepository&lt;T&gt; extends JpaRepository&lt;User,Long&gt; &#123; @EntityGraph(&quot;UserEntity&quot;) List&lt;User&gt; findByNameContaining(String name); &#125; 注解中的value是@NamedEntityGraph定义的name。","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://super-aviator.github.io/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"https://super-aviator.github.io/tags/Spring-Data-JPA/"}],"author":"熊乾坤"},{"title":"Spring Data JPA进阶学习","slug":"Spring-Data-JPA深入学习","date":"2019-06-20T04:14:00.000Z","updated":"2021-03-10T05:21:30.000Z","comments":true,"path":"2019/06/20/Spring-Data-JPA深入学习/","link":"","permalink":"https://super-aviator.github.io/2019/06/20/Spring-Data-JPA%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"这几天静下心来深入学习一下Spring Data Jpa的深入知识，参考书籍为《Spring Data JPA从入门到精通》，感觉作者写的很乱，不过收获应该还是很多的。 Repository中方法的关键字Repository中的方法有很多关键字可以使用，在阅读书的时候发现了很多以前没有使用到并且没有注意到的细节问题： 小于使用LessThan关键字，大于使用GreaterThan关键字 小于等于使用LessThanEqual关键字，大于等于使用GreaterThanEqual关键字 时间的比较需要使用After和Before like关键字不会在参数前后加上%,StartingWith关键字会在参数前加%，EndingWith关键字会在参数后加%，而Containing关键字会在参数前后都加上%，一般用于模糊查询。 In关键字的参数是Collection接口 对于忽略大小写的比较，可以使用IgnoreCase关键字 数据的分页和排序查询数据时如果想要对数据进行分页，只需要在查询方法中加入Pagable对象，并返回Page或者Slice对象即可，调用时，参数使用PageRequest，并在构造函数中传入起始页以及每页显示的项目数即可。如果想要对分页的数据进行排序，可以在PageRequest构造器中传入Sort对象即可。 GeneratedValue的四种主键生成策略参考文章：GenerationType四中类型 JPA提供的四种标准用法为TABLE,SEQUENCE,IDENTITY,AUTO. TABLE：使用一个特定的数据库表格来保存主键。 SEQUENCE：根据底层数据库的序列来生成主键，条件是数据库支持序列。 IDENTITY：主键由数据库自动生成（主要是自动增长型） AUTO：主键由程序控制。 GenerationType.TABLE使用一个特定的数据库表格来保存主键,持久化引擎通过关系数据库的一张特定的表格来生成主键,这种策略的好处就是不依赖于外部环境和数据库的具体实现,在不同数据库间可以很容易的进行移植,但由于其不能充分利用数据库的特性,所以不会优先使用。该策略一般与另外一个注解一起使用@TableGenerator,@TableGenerator注解指定了生成主键的表(可以在实体类上指定也可以在主键字段或属性上指定),然后JPA将会根据注解内容自动生成一张表作为序列表(或使用现有的序列表)。如果不指定序列表,则会生成一张默认的序列表,表中的列名也是自动生成,数据库上会生成一张名为sequence的表(SEQ_NAME,SEQ_COUNT)。序列表一般只包含两个字段:第一个字段是该生成策略的名称,第二个字段是该关系表的最大序号,它会随着数据的插入逐渐累加。 @Id @Column(name=&quot;id&quot;) @GeneratedValue(strategy=GenerationType.TABLE,generator=&quot;table_gen&quot;) @TableGenerator( name = &quot;table_gen&quot;, table=&quot;fendo_generator&quot;, pkColumnName=&quot;seq_name&quot;, //指定主键的名字 pkColumnValue=&quot;fendos&quot;, //指定下次插入主键时使用默认的值 valueColumnName=&quot;seq_id&quot;, //该主键当前所生成的值，它的值将会随着每次创建累加 initialValue = 1, //初始化值 allocationSize=1 //累加值 ) public Integer getUid() &#123; return uid; &#125; GenerationType.SEQUENCE在某些数据库中,不支持主键自增长,比如Oracle,其提供了一种叫做”序列(sequence)”的机制生成主键。此时,GenerationType.SEQUENCE就可以作为主键生成策略。该策略的不足之处正好与TABLE相反,由于只有部分数据库(Oracle,PostgreSQL,DB2)支持序列对象,MYsql不支持序列,所以该策略一般不应用于其他数据库。类似的,该策略一般与另外一个注解一起使用@SequenceGenerator,@SequenceGenerator注解指定了生成主键的序列.然后JPA会根据注解内容创建一个序列(或使用一个现有的序列)。如果不指定序列,则会自动生成一个序列SEQ_GEN_SEQUENCE。 @Id @GeneratedValue(strategy = GenerationType.SEQUENCE,generator=&quot;fendo_seq&quot;) @SequenceGenerator(name=&quot;fendo_seq&quot;, sequenceName=&quot;seq_name&quot;) GenerationType.IDENTITY此种主键生成策略就是通常所说的主键自增长,数据库在插入数据时,会自动给主键赋值,比如MySQL可以在创建表时声明”auto_increment” 来指定主键自增长。该策略在大部分数据库中都提供了支持(指定方法或关键字可能不同),但还是有少数数据库不支持,所以可移植性略差。使用自增长主键生成策略是只需要声明strategy = GenerationType.IDENTITY即可。 @Id @GeneratedValue(strategy = GenerationType.IDENTITY) GenerationType.AUTO把主键生成策略交给持久化引擎(persistence engine),持久化引擎会根据数据库在以上三种主键生成策略中选择其中一种。此种主键生成策略比较常用,由于JPA默认的生成策略就是GenerationType.AUTO,所以使用此种策略时.可以显式的指定@GeneratedValue(strategy = GenerationType.AUTO)也可以直接@GeneratedValue。 @Id @GeneratedValue(strategy = GenerationType.AUTO) 各种数据库支持的类型 使用Projections查询部分字段在写代码时常常有这样的业务逻辑，就是仅仅查询实体类的部分字段，而忽略其他的字段，比如查询用户，不包括用户的密码等敏感信息。 Spring Data JPA对Projections有很好的支持，使用方式如下：对于如下的实体类： @Data @Entity public class User &#123; @Id @GeneratedValue private Long id; private String name; private String email; private String address; &#125; 如果只想查询用户的name和email字段，首先需要定义一个接口，包含想要查询的字段的getter方法： /** * @author Aviator */ @ToString public interface User &#123; String getName(); String getEmail(); &#125; 然后在Repository中，编写查询方法，方法返回的集合中包含该接口： public interface UserJpaRepository extends Repository&lt;User,Long&gt; &#123; /** * 查询所有name的用户 * @param name 字符串类型 * @return projection，查询特定字段的值,集合中的User为编写的接口。 */ List&lt;User&gt; findUserByName(String name); &#125; 这样就可以查询User实体类的name和email字段了： @RestController public class UserController &#123; @Autowired UserJpaRepository userRepository; @GetMapping(&quot;/user&quot;) public List&lt;UserDTO&gt; getAllUser()&#123; return userRepository.findUserByName(&quot;熊乾坤&quot;); &#125; &#125; 结果： [&#123;&quot;name&quot;:&quot;熊乾坤&quot;,&quot;email&quot;:&quot;2372389705@qq.com&quot;&#125;,&#123;&quot;name&quot;:&quot;熊乾坤&quot;,&quot;email&quot;:&quot;2372389705@qq.com&quot;&#125;] 除了使用接口的方式，JPA中也可以使用DTO类来实现Projections: @Getter @ToString public class UserDTO &#123; /** * 使用Projection时，字段必须为final修饰 */ private final String name, email; public UserDTO(String name, String email) &#123; this.name = name; this.email = email; &#125; &#125; 值得注意的是：如果使用DTO类的方式，类中的字段必须使用final修饰，否则会抛出没有转换器的异常，要注意一下。 使用动态Projections上面学习的Projections也支持动态的操作，在Repository定义的方法中，使用泛型，就可以达到动态的映射，可以根据判定条件查询实体类的某些字段： public interface UserJpaRepository&lt;T&gt; extends Repository&lt;User,Long&gt; &#123; /** * 使用模糊查询 * @param name 字符串类型 * @param tClass 类型信息 * @return 用户列表 */ List&lt;T&gt; findUserByName(String name,Class&lt;T&gt; tClass); &#125; 此时，如果想查询User的所有字段，则调用findUserByName方法时只需要指定tClass参数为User.class,如果只需要查询User的部分参数，则tClass参数传入UserDTO.class即可。 合理使用@Modifying注解在使用Spring Data JPA对数据库中的数据进行修改或者删除操作时，在使用@Query注解的同时，也需要使用到@Modifying注解，但是单独使用@Modifying注解时可能会因为缓存而导致一些问题。 JPA 的 Repository 提供一种非常易用的机制用于 ORM 方式处理数据，但是如果需要一次性更新一批数据的部分字段，构造所有实体并逐个修改字段再存回数据库就显得有些臃肿。在 JPA 中提供了 @Query 注解用于使用 JPQL 执行数据库操作，如果数据库操作是修改数据而非查询数据，则需要再额外使用 @Modifying 注解提示 JPA 该操作是修改操作。 当进行 find 操作时，JPA 在 EntityManager 中缓存了 find 生成的对象，当再次 find 时会直接返回该对象。于是可能会出现下面这种情况 ,用@Query 定义一个修改状态的方法 public interface EntityRepository extends JpaRepository&lt;Entity, Integer&gt; &#123; @Modifying @Query(&quot;update Entity set status = &#39;IGNORED&#39; where id = ?1&quot;) int updateStatus(int id); &#125; 先读取一个对象，再修改对象状态，再次读取对象 Optional&lt;Entity&gt; entityBefore = repository.findById(1); repository.updateStatus(1); Optional&lt;Entity&gt; entityAfter = repository.findById(1); 结果会发现 entityBefore 和 entityAfter 中的 Entity 对象 id 是相同的，中间对状态的修改并没有体现出来！当然，其原因也很明确，**@Query 跟 find 和 save 系列方法是两套不同的体系**，@Query 引起的数据库变更 EntityManager 并不能发现，更进一步说，使用其它工具或者其它框架修改数据库中的数据，也不能及时反应到 JPA 的 find 系列方法上来。 当然，只要有缓存机制就一定不可避免存在此类问题，这仅是个取舍问题而不要认为是 BUG。如果要解决 find 得到的值不是数据库中最新值的问题可以有几种方式，避免使用 @Query 是一种方式，在需要时显式清理 EntityManager 的缓存也是一种方式。Spring Data JPA 提供了另外一种方式则是 @Modifying(clearAutomatically = true)，@Modifying 的 clearAutomatically 属性为 true 时，执行完 modifying query 之后就会清理缓存，从而在下次 find 时就可以读取到数据库中的最新值。 自动清理之后还会带来一个新的问题，clear 操作清理的缓存中，还包括提交后未 flush 的数据，例如调用 save 而不是 saveAndFlush 就有可能不会立即将修改内容更新到数据库中，在 save 之后 flush 之前调用 @Modifying(clearAutomatically = true) 修饰的方法就有可能导致修改丢失。如果再要解决这个问题，还可以再加上另外一个属性 @Modifying(clearAutomatically = true, flushAutomatically = true)，**@Modifying 的 flushAutomatically 属性为 true 时，执行 modifying query 之前会先调用 flush 操作，从而避免数据丢失问题。** 在实际运行中，clear 和 flush 操作都可能需要消耗一定的时间，要根据系统实际情况可以选择使用其中的一个或两个属性，以保证系统的正确性。 参考: flushAutomatically 属性是在 https://jira.spring.io/browse/DATAJPA-806 提出并被采纳的。 参考地址： @Modifying注解详解 Entity中常用的注解实体类中有很多可以使用的注解，下面是常用的一些注解： @Basic(fetch=FetchType,optional=true) @Basic表示一个简单的属性到数据库表的字段的映射,对于没有任何标注的getXxxx()方法,默认 即为 @Basic fetch: 表示该属性的读取策略,有EAGER和LAZY两种,分别表示主支抓取和延迟加载,默认为EAGER. FetchType.LAZY：懒加载，加载一个实体时，定义懒加载的属性不会马上从数据库中加载。 FetchType.EAGER：急加载，加载一个实体时，定义急加载的属性会立即从数据库中加载。 比方User类有两个属性，name跟address，就像百度知道，登录后用户名是需要显示出来的，此属性用到的几率极大，要马上到数据库查，用急加载;而用户地址大多数情况下不需要显示出来，只有在查看用户资料是才需要显示，需要用了才查数据库，用懒加载就好了。所以，并不是一登录就把用户的所有资料都加载到对象中，于是有了这两种加载模式。 optional:表示该属性是否允许为null,默认为true @Basic(optional=false) public String getAddress() &#123; return address; &#125; @Transient@Transient表示该属性并非一个到数据库表的字段的映射，表示非持久化属性，与@Basic作用相反。JPA映射数据库的时候忽略它。如果一个属性并非数据库表的字段映射,就务必将其标示为 @Transient ,否则,ORM框架默认其注解为 @Basic @Temporal(TemporalType)@Temporal用来设置Date类型的属性映射到对应精度的字段。 @Temporal(TemporalType.DATE)映射为日期date（只有日期）。 @Temporal(TemporalType.TIME)映射为时间time（只有时间）。 @Temporal(TemporalType.TIMESTAMP)映射为日期date+time（日期+时间）。 @Lob@Lob 将属性映射成数据库支持的大对象类型，支持以下两种数据库类型的字段。 Clob（Character Large Ojects）类型是长字符串类型，java.sql.Clob、Character[]、char[]和String将被映射为Clob类 型。 Blob（Binary Large Objects）类型是字节类型，java.sql.Blob、Byte[]、byte[]和实现了Serializable接口的类型 将被映射为Blob类型。 Clob、Blob占用内存空间较大，一般配合@Basic(fetch=FetchType.LAZY)将其设置为延迟加载。 @Enumerated在数据库中创建字段时，可以创建枚举类型的字段，例如在User表中，GENDER字段为枚举类型ENUM(‘MALE’,FEMALE)。那么在Entity实体类中需要在字段上使用使用@Enumerated注解，并创建相应的枚举类： 创建Enum： public enum Gender &#123; //男性 MALE(&quot;男性&quot;), //女性 FEMALE(&quot;女性&quot;); private String value; Gender(String str)&#123; value=str; &#125; &#125; 然后在实体类中使用@Enumerated注解： @Entity @Data @Table(name = &quot;USER&quot;) public class User &#123; @Id @GeneratedValue private Long id; @Column(name = &quot;NAME&quot;) private String name; @Column(name = &quot;EMAIL&quot;) private String email; @Column(name = &quot;ADDRESS&quot;) private String address; @Enumerated(EnumType.STRING) @Column(name = &quot;GENDER&quot;) private Gender gender; &#125; 这样就可以在实体类中使用枚举类型啦。 值得注意的是，这时插入两条数据，数据库里面的值是MAIL/FMAIL，而不是“男性”/“女性”。如果我们用@Enumerated(EnumType.ORDINAL)，那么 这时数据库里面的值是0、1。但是实际工作中，不建议用数字下标，因为枚举里面的属性值是会不断新增的，如果新增一个，位置变化了就惨了。 @CreatedDate用来指定当前的时间字段的数据为数据插入时的时间。","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://super-aviator.github.io/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"https://super-aviator.github.io/tags/Spring-Data-JPA/"}],"author":"熊乾坤"},{"title":"[转载]Lombok安装与常见的问题","slug":"转载-Lombok问题解决","date":"2019-06-04T03:26:00.000Z","updated":"2021-02-23T12:59:58.000Z","comments":true,"path":"2019/06/04/转载-Lombok问题解决/","link":"","permalink":"https://super-aviator.github.io/2019/06/04/%E8%BD%AC%E8%BD%BD-Lombok%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"","text":"原文地址：lombok踩坑与思考 在实习的时候公司的代码中用到了Lombok，主要是为了简化实体类的代码量，以前这些Getter和Setter方法都是用IDEA的ctrl+insert来生成的，但是为了代码风格的一致性，以后得改用Lombok了。在网上看到一篇关于Lombok踩坑的文章，抄袭一下。 Lombok安装想要使用Lombok，首先需要在maven中加入Lombok的依赖： &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 然后需要在IDEA中安装Lombok的插件，在IDEA中点击File-&gt;Settings-&gt;Plugins，然后所有Lombok插件进行安装并重启IDEA， 最后，需要打开IDEA的Annotation Processors，在IDEA中选择File-&gt;Settings-&gt;Build,Execution,deployment-&gt;Compiler-&gt;Annotation Processors，然后勾选Enable annotation processing选项就OK啦。接下来就可以使用Lombok啦。 一些杂七杂八的问题以下这些是最初我不喜欢lombok的原因。 额外的环境配置作为IDE插件+jar包，需要对IDE进行一系列的配置。目前在idea中配置还算简单，几年前在eclipse下也配置过，会复杂不少。 传染性一般来说，对外打的jar包最好尽可能地减少三方包依赖，这样可以加快编译速度，也能减少版本冲突。一旦在resource包里用了lombok，别人想看源码也不得不装插件。 而这种不在对外jar包中使用lombok仅仅是约定俗成，当某一天lombok第一次被引入这个jar包时，新的感染者无法避免。 降低代码可读性定位方法调用时，对于自动生成的代码，getter/setter还好说，找到成员变量后find usages，再根据上下文区分是哪种；equals()这种，想找就只能写段测试代码再去find usages了。 目前主流ide基本都支持自动生成getter/setter代码，和lombok注解相比不过一次键入还是一次快捷键的区别，实际减轻的工作量十分微小。 @EqualsAndHashCode和equals()原理当这个注解设置callSuper=true时，会调用父类的equlas()方法，对应编译后class文件代码片段如下： public boolean equals(Object o) &#123; if (o == this) &#123; return true; &#125; else if (!(o instanceof BaseVO)) &#123; return false; &#125; else &#123; BaseVO other = (BaseVO)o; if (!other.canEqual(this)) &#123; return false; &#125; else if (!super.equals(o)) &#123; return false; &#125; else &#123; // 各项属性比较 &#125; &#125; &#125; 如果一个类的父类是Object（java中默认没有继承关系的类父类都是Object），那么这里会调用Object的equals()方法，如下 public boolean equals(Object obj) &#123; return (this == obj); &#125; 问题对于父类是Object且使用了@EqualsAndHashCode(callSuper = true) 注解的类，这个类由lombok生成的equals()方法只有在两个对象是同一个对象时，才会返回true，否则总为false，无论它们的属性是否相同。这个行为在大部分时间是不符合预期的，equals()失去了其意义。即使我们期望equals()是这样工作的，那么其余的属性比较代码便是累赘，会大幅度降低代码的分支覆盖率。以一个近6000行代码的业务系统举例，是否修复该问题并编写对应测试用例，可以使整体的jacoco分支覆盖率提高10%~15%。 相反地，由于这个注解在jacoco下只算一行代码，未覆盖行数倒不会太多。 解决有几种解决方法可以参考： 不使用该注解。大部分pojo我们是不会调用equals进行比较的，实际用到时再重写即可。 去掉callSuper = true。如果父类是Object，推荐使用。 重写父类的equals()方法，确保父类不会调用或使用类似实现的Ojbect的equals()。 其他@data注解包含@EqualsAndHashCode注解，由于不调用父类equals()，避免了Object.equals()的坑，但可能带来另一个坑。详见@data章节。 @data从一个坑出来掉到另一个大坑上文提到@EqualsAndHashCode(callSuper = true) 注解的坑，那么 @data 是否可以避免呢？很不幸的是，这里也有个坑。由于 @data 实际上就是用的 @EqualsAndHashCode，没有调用父类的equals()，当我们需要比较父类属性时，是无法比较的。示例如下： @Data public class ABO &#123; private int a; &#125; @Data public class BBO extends ABO &#123; private int b; public static void main(String[] args) &#123; BBO bbo1 = new BBO(); BBO bbo2 = new BBO(); bbo1.setA(1); bbo2.setA(2); bbo1.setB(1); bbo2.setB(1); System.out.print(bbo1.equals(bbo2)); // true &#125; &#125; 很显然，两个子类忽略了父类属性比较。这并不是因为父类的属性对于子类是不可见——即使把父类private属性改成protected，结果也是一样——而是因为lombok自动生成的equals()只比较子类特有的属性。 解决方法 用了 @data 就不要有继承关系，类似kotlin的做法，具体探讨见下一节 自己重写equals()，lombok不会对显式重写的方法进行生成 显式使用@EqualsAndHashCode(callSuper = true)。lombok会以显式指定的为准。 关于@data和data在了解了 @data 的行为后，会发现它和kotlin语言中的data修饰符有点像：都会自动生成一些方法，并且在继承上也有问题——前者一旦有继承关系就会踩坑，而后者修饰的类是final的，不允许继承。kotlin为什么要这样做，二者有没有什么联系呢？在一篇流传较广的文章(抛弃 Java 改用 Kotlin 的六个月后，我后悔了(译文))中，对于data修饰符，提到： Kotlin 对 equals()、hashCode()、toString() 以及 copy() 有很好的实现。在实现简单的DTO 时它非常有用。但请记住，数据类带有严重的局限性。你无法扩展数据类或者将其抽象化，所以你可能不会在核心模型中使用它们。 这个限制不是 Kotlin 的错。在 equals() 没有违反 Liskov 原则的情况下，没有办法产生正确的基于值的数据。 对于Liskov（里氏替换）原则，可以简单概括为： 一个对象在其出现的任何地方，都可以用子类实例做替换，并且不会导致程序的错误。换句话说，当子类可以在任意地方替换基类且软件功能不受影响时，这种继承关系的建模才是合理的。 根据上一章的讨论，equals()的实现实际上是受业务场景影响的，无论是否使用父类的属性做比较都是有可能的。但是kotlin无法决定equals()默认的行为，不使用父类属性就会违反了这个原则，使用父类属性有可能落入调用Object.equals()的陷阱，进入了两难的境地。 kotlin的开发者回避了这个问题，不使用父类属性并且禁止继承即可。只是kotlin的使用者就会发现自己定义的data对象没法继承，不得不删掉这个关键字手写其对应的方法。 回过头来再看 @data ，它并没有避免这些坑，只是把更多的选择权交给开发者决定，是另一种做法。 后记其他lombok注解实际使用较少，整体阅读了 官方文档暂时没有发现其他问题，遇到以后继续更新。实际上官方文档中也提到了equals()的坑。","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Lombok","slug":"Lombok","permalink":"https://super-aviator.github.io/tags/Lombok/"}],"author":"熊乾坤"},{"title":"SpringBoot常用的配置项","slug":"SpringBoot常用的配置项","date":"2019-06-02T03:49:00.000Z","updated":"2021-02-23T12:59:58.000Z","comments":true,"path":"2019/06/02/SpringBoot常用的配置项/","link":"","permalink":"https://super-aviator.github.io/2019/06/02/SpringBoot%E5%B8%B8%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9/","excerpt":"","text":"SpringBoot减少了Spring应用的大量的配置，但是开发者可能还需要对项目的细节进行微调，以满足自己特殊的需求，而这些配置项都应该在项目自带的配置文件application.properties中进行配置，如下是一些经常会用到的配置项，以后忘记了可以到这里看一看： DataSourcespring: datasource: url:jdbc: mysql://127.0.0.1:3306/yxb?useSSL=false&amp;useUnicode=true &amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai driver: com.mysql.cj.jdbc.Driver #一般不需要指定 username: root password: 123456 设置项目的启动端口和IP#启动端口和IP server: port: 8080 address: 192.168.1.10 #在部署到服务器时不需要此配置 Spring Data JPAspring: jpa: show-sql: true #打印sql语句 properties: hibernate: enable_lazy_load_no_trans: true #解决缺少session的问题 format_sql: true #格式化sql语句 ddl_auto: true #实体类可以更改数据库结构，在@Table注解中加上catalog属性，值为数据库名。 Bannerspring: banner: location: banner.txt #指定banner.txt的位置 日志logging: level: root: info #定义日志的打印等级","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://super-aviator.github.io/tags/SpringBoot/"}],"author":"熊乾坤"},{"title":"SpringBoot学习笔记","slug":"SpringBoot学习笔记","date":"2019-06-02T02:37:00.000Z","updated":"2021-02-23T12:59:58.000Z","comments":true,"path":"2019/06/02/SpringBoot学习笔记/","link":"","permalink":"https://super-aviator.github.io/2019/06/02/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"参考文章：SpringBoot中文文档SpringBoot实战@ConfigurationProperties注解 现在公司新项目使用的是SpringBoot，所以趁现在有时间学习一下SpringBoot,为以后的开发做好准备。 spring-boot-maven-plugin插件SpringBoot项目中会自带一个插件：org.springframework.boot：spring-boot-maven-plugin，这个插件有如下几个目标可以使用： spring-boot:build-info spring-boot:help 运行该目标能够显示其他目标的说明文字 spring-boot:repackage spring-boot:run 启动你的项目 spring-boot:start spring-boot:stop Spring Boot Maven plugin的最主要goal就是repackage，其在Maven的package生命周期阶段，能够将mvn package生成的软件包，再次打包为可执行的软件包，并将mvn package生成的软件包重命名为*.original。使用命令mvn package spring-boot:repackage将生成一个可以直接执行的jar包，使用java -jar执行，同时原生的jar使用.original后缀保存。 指定SpringBoot启动时运行的类你还可以指定要执行的类，如果不指定的话，Spring会找有这个【public static void main(String[] args)】方法的类，当做可执行的类。 如果你想指定的话，可以用下面两个方法： 如果你的POM是继承spring-boot-starter-parent的话，只需要下面的指定就行。 &lt;properties&gt; &lt;!-- The main class to start by executing java -jar --&gt; &lt;start-class&gt;com.mycorp.starter.HelloWorldApplication&lt;/start-class&gt; &lt;/properties&gt; 如果你的POM不是继承spring-boot-starter-parent的话，需要下面的指定。 &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;$&#123;start-class&#125;&lt;/mainClass&gt; &lt;layout&gt;ZIP&lt;/layout&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; @SpringBootApplication注解@SpringBootApplication开启了Spring的组件扫描和Spring Boot的自动配置功能。实际上，@SpringBootApplication将三个有用的注解组合在了一起。 Spring的@Configuration：标明该类使用Spring基于Java的配置。虽然本书不会写太多 配置，但我们会更倾向于使用基于Java而不是XML的配置。 Spring的@ComponentScan：启用组件扫描，这样你写的Web控制器类和其他组件才能被 自动发现并注册为Spring应用程序上下文里的Bean。本章稍后会写一个简单的Spring MVC 控制器，使用@Controller进行注解，这样组件扫描才能找到它。 Spring Boot的@EnableAutoConfiguration：这个不起眼的小注解也可以称为 @Abracadabra，就是这一行配置开启了Spring Boot自动配置的魔力，让你不用再写成篇的配置了。 在Spring Boot的早期版本中，你需要在ReadingListApplication类上同时标上这三个注解，但从Spring Boot 1.2.0开始，有@SpringBootApplication就行了。 使用@ConfigurationProperties注解在application.yml中，假如有如下配置： #自定义配置 myconfig: config1: this is myconfig 如果想将myconfig下的配置包装成一个对象，并提供getter和setter方法进行读取和写入，应该如何实现呢？这就需要使用@ConfigurationProperties注解去实现。使用这个注解主要由以下步骤： 为项目于添加spring-boot-configuration-processor依赖 创建一个Bean,并定义myconfig下的所有属性，并提供getter或者setter方法。 在需要使用到的地方使用getter和setter方法进行读取和写入。 要使用ConfigurationProperties注解，首先需要为项目添加所需的依赖，在pom文件中添加： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 然后创建bean: package com.xqk.yxb.dto; import lombok.Data; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; /** * @author Aviator */ @Data @Component @ConfigurationProperties(prefix = &quot;myconfig&quot;) public class MyConfig &#123; private String config1; &#125; bean中的@ConfigurationProperties注解定义了属性在配置文件中的前缀为myconfig，并定义了myconfig下的属性config1。并提供了getter和setter方法。 需要使用自定义的属性时，只需要注入我们自定义的bean，就可以使用： package com.xqk.yxb.controller; import com.xqk.yxb.dto.HTTPResponse; import com.xqk.yxb.dto.MyConfig; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; import java.util.logging.Level; import java.util.logging.Logger; /** * @author Aviator */ @RestController public class HomeController &#123; @Autowired private MyConfig myConfig; private Logger log=Logger.getLogger(&quot;HomeController&quot;); @RequestMapping(value = &quot;/index&quot;,method = RequestMethod.GET) public HTTPResponse home()&#123; log.log(Level.INFO,myConfig.getConfig1()); myConfig.setConfig1(&quot;项目搭建成功&quot;); log.log(Level.INFO,myConfig.getConfig1()); return new HTTPResponse(1,&quot;项目搭建成功&quot;); &#125; &#125; 也可以在@bean注解的方法上使用@ConfigurationProperties注解，这样就不需要在实体类上使用@Component和@Configuration注解了,在启动类中定义bean： package com.dxz.property4; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; @SpringBootApplication public class TestProperty4 &#123; @Bean @ConfigurationProperties(locations = &quot;classpath:mail.properties&quot;,prefix = &quot;mail&quot;) public MailProperties mailProperties()&#123; MailProperties mp = new MailProperties(); System.out.println(&quot;zheli &quot; + mp); return mp; &#125; public static void main(String[] args) &#123; //SpringApplication.run(TestProperty1.class, args); new SpringApplicationBuilder(TestProperty4.class).web(true).run(args); &#125; &#125; 开启配置属性 从技术上来说，@ConfigurationProperties注解不会生效，除非先向Spring配置类添加@EnableConfigurationProperties注解。但通常无需这么 做，因为Spring Boot自动配置后面的全部配置类都已经加上了@EnableConfigurationProperties注解。因此，除非你完全不使用自动配置（那怎么可能？），否则就无需显式地添加@EnableConfigurationProperties。 使用 ApplicationRunner 或 CommandLineRunner如果您需要在 SpringApplication 启动时运行一些代码，可以实现 ApplicationRunner 或者 CommandLineRunner 接口。这两个接口的工作方式是一样的，都提供了一个单独的 run 方法，它将在 SpringApplication.run(​…) 完成之前调用。 CommandLineRunner 接口提供了访问应用程序字符串数组形式参数的方法，而 ApplicationRunner 则使用了上述的 ApplicationArguments 接口。以下示例展示 CommandLineRunner 和 run 方法的使用： import org.springframework.boot.*; import org.springframework.stereotype.*; @Component public class MyBean implements CommandLineRunner &#123; public void run(String... args) &#123; // Do something... &#125; &#125; 如果您定义了多个 CommandLineRunner 或者 ApplicationRunner bean，则必须指定调用顺序，您可以实现 org.springframework.core.Ordered 接口，也可以使用 org.springframework.core.annotation.Order 注解解决顺序问题。","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://super-aviator.github.io/tags/SpringBoot/"}],"author":"熊乾坤"},{"title":"Maven知识点总结","slug":"Maven实战学习笔记","date":"2019-05-21T03:51:00.000Z","updated":"2021-02-23T13:00:02.000Z","comments":true,"path":"2019/05/21/Maven实战学习笔记/","link":"","permalink":"https://super-aviator.github.io/2019/05/21/Maven%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"参考地址：并发编程网-maven文档翻译 实习结束后从上海到武汉已经休息了大半个月了，是时候学习点东西了，首先想学习一下关于Maven的知识，回想起来貌似还没有系统的学过Maven，平时最多的也就用到过Maven的依赖管理，公司项目的POM文件很多标签都不知道什么意思,所以系统学习一下Maven还是很有必要的，网上找了一本扫描版的Maven实战的电子书凑活看一下。等Maven学完之后再将公司实习的时候每周总结的知识点学习一遍，岂不美哉？so,开始吧。 Maven的安装与配置用户下载Maven的安装包，然后解压到指定目录，配置M2_HOME的环境变量，并将%M2_HOME%/bin添加到path环境变量中。同时如果需要修改本地仓库路径，可以在 Maven 目录下的 conf/setting.xml 文件中，通过 来指定本地仓库路径，默认路径为~/.m2/repository。 在首次运行mvn命令行时，可能会抛出No compiler is provided in this environment. Perhaps you are running on a JRE rather than a JDK?错误，这是因为mvn打包需要jdk的环境，而它自己没有找到jdk的配置目录，所以就报错了，首先应该检查自己的jdk环境变量是否有问题，如果没问题，就需要修改一下bin目录中的mvn.bat或者mvn.sh文件的代码：在mvn.bat文件中，手动设置JAVA_HOME的目录，就可以解决这个问题： [问题]idea maven 有jar包，就是报错整个项目找不到jaridea中的mvn很容易出现各种各样的问题，有时候明明mvn中有jar包，但是编译的时候还是提示却少jar包，这有可能是idea的解析有问题，删除.iml文件，让他重新生成，试了几次之后就成功了。 pom.xml中最基本的标签&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt; &lt;name&gt;项目名称&lt;/name&gt; &lt;description&gt;Parent pom providing dependency and plugin management for applications built with Maven&lt;/description&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;/project&gt; modelVersion 指定xml的版本，在maven3和2中只能为4.0.0 groupId和artifactId是maven项目的坐标 version 工程的版本 packaging 项目打包的格式，可以是jar、war、pom，当项目为聚合或者继承项目时，必须要将其申明为pom name 项目的输出名称，在mvn命令时会显示该名称 description 项目的简要描述 依赖引入（dependencies）&lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- 依赖的group ID --&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;!-- 依赖的artifact ID --&gt; &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt; &lt;!-- 依赖的版本号。 在 Maven 2 里，也可以配置成版本号的范围。 --&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展 名或分类器。类型经常和使用的打包方式对应，尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。 如果设置extensions为 true，就可以在plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt; &lt;type&gt;jar&lt;/type&gt; &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如， 如果你想要构建两个单独的构件成JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生 成两个单独的JAR构件。 --&gt; &lt;classifier&gt;&lt;/classifier&gt; &lt;!-- 依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- 仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件 系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt; &lt;systemPath&gt;&lt;/systemPath&gt; &lt;!-- 当计算传递依赖时，从依赖构件列表里，列出被排除的依赖构件集。即告诉 Maven 你只依赖指定的项目，不依赖项目的 依赖。此元素主要用于解决版本冲突问题 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;!-- 可选依赖，如果你在项目 B 中把 C 依赖声明为可选，你就需要在依赖于 B 的项目（例如项目 A）中显式的引用对 C 的依赖。 可选依赖阻断依赖的传递性。 --&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 仓库配置&lt;!-- 发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!-- 包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!-- 如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!-- true 或者 false 表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled&gt;&lt;enabled&gt; &lt;!-- 该元素指定更新发生的频率。Maven 会比较本地 POM 和远程 POM 的时间戳。 这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy&gt;&lt;/updatePolicy&gt; &lt;!-- 当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;!-- 如何处理远程仓库里快照版本的下载。有了 releases 和 snapshots 这两组配置，POM 就可以在每个单独的仓库中， 为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。 --&gt; &lt;snapshots&gt; &lt;enabled&gt;&lt;enabled&gt; &lt;updatePolicy&gt;&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;!-- 远程仓库唯一标识符。可以用来匹配在 settings.xml 文件里配置的远程仓库 --&gt; &lt;id&gt;banseon-repository-proxy&lt;/id&gt; &lt;!-- 远程仓库名称 --&gt; &lt;name&gt;banseon-repository-proxy&lt;/name&gt; &lt;!-- 远程仓库 URL，按 protocol://hostname/path 形式 --&gt; &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt; &lt;!-- 用于定位和排序构件的仓库布局类型-可以是 default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认 的布局；然而，Maven 1.x 有一种不同的布局。我们可以使用该元素指定布局是 default（默认）还是 legacy（遗留）。 --&gt; &lt;layout&gt; default &lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; 项目的聚合（Aggregator）在实习的时候，发现公司的项目不是单单的一个模块，而是由四个小模块组合而成，最后所有的模块由一个总的pom文件进行管理，当时看的一脸懵逼，其实这就是使用的maven的工程聚合的功能，具体的目录结构如下： | |\\ | module1 | \\ | pom.xml |\\ | module2 | \\ | pom.xml |\\ | module3 | \\ | pom.xml |\\pom.xml 在项目中有一个工程仅仅用来聚合其他的工程，所以该maven工程没有常规的src等目录，只有一个pom.xml文件，当对聚合工程执行maven命令时，会对所有聚合的工程都执行该命令，起到项目总体管理的目的。 工程聚合和工程继承很相似，但不是从子模块指定父POM，而是从父POM指定子模块。这样做的话，父工程就知道子模块的存在了，而且如果Maven命令从父工程调用，在子模块中也能顺利执行。工程聚合要求如下做法： 将父POM的packageing属性设为”pom” 在父POM中指定模块的目录(子POM) 在聚合项目的pom.xml中，具体的示例如下： &lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;项目描述&lt;/name&gt; &lt;modules&gt; &lt;module&gt;module1&lt;/module&gt; &lt;module&gt;../module2&lt;/module&gt; &lt;!--标签的数据为相对路径，module2与聚合项目为平行目录--&gt; &lt;/modules&gt; &lt;/project&gt; modules标签指定一个或多个子模块的文件夹的相对路径。这样，如果在顶级目录执行的mvn命令，那么在子模块中也会被执行相同的命令。 项目的继承（Extend）maven项目中，如果多个子模块中都引用了相同的依赖，势必会有许许多多的重复性的代码，而且如果每个模块申明的依赖版本不一样，那么就会导致许多奇怪的问题，maven中一个解决方法是将公共的依赖申明到父类的pom中，如果需要则从父类的pom文件中引用。 想要使用到工程的继承，只需要在子工程的pom文件中使用parent标签申明父类的pom就可以引用到父类的pom文件,具体步骤如下所示： 在所有子POM中指定它们的父POM。 将父POM的packaging元素的值设为”pom”。 在父POM中指定子模块(子POM)的目录。 在子类的pom中需要如下配置： &lt;project&gt; &lt;parent&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt; &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;my-module&lt;/artifactId&gt; &lt;/project&gt; &lt;dependencies&gt; &lt;dependency&gt; ... &lt;/dependency&gt; &lt;/dependencies&gt; relativePath指定了父类pom的相对路径，其默认的路径为../pom.xml，所以如果是默认路径则不需要指定relativePath标签。 如上面所看到的的，如果需要指定子模块的version和父模块的version相同，则只需要在子模块的pom文件中，去除本项目的groupId和version即可，这样子模块的version就继承了父模块的version。 上述pom文件中申明的依赖和插件都会被所有子模块所继承，这会导致不需要该依赖的模块也会继承这些依赖和插件。为了子模块更灵活的继承父类的模块和依赖，需要使用更灵活的方法。 使用dependencyManagement和pluginManagement使用dependencyManagement和pluginManagement标签包含的依赖和plugin不会被主动的继承，如果子pom文件中显示的申明了和父类pom中相同坐标的依赖或者插件，该依赖和插件才会被继承到子pom中。具体用法如下所示： &lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;项目描述&lt;/name&gt; &lt;modules&gt; &lt;module&gt;module1&lt;/module&gt; &lt;module&gt;../module2&lt;/module&gt; &lt;!--标签的数据为相对路径，module2与聚合项目为平行目录--&gt; &lt;/modules&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot&lt;/artifactId&gt; &lt;version&gt;2.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-test&lt;/artifactId&gt; &lt;version&gt;2.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-test-autoconfigure&lt;/artifactId&gt; &lt;version&gt;2.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;kotlin.version&#125;&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;compile&lt;/id&gt; &lt;phase&gt;compile&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;test-compile&lt;/id&gt; &lt;phase&gt;test-compile&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;test-compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;jvmTarget&gt;$&#123;java.version&#125;&lt;/jvmTarget&gt; &lt;javaParameters&gt;true&lt;/javaParameters&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/pluginManagement&gt; &lt;/build&gt; &lt;/project&gt; 在子pom中只需要声明父类相同坐标的依赖，不需要声明版本，就能继承父类pom的依赖和插件，而那些在子pom文件中未申明的依赖和插件则不会被继承： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; maven反应堆构建顺序反应堆指的是maven中所有模块构成的一个体系，反应堆的构建顺序如下： 聚合模块-&gt;父类模块-&gt;子模块1-&gt;子模块2-&gt;... maven中的变量Maven鼓励的做法是不要做重复的工作(don’t repeat yourself)。但总有在不同的地方使用相同属性的情况。为了确保属性值指定一次，Maven允许你在POM使用你自己的变量或者预先定义的变量。 maven中有两种变量，一种为用户自定义类型的变量，一种是工程的变量，包含了整个工程的详细信息。 自定义变量在pom文件中，使用properties标签可以自定义一个或者多个属性 &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; 在项目中，可以使用$&#123;java.version&#125;来引用自定义的属性。 &lt;plugin&gt; &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;kotlin.version&#125;&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;compile&lt;/id&gt; &lt;phase&gt;compile&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;test-compile&lt;/id&gt; &lt;phase&gt;test-compile&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;test-compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;jvmTarget&gt;$&#123;java.version&#125;&lt;/jvmTarget&gt;&lt;!--引用自定义属性--&gt; &lt;javaParameters&gt;true&lt;/javaParameters&gt; &lt;/configuration&gt; &lt;/plugin&gt; 要注意的是这些变量在继承之后才会被处理。这意味着如果一个父工程使用了一个变量，它们在子工程中的定义与在父工程中的定义会不一样，是最后使用的那个。即，从父pom中继承的属性会被自定义的属性覆盖 工程变量一个Model的任何字段都是一个单独的可以做为变量引用的值元素。例如，$&#123;project.groupId&#125;, $&#123;project.version&#125;,$&#123;project.build.sourceDirectory&#125;等等。参考POM reference 列举的全部属性。这些变量都用”project”前缀来引用。你可以看看pom references. 作为前缀，或者完全省略前缀 – 这些形式现在已经废弃不再使用了。 特殊变量 变量 解释 project.basedir 当前工程所在的目录 project.baseUri 当前工程所在的目录，表示为一个URI，Maven 2.1.0之后 maven.build.timestamp 时间戳，表示开始构建的时间，Maven 2.1.0-M1之后","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://super-aviator.github.io/tags/Maven/"}],"author":"熊乾坤"},{"title":"CentOS系统下安装rpm格式的MySQL","slug":"CentOS系统下安装rpm包的MySQL","date":"2019-04-13T01:45:00.000Z","updated":"2021-02-23T13:00:10.000Z","comments":true,"path":"2019/04/13/CentOS系统下安装rpm包的MySQL/","link":"","permalink":"https://super-aviator.github.io/2019/04/13/CentOS%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%89%E8%A3%85rpm%E5%8C%85%E7%9A%84MySQL/","excerpt":"","text":"通过官网我们可以通过各种方式安装MySQL,但是如果通过官方下载的镜像安装时，由于网络的问题，会链接不到镜像，所以可以通过下载rpm格式的安装包，然后通过rpm命令去安装MySQL。 下载rpm的安装包可以通过官网去下载RedHat对应版本的tar压缩包，需要注意的是如果CentOS上没有MySQL组件或者版本不对，则需要下载RPM Bundle包，里面有MySQL的所有组件。 解压tar文件下载之后会有一个.tar格式的压缩包，使用tar -xvf 压缩包名去解压，需要注意是**.tar格式和.tar.gz格式解压和压缩区别是不带-z参数。解压之后会得到以下文件（第一个文件不是的，截图手抖多截了一个QAQ）：然后依次安装common-&gt;libs-&gt;client-&gt;server**，安装顺序不能错哦。 使用rpm命令安装MySQL组件(参考文章)rpm安装命令： rpm -i example.rpm #安装 example.rpm 包； rpm -iv example.rpm #安装 example.rpm 包并在安装过程中显示正在安装的文件信息； rpm -ivh example.rpm #安装 example.rpm 包并在安装过程中显示正在安装的文件信息及安装进度 rpm卸载命令： # rpm -e example 如果出现： error: Failed dependencies: mysql-community-client(x86-64) &gt;= 5.7.9 is needed by mysql-community-server-5.7.25-1.el7.x86_64 mysql-community-common(x86-64) = 5.7.25-1.el7 is needed by mysql-community-server-5.7.25-1.el7.x86_64 mariadb-server is obsoleted by mysql-community-server-5.7.25-1.el7.x86_64 则表明组件的安装顺序有问题。 如果出现： Preparing... ################################# [100%] file /usr/share/mysql/czech/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64 file /usr/share/mysql/danish/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64 file /usr/share/mysql/dutch/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64 file /usr/share/mysql/english/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64 file /usr/share/mysql/estonian/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64 file /usr/share/mysql/french/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64 file /usr/share/mysql/german/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64 file /usr/share/mysql/greek/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64 file /usr/share/mysql/hungarian/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64 file /usr/share/mysql/italian/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64 file /usr/share/mysql/japanese/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64 file /usr/share/mysql/korean/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64 这是因为安装的rpm包和系统已有的组件冲突了，可以通过如下方式删除系统中的组件：首先使用yum查看系统的MySQL组件： yum list installed | grep &quot;mysql&quot; 然后如果已经安装的MySQL组件和想要安装的组件有冲突，就删除它们吧： yum -y remove 想要删除的组件名 删除之后再使用rpm安装就ok了。 启动并设置密码（参考文章）启动MySQL并查看运行状态: sudo service mysqld start;#启动 sudo service mysqld status;#查看是否运行 因为安装时会给root设置一个默认密码，可以通过如下方式查看保存在log文件中的密码： sudo grep &#39;temporary password&#39; /var/log/mysqld.log 然后使用这个密码登陆MySQL： mysql -uroot -p 修改密码可以使用如下命令： ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;NewPassword&#39;;#方式一 SET password=password(&#39;NewPassword&#39;); 设置密码时，如果密码太简单，会因为MySQL密码的安全策略而报错,可以通过如下命令修改安全策略： SHOW VARIABLES LIKE &#39;validate_password%&#39;; #查看系统安全策略 set global validate_password_policy=LOW; #设置密码的验证强度等级为低，就只会检查密码长度 set global validate_password_length=6; #设置密码长度为6，默认长度为8 MySQL安全各策略字段含义如下： validate_password_length 固定密码的总长度； validate_password_dictionary_file 指定密码验证的文件路径； validate_password_mixed_case_count 整个密码中至少要包含大/小写字母的总个数； validate_password_number_count 整个密码中至少要包含阿拉伯数字的个数； validate_password_policy 指定密码的强度验证等级，默认为 MEDIUM； validate_password_special_char_count 整个密码中至少要包含特殊字符的个数； 关于 validate_password_policy 的取值： 0/LOW：只验证长度； 1/MEDIUM：验证长度、数字、大小写、特殊字符； 2/STRONG：验证长度、数字、大小写、特殊字符、字典文件；","categories":[{"name":"Database","slug":"Database","permalink":"https://super-aviator.github.io/categories/Database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://super-aviator.github.io/tags/MySQL/"}],"author":"熊乾坤"},{"title":"Sping Data JPA入门学习","slug":"Sping-Data-JPA入门介绍","date":"2019-03-27T11:23:00.000Z","updated":"2021-02-23T13:00:10.000Z","comments":true,"path":"2019/03/27/Sping-Data-JPA入门介绍/","link":"","permalink":"https://super-aviator.github.io/2019/03/27/Sping-Data-JPA%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"参考文章： Spring Data JPA的官方文档 IMB Develop 博客 CSDN博客 目前的公司的项目需要用到Spring Data JPA，记得刚开始看的时候感觉一脸懵逼，后来稍微看懂了以后感觉项目中如果业务逻辑比较简单的话，使用JPA比Mybatis更省事省力，它不需要使用JDBC中的那套麻烦的API，甚至也不需要写Mybatis那样的映射，定义好接口就可以直接用，感觉非常神奇，好好学习一下，今天下雨，就不加班了吧。 2019.3.28，我配这个花了差不多两天的时间，各种jar包不兼容，缺这里少哪里，我都感觉快得抑郁症了，真滴痛苦，好在最后好点了，非常感谢参考的文章的博主以及《Spring In Action》的作者，给了我黑暗的人生一点阳光。 最后的图片是很久以前在豆瓣看的一只飞机耳的猫，有点阔爱。 配置数据源对数据库的一切操作的第一步是数据源（DataSource），学习Mybatis的时候应也是得先配置数据源，Spirng中有三种数据源： 通过JDBC驱动程序定义的数据源 JNDI查找的数据源（测试环境推荐） 基于连接池的数据源（生产环境推荐） 在配置数据源之前，需要添加MySQL驱动的jar: &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; jar包的版本很重要，有时候版本不兼容是很麻烦的。 配置JDBC驱动程序定义的数据源不支持池化的链接，推荐开发时使用。 配置JNDI数据源可以在应用之外对数据源进行控制。 配置连接池的数据源重点记录一下基于连接池的数据源，生产环境推荐使用，性能更好。连接池有一下三种实现方式： Apache Commons DBCP c3p0 BoneCP 记录一下第一种配置DataSource的方式，其他的方式类似，首先导入需要的jar包： &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; 然后通过xml文件配置的方式： &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/spring_data_jpa? characterEncoding=utf8&amp;amp;userSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;property name=&quot;initialSize&quot; value=&quot;10&quot;/&gt; &lt;/bean&gt; 或者可以通过注解的方式获得一个bean： @Bean public DataSource dataSource()&#123; BasicDataSource dataSource=new BasicDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://127.0.0.1:3306/spring_data_jpa? characterEncoding=utf8&amp;amp;userSSL=false&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;123456&quot;); &#125; 也可以在.properties后缀的文件中写入配置项，然后使用$&#123;配置项名称&#125;的方式在xml文件中引用配置项，如下是在jdbcConfiguration.properties文件中定义jdbc配置项： jdbcConfiguration.properties jdbc.driverClassName=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/springdata?useSSL=false&amp;characterEncoding=utf-8 jdbc.username=root jdbc.password=123456 这里需要注意的是，在properties文件中&amp;不需要转译成&amp;amp;，否则所有中文会变成???，而在xml文件中配置时则需要转译成&amp;amp; 对DataSource进行测试： import org.apache.commons.dbcp.BasicDataSource; import org.junit.jupiter.api.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.Bean; import org.springframework.context.support.ClassPathXmlApplicationContext; import javax.sql.DataSource; import java.sql.Connection; import java.sql.SQLException; public class DataSourceTest &#123; private ApplicationContext context; private Connection con; @Test public void testDataSource() &#123; context = new ClassPathXmlApplicationContext(&quot;WEB-INF/applicationContext.xml&quot;); DataSource dataSource = context.getBean(DataSource.class); try &#123; con = dataSource.getConnection(); System.out.println(con); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (con != null) con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; output: jdbc:mysql://127.0.0.1:3306/spring_data_jpa?characterEncoding=utf8&amp;userSSL=false ,UserName=root@localhost, MySQL-AB JDBC Driver 配置实体管理器（EntityManager）实体管理器是负责管理Entity的对象。对Entity的操作包括添加、删除、修改和查询，都是通过实体管理器来实现的。使用JPA的第一个步骤就是配置一下EntityManager，而EntityManager都是通过EntityManagerFactory得到的，JPA定义了两种类型的实体管理器： 应用程序类型管理器适用于不是运行在JavaEE容器中的独立应用程序，用户需要对其进行打开、关闭、事物处理等控制，配置比较繁琐。由LocalEntityManagerFactoryBean生成对应的EntityManager。 容器类型管理器由JavaEE负责创建和管理，适合JaveEE容器，配置比应用程序管理器简单很多。由LocalContinerManagerFactoryBean生成对应的EntityManager。 两种配置方式没有什么大的区别，Spring都会负责管理两种EntityManager。如何配置两种EntityManager对Spring应用程序来说是透明的，你只需要把注意力放在如何处理业务逻辑上，数据访问的细节被隐藏起来了。 JpaVenderAdapter类是JPA的具体实现类，有四种JPA实现厂商： EclipseLinkJpaVenderAdapter HibernateJpaVneterAdapter OpenJpaVneterAdapter TopLinkJpaVneterAdapter 在applicatinContext.xml文件中进行配置： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;&gt; &lt;!--引入jdbc配置文件--&gt; &lt;context:property-placeholder location=&quot;jdbcConfiguration.properties&quot;/&gt; &lt;!--使用jpa命名空间开启Repository接口自动扫描--&gt; &lt;jpa:repositories base-package=&quot;com.spring.model&quot;/&gt; &lt;!--配置数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; &gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/bean&gt; &lt;!--配置Jpa实现供应商--&gt; &lt;bean id=&quot;jpaVendorAdapter&quot; class=&quot;org.springframework.orm.jpa.vendor .HibernateJpaVendorAdapter&quot;&gt; &lt;property name=&quot;database&quot; value=&quot;MYSQL&quot; /&gt; &lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot; /&gt; &lt;property name=&quot;showSql&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;generateDdl&quot; value=&quot;false&quot; /&gt; &lt;/bean&gt; &lt;!--配置实体管理器工厂--&gt; &lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;property name=&quot;jpaVendorAdapter&quot; ref=&quot;jpaVendorAdapter&quot; /&gt; &lt;property name=&quot;packagesToScan&quot; value=&quot;com.spring.model&quot; /&gt; &lt;/bean&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; 继承接口继承Repository接口Repository接口Repository是一个标记接口，所有继承（或者间接继承）了这个接口的接口都会被Spring自动扫描到，然后自动创建这个接口的实现类。如果用户只需要定义自己特有的方法，而不使用CrudRepository接口中自带的方法，则只需要继承Repository接口： interface PersonRepository extends Repository&lt;Person, Long&gt; &#123; List&lt;Person&gt; findByLastname(String lastname); &#125; 也可以使用下面的这种方式： @RepositoryDefinition(domainClass = AccountInfo.class, idClass = Long.class) public interface UserDao &#123; …… &#125; CrudRepository接口以下部分内容来自Spring Data JPA的官方文档以及IBM Develop的大神的文章。 Spring Data库的核心接口是Repository。它使用domain类去管理，domain类中的id类型作为类型参数。这个接口主要作为一个标记接口(没有任何方法)，依靠具体的类型运作并帮助您发现接口，CrudRepository 提供丰富的CRUD功能去管理实体类。 import java.io.Serializable; @NoRepositoryBean public interface CrudRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; &#123; &lt;S extends T&gt; S save(S var1); &lt;S extends T&gt; Iterable&lt;S&gt; save(Iterable&lt;S&gt; var1); T findOne(ID var1); boolean exists(ID var1); Iterable&lt;T&gt; findAll(); Iterable&lt;T&gt; findAll(Iterable&lt;ID&gt; var1); long count(); void delete(ID var1); void delete(T var1); void delete(Iterable&lt;? extends T&gt; var1); void deleteAll(); &#125; 有@NoRepositoryBean注解的接口Spring不会为其创建实现类。两个接口的中间接口一般需要使用@NoRepositoryBean注解。通过CrudRepository类的定义可以看到，CrudRepository类定义了11种对数据库操作的常用方法。 如果持久层接口较多，且每一个接口都需要声明相似的增删改查方法，直接继承 Repository 就显得有些啰嗦，这时可以继承 CrudRepository，它会自动为域对象创建增删改查方法，供业务层直接使用。开发者只是多写了 “Crud” 四个字母，即刻便为域对象提供了开箱即用的十个增删改查方法。 **但是，使用 CrudRepository 也有副作用，它可能暴露了你不希望暴露给业务层的方法。比如某些接口你只希望提供增加的操作而不希望提供删除的方法。针对这种情况，开发者只能退回到 Repository 接口，然后到 CrudRepository 中把希望保留的方法声明复制到自定义的接口中即可。 ** 用户可以定义一个接口继承CrudRepository类来定义访问数据库的方法，当然也可以使用CrudRepository接口中自带的方法： public interface UserRepository extends CrudRepository&lt;User, Long&gt; &#123; //查询并统计 Long countByLastname(String lastname); //查询并删除 Long deleteByLastname(String lastname); List&lt;User&gt; removeByLastname(String lastname); &#125; PagingAndSortingRepository接口CrudRepository有一个PagingAndSortingRepository 抽象,增加了额外的方法来简化对实体的分页访问: public interface PagingAndSortingRepository&lt;T, ID extends Serializable&gt; extends CrudRepository&lt;T, ID&gt; &#123; Iterable&lt;T&gt; findAll(Sort sort); Page&lt;T&gt; findAll(Pageable pageable); &#125; 进入用户类别的第二页（每一页的条目是20），可以照下面这样来分页 PagingAndSortingRepository&lt;User, Long&gt; repository = // … get access to a bean Page&lt;User&gt; users = repository.findAll(new PageRequest(1, 20)); 如何选择上述四个接口，开发者到底该如何选择？其实依据很简单，根据具体的业务需求，选择其中之一。笔者建议在通常情况下优先选择 Repository 接口。因为 Repository 接口已经能满足日常需求，其他接口能做到的在 Repository 中也能做到，彼此之间并不存在功能强弱的问题。只是 Repository 需要显示声明需要的方法，而其他则可能已经提供了相关的方法，不需要再显式声明，但如果对 Spring Data JPA 不熟悉，别人在检视代码或者接手相关代码时会有疑惑，他们不明白为什么明明在持久层接口中声明了三个方法，而在业务层使用该接口时，却发现有七八个方法可用，从这个角度而言，应该优先考虑使用 Repository 接口。 为接口的方法声明自定义查询方法名定义查询的规则： And — 等价于 SQL 中的 and 关键字，比如 findByUsernameAndPassword(String user, Striang pwd)； Or — 等价于 SQL 中的 or 关键字，比如 findByUsernameOrAddress(String user, String addr)； Between — 等价于 SQL 中的 between 关键字，比如 findBySalaryBetween(int max, int min)； LessThan — 等价于 SQL 中的 “&lt;”，比如 findBySalaryLessThan(int max)； GreaterThan — 等价于 SQL 中的”&gt;”，比如 findBySalaryGreaterThan(int min)； IsNull — 等价于 SQL 中的 “is null”，比如 findByUsernameIsNull()； IsNotNull — 等价于 SQL 中的 “is not null”，比如 findByUsernameIsNotNull()； NotNull — 与 IsNotNull 等价； Like — 等价于 SQL 中的 “like”，比如 findByUsernameLike(String user)； NotLike — 等价于 SQL 中的 “not like”，比如 findByUsernameNotLike(String user)； OrderBy — 等价于 SQL 中的 “order by”，比如 findByUsernameOrderBySalaryAsc(String user)； Not — 等价于 SQL 中的 “！ =”，比如 findByUsernameNot(String user)； In — 等价于 SQL 中的 “in”，比如 findByUsernameIn(Collection userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数； NotIn — 等价于 SQL 中的 “not in”，比如 findByUsernameNotIn(Collection userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数； 在使用方法名定义查询时，会有一些限制，比如方法名太长、想要的查询很难用方法名去表达时，我们可以通过@Query注解自定义查询： import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Query; public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123; @Query(&quot;SELECT a FROM User AS a WHERE a.user_id= ?1&quot;)//指定SQL语句 User findById(Long id); &#125; 需要注意的是，占位符？后面必须按顺序接上数字。同时FROM后面的表明需要为实体类名，具体的原因还没弄清楚，可能是JPQL的特定语法 很多开发者在创建 JPQL 时喜欢使用命名参数来代替位置编号，@Query 也对此提供了支持。JPQL 语句中通过”: 变量”的格式来指定参数，同时在方法的参数前面使用 @Param 将方法参数与 JPQL 中的命名参数对应，示例如下： public interface UserDao extends Repository&lt;AccountInfo, Long&gt; &#123; public AccountInfo save(AccountInfo accountInfo); @Query(&quot;from AccountInfo a where a.accountId = :id&quot;) public AccountInfo findByAccountId(@Param(&quot;id&quot;)Long accountId); @Query(&quot;from AccountInfo a where a.balance &gt; :balance&quot;) public Page&lt;AccountInfo&gt; findByBalanceGreaterThan( @Param(&quot;balance&quot;)Integer balance,Pageable pageable); &#125; 此外，开发者也可以通过使用 @Query 来执行一个更新操作，为此，我们需要在使用 @Query 的同时，用 @Modifying 来将该操作标识为修改查询，这样框架最终会生成一个更新的操作，而非查询。如下所示： @Modifying @Query(&quot;update AccountInfo a set a.salary = ?1 where a.salary &lt; ?2&quot;) public int increaseSalary(int after, int before);//返回值必须为void、Integer/int 定义实体类（Entity）对于接口中要使用到的实体类，需要使用以下方法定义： import javax.persistence.Entity; import javax.persistence.Id; import javax.persistence.Table; @Entity//声明一个实体类 @Table(name = &quot;user&quot;)//定义表名 public class User &#123; public User() &#123; &#125; @Id private Long user_id; private String user_name; private int user_age; private String user_addr; public User(Long user_id, String user_name, int user_age, String user_addr) &#123; this.user_id = user_id; this.user_name = user_name; this.user_age = user_age; this.user_addr = user_addr; &#125; public Long getUser_id() &#123; return user_id; &#125; setter/getter方法 &#125; ** 需要注意的是所有的POJO都要有默认构造器，因为反射需要有默认构造器。同时，在使用AutoIncrement时，需要在自增的属性上使用@GeneratedValue(strategy=GenerationType.IDENTITY) 或者添加注解：&lt;property name=&quot;hibernate.id.new_generator_mappings&quot;&gt;false&lt;/property&gt; ** 可以在配置LocalContainerEntityManagerFactoryBean时，调用方法setPackageToScan来定义扫描Entity类的路径: emf.setPackagesToScan(new String[]&#123;&quot;com.rick.entities&quot;&#125;); 为这些接口创建代理实例有了自定义的Repository接口，我们并不需要为这些接口提供实现类，我们只需要像配置&lt;context:component-scan base-package=&quot;com.spring&quot; /&gt; 一样开启自动的Repository扫描，在启动时Spring就会扫描指定目录下的所有实现了Repository接口的接口，并自动为我们创建实现类，实现类的行为都是通过方法名实现的，专业名词叫做(领域特定语言)DSL，我也不懂是个啥，反正非常的炫酷。开启扫描有两种方式：在xml中开启： &lt;jpa:repositories base-package=&quot;com.spring.model&quot;/&gt; 通过Java配置类开启： import org.springframework.data.jpa.repository.config.EnableJpaRepositories; @EnableJpaRepositories(&quot;com.acme.repositories&quot;) class Config &#123;&#125; 获得repository 实例注入并使用它。在需要对数据库进行操作的地方，直接注入一个repository，然后就可以调用我们定义的那些方法啦： import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations= &quot;classpath:spring-config.xml&quot;)//得到xml配置文件 public class UserRepositoryIntegrationTest &#123; @Autowired UserRepository repository;//注入自定义的Repository接口 @Test public void sampleTestCase() &#123; User result = repository.findById(10002l); User user=new User(10003l,&quot;caf&quot;,123,&quot;新洲蘑菇棒&quot;); repository.save(user); System.out.println(result); System.out.println(repository.count()); System.out.println(repository.findById(10003l)); &#125; &#125; 为接口中的部分方法提供自定义实现有些时候，开发者可能需要在某些方法中做一些特殊的处理，此时自动生成的代理对象不能完全满足要求。为了享受 Spring Data JPA 带给我们的便利，同时又能够为部分方法提供自定义实现，我们可以采用如下的方法： 将需要开发者手动实现的方法从持久层接口（假设为 AccountDao ）中抽取出来，独立成一个新的接口（假设为 AccountDaoPlus ），并让 AccountDao 继承 AccountDaoPlus；AccountDap extends CurdRepository&lt;User,long&gt;,AccountDaoPluse 为 AccountDaoPlus 提供自定义实现（默认为接口加上Impl,即为 AccountDaoPlusImpl ）； AccountDaoPlusImple implements AccountDapPlus 将 AccountDaoPlusImpl 配置为 Spring Bean； 在业务层注入并使用AccountDaoPlus； 指定自定义实现类&lt;jpa:repositories base-package=&quot;footmark.springdata.jpa.dao&quot;&gt; &lt;jpa:repository id=&quot;accountDao&quot; repository-impl-ref=&quot; accountDaoPlus &quot; /&gt; &lt;/jpa:repositories&gt; &lt;bean id=&quot;accountDaoPlus&quot; class=&quot;.......&quot;/&gt; 此外，&lt;jpa:repositories &gt; 提供了一个 repository-impl-postfix 属性，用以指定实现类的后缀。例如如下配置： &lt;--指定自定义实现类为自定义接口名+Impl;--&gt; &lt;jpa:repositories base-package=&quot;footmark.springdata.jpa.dao&quot; repository-impl-postfix=&quot;Impl&quot;/&gt; 基于Java类的配置时做如下配置： @EnableRepositories( base-packet=&quot;com.spring.model&quot; repositoryImplementationPostfix=&quot;Helper&quot;//指定自定义实现类为自定义接口名+Helper; ) 启用Spring注解事务SpringDataJPA，中在插入修改删除等需要对数据进行修改的操作时需要使用事务，而查找操作则不需要使用事务要启用Spring的注解事务，需要做如下配置，关于事务我还没有认真学习过，清明节放假好好学习一下： 首先需要在配置文件中开启注解事务： &lt;!--开启注解事务--&gt; &lt;jx:annotation-driven/&gt; 同时需要引入jx的命名空间xmlns:jx=&quot;http://www.springframework.org/schema/tx&quot;. 在开启注解事物之后，就可以使用@Transactional注解来使用事务了。@Transactional注解只能使用在public修饰的方法中，对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能，同时需要在业务层使用，而不能在DAO接口层。 Spring团队的建议是你在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。你当然可以在接口上使用 @Transactional 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是 不能继承 的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）。因 此，请接受Spring团队的建议并且在具体的类上使用博客原文 业务层代码： import javax.transaction.Transactional; /** * 业务层，用于定义对User的常规操作 */ public class UserOptService &#123; private UserRepository repository; public UserOptService(UserRepository repository) &#123; this.repository = repository; &#125; @Transactional public void updateUserAddr(long id, String addr)&#123; repository.updateUserAddr(id,addr); &#125; public User findByUserId(long id)&#123; return repository.findById(id); &#125; public User addUser(User user)&#123; return repository.save(user); &#125; &#125; 在DAO层（也就是Repository接口），对涉及删除、修改、增加的方法添加@Modifying注解： import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Modifying; import org.springframework.data.jpa.repository.Query; import org.springframework.data.repository.query.Param; public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123; @Query(&quot;SELECT a FROM User AS a WHERE a.user_id= ?1&quot;) User findById(Long id); @Modifying//增加的注解 @Query(&quot;UPDATE User SET user_addr = :addr WHERE user_id= :id&quot;) void updateUserAddr(@Param(&quot;id&quot;) Long id, @Param(&quot;addr&quot;) String addr); &#125; 测试事务是否能正常运行： import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations= &quot;classpath:spring-config.xml&quot;) public class UserRepositoryIntegrationTest &#123; @Autowired UserOptService service; @Test public void sampleTestCase() &#123; User result = service.findByUserId(10002l); System.out.println(result); User user=new User(&quot;caf&quot;,134,&quot;新洲蘑菇棒&quot;); service.addUser(user); String addr=&quot;美丽繁华的魔都嗯嗯嗯！&quot;; service.updateUserAddr(10001l,addr);//可以成功修改 service.updateUserAddr(100011l,addr);//使用错误的ID，不能成功修改 System.out.println(service.findByUserId(10001l)); &#125; &#125; 在测试类中，使用正确的ID可以插入，而使用错误的ID则无法插入。(发生异常，数据回滚)","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Java Web","slug":"Java-Web","permalink":"https://super-aviator.github.io/tags/Java-Web/"},{"name":"Spring","slug":"Spring","permalink":"https://super-aviator.github.io/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"https://super-aviator.github.io/tags/Spring-Data-JPA/"}],"author":"熊乾坤"},{"title":"Spring中使用Multipart上传文件","slug":"Spring中使用Multipart上传文件","date":"2019-03-21T14:10:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2019/03/21/Spring中使用Multipart上传文件/","link":"","permalink":"https://super-aviator.github.io/2019/03/21/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8Multipart%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/","excerpt":"","text":"在web应用中，我们常常需要使用到文件上传功能，比如用户注册时需要上传用户自定义的头像，在聊天室需要发送聊天图片等等，这就需要使用到Multipart功能，要使用文件上传功能，前端的表单代码需要做一些小修改，同时后台Spring也需要添加对Multipart的解析器（Resolver）. 前台代码的修改当表单需呀使用到Multipart时，需要在form标签中加上enctype属性： &lt;form method=&quot;POST&quot; action=&quot;http://localhost:8080/uploadImg&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;uploadImg&quot; accept=&quot;image/jpg,image/png&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; &gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; &gt; &lt;/form&gt; 需要注意的时上面的代码中的enctype=&quot;multipart/form-data&quot;,当使用此属性时，form表单会被拆分为多个part，包含文件的part中，存放的数据即为文件的二进制数据。input标签中的accept=&quot;image/jpg,image/png&quot;属性指明了所需的文件类型。 Spring中使用Multipart接收文件Spring中接收Multipart数据需要添加相应的解析器（Resolver）,Spring中主要有两种multipart解析器： StandardServletMultipartResovler 依赖于Servlet3.0对Multipart的支持，不需要依赖其他的包。 CommonsMultipartResolver 使用Jakarta Commons FileUpload解析multipart请求。 如果需要把应用部署到Servlet3.0的容器中或者使用3.1之前的Spring版本，则需要使用CommonsMultipartResolver，否则，一般情况下我们使用StandardServletMultipartResovler。 配置StandardServletMultipartResolver解析器如果配置StandardServletMultipartResolver解析器，首先需要在WebConfig配置类中添加Bean。 @Bean public MultipartResolver multipartResolver()&#123; return new StandardServletMultipartResolver(); &#125; 由于StandardServletMultipartResolver类没有属性和构造器参数，所以不能对其进行设置，我们需要重写AbstractAnnotationCongifDispatcherServlet类的customizeRegistration方法，在这个方法中去对StandardServletMultipartResolver进行设置： @Override protected void customizeRegistration(ServletRegistration.Dynamic registration) &#123; registration.setMultipartConfig(new MultipartConfigElement(&quot;E://avatar//&quot;,2097152,4194304,0)); &#125; 对于Multipart，我们一般需要配置一下几个参数： 文件临时存放的路径例如：&quot;E://avatar//&quot; 上传的文件的最大长度 例如：2MB 整个请求的最大长度 例如：4MB 上传过程中，如果文件大于某个数，则需要将其存入临时存放的路径中 例如：0（即任何大小的文件都需要存到临时路径中） 如果是基于web.xml的配置，则需要在DispatcherServlet的Servlet中添加&lt;multipart-config&gt;标签： &lt;servlet&gt; &lt;servlet-name&gt;application&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet. DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt;org.springframework.web.context.support. AnnotationConfigWebApplicationContext&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--定义contextConfigLocation的初始化参数--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.spring.mvc.WebConfig&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;multipart-config&gt; &lt;location&gt;E://avatar//&lt;/location&gt; &lt;max-file-size&gt;2097152&lt;/max-file-size&gt; &lt;max-request-size&gt;4194304&lt;/max-request-size&gt; &lt;/multipart-config&gt; &lt;/servlet&gt; 配置CommonsMultipartResolver解析器CommonsMultipartResolver可以作为StandardMultipartResolver的替代方案，配置CommonsMultipartResolver需要引入单独的jar包： &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;com.springsource.org.apache.commons.fileupload&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 然后在WebConfig.java中申明Bean: @Bean public MultipartResolver commonsMultipartResolver() throws IOException &#123; CommonsMultipartResolver resolver= new CommonsMultipartResolver(); resolver.setUploadTempDir(new FileSystemResource(&quot;E://avatar//&quot;)); resolver.setMaxUploadSize(2097152); resolver.setMaxInMemorySize(0); return resolver; &#125; 与StandardMultipartRsolver不同的是，CommonsMultipartResolver可以在申明时直接配置参数，不过CommonsMultipartResolver类无法配置整个请求的最大长度这一参数。 处理Multipart数据在Controller中，需要对Multipart进行写入处理： import java.io.File; import java.io.IOException; import static org.springframework.web.bind.annotation.RequestMethod.POST; @Controller @RequestMapping(value = &quot;/uploadImg&quot;) public class UploadImgController &#123; @RequestMapping(method = POST) public @ResponseBody LoginMsg uploadImg(@RequestParam(&quot;uploadImg&quot;)MultipartFile img ,User user) throws IOException &#123; System.out.println(&quot;UploadImgController has been visited&quot;); File f=new File(&quot;E://avatar//&quot;+img.getOriginalFilename()); img.transferTo(f); String path=f.getAbsolutePath(); return new LoginMsg(0,path); &#125; &#125; 在处理表单对应的方法中，需要使用@RequestParam注解，并将前端的文件的标签的name属性作为参数传递进去，Spring会自动将其包装为MultipartFile对象，此对象包含了文件的所有信息：字节数组、文件名等，以及写入到磁盘的快捷方法transferTo().上面的方法中，还返回了代表成功失败的json对象，用于前端判断图片是否上传成功。同时，表单中的其他项则被包装到User类中。同理，如果需要上传多个文件，则可以将参数设置为@RequestParam(&quot;uploadImg&quot;)MultipartFile[] img。","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://super-aviator.github.io/tags/Spring/"}],"author":"熊乾坤"},{"title":"基于Java类配置的SpringMVC中添加自定义Servlet和Filter","slug":"基于Java类配置的Spring中添加自定义Servlet和Filter","date":"2019-03-19T13:59:00.000Z","updated":"2021-02-23T13:00:00.000Z","comments":true,"path":"2019/03/19/基于Java类配置的Spring中添加自定义Servlet和Filter/","link":"","permalink":"https://super-aviator.github.io/2019/03/19/%E5%9F%BA%E4%BA%8EJava%E7%B1%BB%E9%85%8D%E7%BD%AE%E7%9A%84Spring%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89Servlet%E5%92%8CFilter/","excerpt":"","text":"在基于Java类的Spring配置中，通过继承AbstractAnnotationConfigDispatcherServletInitializer类来初始化ContextLoadListener和DispatcherServlet,通过这种方式配置Spring时如何添加自定义的Servlet和Filter呢？比如解决跨域访问时，需要添加自定义的Filter去解决。 重写AbstractAnnotationConfigDispatcherServletInitializer类的方法来添加Filter如果想要添加DispatcherServlet相同映射路径的Filter,可以使用一种快捷的方法，即重写getServletFilters()方法，如下所示： //AbstractAnnotationConfigDispatcherServletInitializer类中 @Override public Filter[] getServletFilters()&#123; return new Filter[]&#123;new MyFilter()&#125;; &#125; 该方法可以返回任意多的Filter,所有的Filter都会映射到DispatcherServlet路径上。 实现WebApplicationInitializer接口添加自定义的Servlet和Filter这种方法更加灵活，可以将Servlet和Filter映射到自定义的路径下。 添加自定义Servletimport javax.servlet.ServletRegistration.Dynamic; public class MyServletInitializer implements WebApplicationInitializer{ @Override public void onStartup(ServletContext servletContext) throws ServletException{ Dynamic mySerlvet=servletContext.addServlet(“myServlet”,MyServlet.class); myServlet.addMapping(“/mypath/*”); }} - 添加自定义Filter ```java import javax.servlet.FilterRegistration.Dynamic; public class MyServletInitializer implements WebApplicationInitializer&#123; @Override public void onStartup(ServletContext servletContext) throws ServletException&#123; Dynamic myFilter=servletContext.addFilter(&quot;myFilter&quot;,MyFilter.class); myFilter.addMappingForUrlPatterns(null,false,&quot;/mypath/*&quot;); &#125; &#125; 重写AbstractAnnotationConfigDispatcherServletInitializer类的方法来自定义DispatcherServlet配置AbstractAnnotationConfigDispatcherServletInitializer类我们重写了必须重写的三个方法，getServletConfigClasses、getRootConfigClasses、getServletMappings,但是还有非常多的方法可以去重写，比如重写**customizeRegistration()**方法，在将DispatcherServlet注册到Servlet容器之中后，就会调用customizeRegistration()方法，并将DispatcherServlet注册之后得到的Dynamic对象传递进来，通过此方法可以自定义DispatcherServlet的很多事情，比如开启Multipart文件上传功能： @Override protected void customizeRegistration(ServletRegistration.Dynamic registration)&#123; registration.setMultipartCongif( new MultimartConfigElement(&quot;/tmp/uploads&quot;); ); //或者设置LoadOnStartup参数 registration.setLoadOnStartup(1); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Java Web","slug":"Java-Web","permalink":"https://super-aviator.github.io/tags/Java-Web/"},{"name":"Spring","slug":"Spring","permalink":"https://super-aviator.github.io/tags/Spring/"}],"author":"熊乾坤"},{"title":"Windows系统下配置Tomcat","slug":"IDEA中配置Tomcat","date":"2019-03-16T13:11:14.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2019/03/16/IDEA中配置Tomcat/","link":"","permalink":"https://super-aviator.github.io/2019/03/16/IDEA%E4%B8%AD%E9%85%8D%E7%BD%AETomcat/","excerpt":"","text":"Tomcat下载并解压首先去官网下载一个Tomcat安装包,JDK当然也是需要滴。 环境配置下载下来的压缩包解药到文件夹中，比如说我解压到了G:\\apache-tomcat-7.0.86文件夹，然后配置环境变量： 计算机→属性→高级系统设置→高级→系统环境变量 新建TOMCAT_HOME变量 变量名TOMCAT_HOME 变量值为解压的Tomcat安装包的路径,比如G:\\apache-tomcat-7.0.86 新建CATALINA_HOME变量 变量名CATALINA_HOME 变量值同样为解压的Tomcat安装包的路径 修改变量Path 在系统变量中找到Path变量名，双击或点击编辑，在末尾添加如下内容;%TOMCAT_HOME%\\bin;%CATALINA_HOME%\\lib 这里要注意，各个变量值之间一定要用;分隔。 在cmd命令窗口下输入startup回车（或者点击bin目录下的startup.bat文件），如果没有报错就说明成功 在浏览器中输入http://localhost:8080或http://127.0.0.1:8080，如果出现tomcat服务器页面即为配置成功。 出现的问题如果输入startup出现Neither the JAVA_HOME nor the JRE_HOME environment variable is defined错误，原因是后来较新版本的JDK（例如我使用的JDK1.6）安装完不会自动登记环境变量JAVA_HOME，JRE_HOME。像我在单位的环境，我的用户是受限制的(PowerUser)，不方便设环境变量，于是我就找到了另外一个方法。先看Tomcat的startup.bat，它调用了catalina.bat,而catalina.bat则调用了setclasspath.bat。只要在setclasspath.bat的开头声明环境变量，修改方法如下：在文件中加入以下两行手动设置JAVA_HOME和JAR_HOME的路径： set JAVA_HOME=D:\\Java\\jdk1.6.0_11 set JRE_HOME=D:\\Java\\jre6 在linux系统中需要将set替换为export。 参考地址1参考地址2参考地址3","categories":[],"tags":[],"author":"熊乾坤"},{"title":"工作总结-第一周","slug":"工作总结-第一周","date":"2019-03-16T12:53:00.000Z","updated":"2021-02-23T13:00:04.000Z","comments":true,"path":"2019/03/16/工作总结-第一周/","link":"","permalink":"https://super-aviator.github.io/2019/03/16/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%80%E5%91%A8/","excerpt":"","text":"在军训结束之后，我顺利的度过了实习的第一周，这一周总的来说很寂寞，很空虚，也很慌，一方面是人际关系的慌，一方面是能力不足引起的恐慌，但是我觉得人的成长总是需要时间的，一切都会慢慢好起来，第一周的收货还是有很多滴，我决定工作的接下来每一周都把上一周遇到的不会的、不熟悉的技术总结一下，犯过的错误坚决不能犯第二次，还有一些比较重要的需要单独总结一下比较好,写到一起也没有关系，因为可以使用博客的搜索功能。废话不多说，开始吧。 MySQL中JOIN的用法在弄毕业实际的时候，使用到了Mybatis，其中含有一对多的映射关系，其实做好只有回想起来也没有很复杂，但是我却零零散散想了有个把星期，其中的关键就是JOIN的用法以及标签的用法。首先记录一下JOIN的用法，StackOverflow上有非常详细的解答，我就直接总结一下吧（偷一下懒先）： INNER JOIN:返回两个表都的部分。如图所示： OUTER JOIN:返回两个表中都有的部分，然后加上左边和右边特有的部分 LEFT OUTER JOIN ：返回两个表中都有的部分，然后加上左边特有的部分。 RIGHT OUTER JOIN ：返回两个表中都有的部分，然后加上右边特有的部分。 JOIN还有很多特殊的用法，上面图中已经涉及到了，这里就不一一写了，脑阔有点疼。 FastJSON中的@JSONFiled注解FastJSON库的功能十分强大，导师说以后使用的时间也会非常多，那就先看一下非常常用的一个注解@JSONField的部分功能吧，更多的用法可以看看文档 自定义属性序列化的顺序有时候前台的JSON字符串的格式是固定的，所以后台就需要对POJO序列化的顺序进行控制，可以在成员变量上使用@JSONField(ordinal = 1)来对属性的序列化进行控制。 将数值类型序列化为字符类型数字类型在传递到前台时可能会出现溢出，导致出错，所以一般可以把数值类型序列化为字符类型，可以在数值类型的成员变量上使用@JSONField(serializeUsing = ToStringSerializer.class)来控制 serializeUsing 这个属性是在fastjson 1.2.16后才有的。要检查下fastJson的版本 将对象属性序列化为指定的名称有时对象的属性并不能序列化为指定的名字，此时就需要使用注解来指定序列化之后的名字，可以使用@JSONField(name=”name”),同样此注解可以使用在geter或者seter方法上，也可以使用在成员变量上，对序列化进行不同控制。 对时间进行格式化对于Data时间格式，可以使用@JSONField(format=”yyyyMMdd”)来格式化时间 ##使用serialize/deserialize指定字段不序列化 public class A &#123; @JSONField(serialize=false) public Date date; &#125; public class A &#123; @JSONField(deserialize=false) public Date date; &#125; 更多的用法可以查看文档 Mybatis中JavaType和JDBCType的对应在弄毕设的时候，数据库中的BIGINT会被映射为Java的Long类型，但是在今天做映射的时候，BIGINT且被映射为Integer类型，具体的原因我还没弄清除，可能是BIGINT（20）由于数字太小进行了自动转换，等下次遇到的时候再去研究一下，先记录下JDBCType和JavaType数据类型的对应关系： JDBCType JavaType CHAR String VARCHAR String LONGVARCHAR String NUMERIC java.math.BigDecimal DECIMAL java.math.BigDecimal BIT boolean BOOLEAN boolean TINYINT byte SMALLINT short INTEGER int BIGINT long REAL float FLOAT double DOUBLE double BINARY byte[] VARBINARY byte[] LONGVARBINARY byte[] DATE java.sql.Date TIME java.sql.Time TIMESTAMP java.sql.Timestamp CLOB Clob BLOB Blob ARRAY Array DISTINCT mapping of underlying type STRUCT Struct REF Ref DATALINK java.net.URL[color=red][/color] ``` # Mybatis中&lt; collection &gt;标签的使用 在做课设处理映射时，使用到了一对多的映射，先还原场景，然后看一看&lt; collection &gt;标签的用法。 ## 表结构： user_info(用户信息表)： ![AeUPfJ.png](https://s2.ax1x.com/2019/03/17/AeUPfJ.png) packet_info(用户分组信息，每个分组保存了用户的好友)： ![AeUMfH.png](https://s2.ax1x.com/2019/03/17/AeUMfH.png) user_packet_info(用户所建的分组)： ![AeUt78.png](https://s2.ax1x.com/2019/03/17/AeUt78.png) packet_user_info(分组中保存的好友)： ![AeUdhQ.png](https://s2.ax1x.com/2019/03/17/AeUdhQ.png) ## 所要是实现的功能 项目中所要实现的功能是查询某一个user_id的所有分组下的好友，返回的主要部分JSON格式需要如下： ```text &#123; //好友列表 &quot;friend&quot;: [&#123; &quot;groupname&quot;: &quot;前端码屌&quot; //好友分组名 ,&quot;id&quot;: 1 //分组ID ,&quot;list&quot;: [&#123; //分组下的好友列表 &quot;username&quot;: &quot;贤心&quot; //好友昵称 ,&quot;id&quot;: &quot;100001&quot; //好友ID ,&quot;avatar&quot;: &quot;a.jpg&quot; //好友头像 ,&quot;sign&quot;: &quot;这些都是测试数据，实际使用请严格按照该格式返回&quot; //好友签名 ,&quot;status&quot;: &quot;online&quot; //若值为offline代表离线，online或者不填为在线 &#125;, …… ] &#125;, …… ] &#125; 解决方法ResultMap: &lt;select id=&quot;SelectFriendInfo&quot; resultMap=&quot;FriendInfoResultMap&quot;&gt; SELECT packet_name ,C.packet_id FROM user_packet_info AS A INNER JOIN packet_info AS C ON A.packet_id=C.packet_id WHERE A.user_id=#&#123;id&#125;; &lt;/select&gt; &lt;select id=&quot;SelectUserFriend&quot; resultType=&quot;FriendInfo&quot;&gt; SELECT E.user_id AS id,username,sign,avatar,status FROM user_packet_info AS A INNER JOIN packet_user_info AS E ON A.packet_id=E.packet_id INNER JOIN user_info AS B ON E.user_id=B.user_id AND B.user_id!=A.user_id WHERE E.packet_id=#&#123;id&#125;; &lt;/select&gt; &lt;resultMap id=&quot;FriendInfoResultMap&quot; type=&quot;PacketInfo&quot;&gt; &lt;constructor&gt; &lt;idArg column=&quot;packet_id&quot; javaType=&quot;Long&quot;/&gt; &lt;arg column=&quot;packet_name&quot; javaType=&quot;String&quot;/&gt; &lt;/constructor&gt; &lt;collection property=&quot;list&quot; ofType=&quot;FriendInfo&quot; javaType=&quot;ArrayList&quot; column=&quot;packet_id&quot; select=&quot;SelectUserFriend&quot;&gt; &lt;id column=&quot;id&quot; javaType=&quot;Long&quot;/&gt; &lt;result column=&quot;username&quot; javaType=&quot;String&quot;/&gt; &lt;result column=&quot;sign&quot; javaType=&quot;String&quot;/&gt; &lt;result column=&quot;status&quot; javaType=&quot;String&quot;/&gt; &lt;result column=&quot;avatar&quot; javaType=&quot;String&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; 其中的&lt; collection &gt;中，需要使用一个column属性，将上层的packet_id传递给下层的查询语句作为参数，association同样也需要。而且不能将两个SELECT合并为一个查询语句。","categories":[{"name":"Career","slug":"Career","permalink":"https://super-aviator.github.io/categories/Career/"}],"tags":[{"name":"工作总结","slug":"工作总结","permalink":"https://super-aviator.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"}],"author":"熊乾坤"},{"title":"JUnit基础用法","slug":"JUnit基础用法介绍","date":"2019-02-01T08:05:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2019/02/01/JUnit基础用法介绍/","link":"","permalink":"https://super-aviator.github.io/2019/02/01/JUnit%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"JUnit4和JUnit5常用注解(Annotations) @BeforeClass(等价于JUnit5中的@BeforeAll)该注解作用于方法之上，含有此注解的方法在所有方法执行之前执行，方法必须使用public static void修饰，不能有参数，通常用来加载资源或配置文件。 @BeforeClass(等价于JUnit5中的@AfterAll)该注解作用于方法之上，含有此注解的方法在所有方法执行之后执行，方法必须使用public static void修饰，不能有参数，通常用来释放资源。 @Before(等价于JUnit5中的@BeforeEach)该注解作用于方法之上，含有此注解的方法在**每个测试方法(@Test注解的方法)**执行之后执行，方法必须使用public void修饰，不能有参数。 @After(等价于JUnit5中的@AfterEach)该注解作用于方法之上，含有此注解的方法在**每个测试方法(@Test注解的方法)**执行之后执行，方法必须使用public void修饰，不能有参数。 @Test该注解作用于方法之上，表示该方法是一个测试方法，方法必须使用public void修饰，不能有参数。 @Ignore(等价于JUnit5中的@Disable)该注解作用于@Test注解的测试方法之上，表示忽略此测试方法，此测试方法不会被执行，此注解不能作用在类上。 @DisplayName（JUnit5新增）该注解可作用于类或者方法上，可以更改测试类的显示名称，例如使用@DisplayName(&quot;Aviator&quot;)则测试类名显示为Aviator，通过@DisplayName，开发人员可以为每个测试用例添加更具体的名字，更容易传达用例所要测试的内容。 常用注释表(CSDN博客原表格地址)： JUnit4 JUnit5 说明 @Test @Test 表示该方法是一个测试方法。JUnit5与JUnit 4的@Test注解不同的是，它没有声明任何属性，因为JUnit Jupiter中的测试扩展是基于它们自己的专用注解来完成的。这样的方法会被继承，除非它们被覆盖； @BeforeClass @BeforeAll 表示使用了该注解的方法应该在当前类中所有使用了@Test @RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之前 执行； @AfterClass @AfterAll 表示使用了该注解的方法应该在当前类中所有使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之后执行； @Before @BeforeEach 表示使用了该注解的方法应该在当前类中每一个使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之前 执行 @After @AfterEach 表示使用了该注解的方法应该在当前类中每一个使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之后 执行 @Ignore @Disabled 用于禁用一个测试类或测试方法 @Category @Tag 用于声明过滤测试的tags，该注解可以用在方法或类上；类似于TesgNG的测试组或JUnit 4的分类。 @Parameters @ParameterizedTest 表示该方法是一个参数化测试 @RunWith @ExtendWith @Runwith就是放在测试类名之前，用来确定这个类怎么运行的 @Rule @ExtendWith Rule是一组实现了TestRule接口的共享类，提供了验证、监视TestCase和外部资源管理等能力 @ClassRule @ExtendWith @ClassRule用于测试类中的静态变量，必须是TestRule接口的实例，且访问修饰符必须为public。 JUnit4和5中的断言（Assertion）点击查看原文地址断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。这些断言方法都是 org.junit.jupiter.api.Assertions 的静态方法。JUnit 5 内置的断言可以分成如下几个类别： 第一类是简单断言，用来对单个值进行简单的验证，常用的方法见表： 方法 说明 assertEquals 判断两个对象或两个原始类型是否相等 assertNotEquals 判断两个对象或两个原始类型是否不相等 assertSame 判断两个对象引用是否指向同一个对象 assertNotSame 判断两个对象引用是否指向不同的对象 assertTrue 判断给定的布尔值是否为 true assertFalse 判断给定的布尔值是否为 false assertNull 判断给定的对象引用是否为 null assertNotNull 判断给定的对象引用是否不为 null 在JUnit5中这些方法都有多个重载方法(JUnit4不支持)，可以提供额外的消息来作为断言不满足时的提示消息(Message)，还可以接受 Java 8 中的函数式编程接口 Supplier来获取要判断的值和显示的消息。下面代码给出了简单断言的使用示例: @Test @DisplayName(&quot;simple assertion&quot;) public void simple() &#123; assertEquals(3, 1 + 2, &quot;simple math&quot;);//接受String作为提示 assertEquals(1,2-1,()-&gt;&quot;simple math&quot;);//接受Java8的Supplier接口作为提示 assertNotEquals(3, 1 + 1); assertNotSame(new Object(), new Object()); Object obj = new Object(); assertSame(obj, obj); assertSame(obj, obj,&quot;not same new Object()&quot;);//接受String作为提示 assertSame(obj, obj,()-&gt;&quot;not same new Object()&quot;);//接受Java8的Supplier接口 assertFalse(1 &gt; 2); assertTrue(1 &lt; 2); assertNull(null); assertNotNull(new Object()); ... &#125; 第二类是通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等,或者通过assertIterableEquals方法来判断两个可迭代对象是否相等，如下所示： @Test @DisplayName(&quot;array assertion&quot;) public void array() &#123; assertArrayEquals(new int[]&#123;1, 2&#125;, new int[] &#123;1, 2&#125;);//同样也可以指定消息或者使用Supplier接口。 &#125; @Test @DisplayName(&quot;iterable assertion&quot;) public void iterable() &#123; assertIterableEquals(Arrays.asList(1,2,3),Arrays.asList(1,2,3),&quot;Iterable Not Equal&quot;); &#125; 第三类是通过assertAll方法来判断一组断言是否满足。assertAll 方法接受多个org.junit.jupiter.api.Executable（方法签名为void-&gt;void）函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言，assertAll的第一个参数是标题（heading），表示一组Executtable共有的属性，如下代码所示： @Test @DisplayName(&quot;assert all&quot;) public void all() &#123; assertAll(&quot;Math&quot;, () -&gt; assertEquals(2, 1 + 1), () -&gt; assertTrue(1 &gt; 0) ); &#125; 第四类是通过 assertThrows 或 expectThrows 来判断是否抛出期望的异常类型。两个方法的参数都是所期望的异常类型和对应的 Executable 接口的实现对象，区别在于 expectThrows 方法会返回抛出的异常对象。在下面代码中，1/0 会抛出 ArithmeticException 异常，下面代码使用assertThrows 用来验证这一点。 @Test @DisplayName(&quot;throws exception&quot;) public void exception() &#123; assertThrows(ArithmeticException.class, () -&gt; System.out.println(1 / 0)); &#125; 第五类是fail方法，用来直接使一个测试方法失败，如下代码所示： @Test @DisplayName(&quot;fail&quot;) public void shouldFail() &#123; fail(&quot;This should fail&quot;); &#125; JUnit中测试异常(Exception)和超时(Timeout)在JUnit4中（JUnit5不支持），可以对@Test注解进行扩展，使用expected和timeout属性，以便支持测试方法是否抛出特定异常和检测方法的运行时间。 @Test(expected=xx.class)：xx.class表示想要抛出的异常类，表示测试的方法抛出此异常时，认为是正常的测试通过的，如果没有抛出特定异常，则测试不通过。 @Test(timeout=毫秒数)：测试方法执行时间是否符合预期，如果方法运行时间超过给定的毫秒数，则测试不通过，否则测试通过，一般用来测试方法的性能。 JUnit5中可以使用断言来测试异常和超时,,以下方法都有一个参数为org.junit.jupiter.api.Executable（方法签名为void-&gt;void），同时可以指定一个String类型的message或者使用函数式接口Supplier来提供message,如下所示： assertThrows：断言所提供的可执行代码块的执行会引发expectedType的异常并返回异常。如果没有抛出异常，或者抛出了不同类型的异常，则此方法将失败。如果不想对异常实例执行其他检查，只需忽略返回值。 assertDoesNotThrow：断言所提供的可执行代码块的执行不会引发expectedType的异常并返回异常。如果抛出异常，则此方法将失败。 expectThrows：和assertThrows功能相同，区别在于 expectThrows 方法会返回抛出的异常对象。 assertTimeout：断言在超出给定超时之前，所提供的可执行代码块的执行完成。注意：可执行代码块将在与调用代码相同的线程中执行。因此，如果超过超时，则不会抢先中止执行可执行代码块，即如果发生超时方法不会立即结束。 assertTimeoutPreemptively：断言在超出给定超时之前，所提供的可执行代码块的执行完成。注意：可执行代码块将在与调用代码不同的线程中执行。此外，如果超时，则可抢占地执行可执行代码块，即如果超时方法会立即结束。 参数化测试（Parameters）","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"JUnit","slug":"JUnit","permalink":"https://super-aviator.github.io/tags/JUnit/"}],"author":"熊乾坤"},{"title":"Intellij IDEA中添加JUnit单元测试","slug":"Intellij-IDEA中添加JUnit单元测试","date":"2019-01-17T06:01:00.000Z","updated":"2021-02-23T13:00:02.000Z","comments":true,"path":"2019/01/17/Intellij-IDEA中添加JUnit单元测试/","link":"","permalink":"https://super-aviator.github.io/2019/01/17/Intellij-IDEA%E4%B8%AD%E6%B7%BB%E5%8A%A0JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","excerpt":"","text":"JUnit是一个很出名的单元测试测试框架，在非常多的项目中被使用，这几天想学习一下JUnit 4。目前广泛使用的是 JUnit 4 版本，同时JUnit 5也可以使用，JUnit 5 在增加了很多的新特性的同时，又保持了对 JUnit 4 的向后兼容性。等具体学习的时候再来看，首先学习在IDEA中添加JUint。 下载jar包首先需要去下载JUnit的jar包以及一个依赖包hamcrest.core，他们的下载地址如下：junit:junit:4.13-beta-1hamcrest.core:1.3.0.1需要注意的是hamcrest.core包不能使用2.1版本的，因为4.13版本的JUnit和它不兼容，会抛出ClassNotFoundException异常。 在Intellij IDEA项目中添加jar包首先需要在IDEA中添加刚才下载好的包： 记得勾选Export选项。 下载插件并进行设置然后需要下载一个名为JUnitGeneratorV2.0的插件： 然后对其进行设置： 输出路径可以更改为想要的路径 将图片中的$data改为$today是为了防止生成的测试类产生乱码。 使用JUnit当想要为当前类添加测试代码，只需要在当前类中使用Alt+inset（或者导航栏中点击Code-Generator）快捷键，选择JUnit-JUnit4，就会自动生成当前类的测试类： 插件默认会测试所有方法，使用快捷键Ctrl+Shift+T可以选择性的测试部分方法，非常的方便： 在输出路径中就可以看到自动生成的测试类，含有需要测试的方法，接下来就可以编写代码对类进行测试啦 QAQ.","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"JUnit","slug":"JUnit","permalink":"https://super-aviator.github.io/tags/JUnit/"}],"author":"熊乾坤"},{"title":"Ubuntu17系统环境下配置JDK","slug":"Ubuntu17系统下配置JDK","date":"2018-12-28T06:59:00.000Z","updated":"2021-02-23T13:00:00.000Z","comments":true,"path":"2018/12/28/Ubuntu17系统下配置JDK/","link":"","permalink":"https://super-aviator.github.io/2018/12/28/Ubuntu17%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%85%8D%E7%BD%AEJDK/","excerpt":"","text":"下载jdk文件在oracle官网上下载JDK1.8 linux的安装包，地址如下：JDK下载地址 解压将下载好的.tar.gz文件解压到指定文件夹:tar -zxvf jdk-8u191-linux-x64.tar.gz /usr/lib/jdk1.8将其解压到文件夹/usr/lib/jdk1.8中。 /usr/lib用于存放目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件的存放位置。这个目录功能类似/lib目录，理说，这里存放的文件应该是/bin目录下程序所需要的库文件的存放地，也不排除一些例外的情况。 .bashrc文件和/etc/profile文件区别在linux系统普通用户目录（cd/home/xxx）或root用户目录（cd /root）下，用指令ls -al可以看到4个隐藏文件， .bash_history 记录之前输入的命令 .bash_logout 当你退出时执行的命令 .profile 当你登入shell时执行 .bashrc 当你登入shell时执行 请注意后两个的区别：.profile只在会话开始时被读取一次，而.bashrc则每次打开新的终端时，都要被读取。 这些文件是每一位用户对终端功能和属性设置，修改.bashrc可以改变环境变量PATH、别名alias和提示符。 除了可以修改用户目录下的.bashrc文件外，还可以修改如“/etc/profile”文件、“/etc/bashrc”文件及目录“/etc/profile.d”下的文件。但是修改/etc路径下的配置文件将会应用到整个系统，属于系统级的配置，而修改用户目录下的.bashrc则只是限制在用户应用上，属于用户级设置。两者在应用范围上有所区别，建议如需修改的话，修改用户目录下的.bashrc，既无需root权限，也不会影响其他用户。 配置环境变量linux中需要在配置文件中修改环境变量PATH，有两个配置文件中写入，在.bashrc文件中写入或者/etc/profile文件中写入如下代码： export JAVA_HOME=/usr/lib/jdk1.8 #此路径为存放jdk的文件夹 export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 方法一：修改用户目录下的.bashrc文件，在文件最后一行添加如上代码：sudo vi ~/.bashrc此方法只对当前用户有效。 方法二：修改/etc/profile文件，在文件最后一行添加如上代码：sudo vi /etc/profile此方法对所有用户有效。 使配置文件生效并进行测试 source filepath 语句会使当前shell读入路径为filepath的shell文件并依次执行文件中的所有语句，通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。例如，当我们修改了/etc/profile文件，并想让它立刻生效，而不用重新登录，就可以使用source命令，如source /etc/profile。 使用source /etc/profile或者source ~/.bashrc使修改生效。使用java -version来测试是否完成配置。","categories":[{"name":"OperationSystem","slug":"OperationSystem","permalink":"https://super-aviator.github.io/categories/OperationSystem/"}],"tags":[{"name":"Linux常用命令","slug":"Linux常用命令","permalink":"https://super-aviator.github.io/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}],"author":"熊乾坤"},{"title":"常见的SQL优化","slug":"常见的SQL优化","date":"2018-10-01T12:14:00.000Z","updated":"2021-02-23T13:00:04.000Z","comments":true,"path":"2018/10/01/常见的SQL优化/","link":"","permalink":"https://super-aviator.github.io/2018/10/01/%E5%B8%B8%E8%A7%81%E7%9A%84SQL%E4%BC%98%E5%8C%96/","excerpt":"","text":"在使用sql语句对数据库中的数据进行操作时，相同功能的sql语句，采用不同的编写方式，执行的性能是不同的，既达性能不同的语句所达到的功能相同，那么就需要对性能差的sql语句进行优化了，优化分为两种重要的方式，即关于数据库索引的优化和sql语句的优化。 注意： 很多时候索引并不是最好的解决方案，对于数据量小的表，大部分情况下使用全局扫描更高效；对于中大型的表，索引就非常有效；对于特大型的表，建立和使用索引的代价将随之增长，这种情况情况下使用分区技术是最好的解决方案. 索引优化优化sql语句的非常重要的方式就是使用索引，索引是专门加快检索方式而建立的。创建语句为：CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name [USING index_type] ON table_name(index_col_name1[(pre_num)],...); 索引的类型mysql中有以下几种索引类型： 普通索引是最基本的索引，它没有任何限制 主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引 唯一索引与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一 组合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合 全文本索引主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用 MATCH (columnName) AGAINST (&#39;string&#39;) ，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多 前缀索引对索引字段的前N个字符创建索引 索引的数据结构（存储方式）索引是单独存储的，不同结构的索引使用的方式也不相同，mysql中有以下几种索引的存储方式 B-Tree索引常见的索引类型，大多数数据引擎都支持，使用B+树存储 HASH索引Memory/Heap引擎支持，使用hash表存储 使用=，&lt;=&gt;才会使用此索引 R-Tree（空间索引）MyISAM索引支持，很少使用 Full-text（全文本索引）MyISAM和高版本MySQL的InnoDB引擎支持 不同常用引擎支持的索引类型如下表： 索引 MyISAM引擎 InnoDB引擎 Memory引擎 B-Tree索引 支持（默认） 支持（默认） 支持 HASH索引 不支持 不支持 支持（默认） R-Tree索引 支持 不支持 不支持 Full-text索引 支持 支持 不支持 SQL语句中使用到索引的典型场景使用explain SLQ语句命令，查看结果中的key字段可以直到查询使用了哪个索引。 匹配全值在组合索引composite\\_index(col1,col2,col3)中，SQL语句中的where关键字后的条件对col1,col2,col3都进行精确匹配时，会使用到复合索引composite_index。例如SELECT * FROM table_name WHERE col1=1 AND col2=2 AND col3=3;’. 匹配值的范围查询在查询时，如果索引列中值进行范围查找，可以使用到索引，例如SELECT * FROM table_name WHERE col1&lt;10 AND col1&gt;20; 匹配最左前缀在组合索引composite\\_index(col1,col2,col3)中，where关键字后的列必须涉及到组合索引中最左边的列，例如：col1，col1+col2,col1+col3…;最左匹配原则是B-Tree索引最重要的使用原则。 仅仅对索引进行查询当select语句想要查询的列都是索引列时，查询的效率非常高，因为只需要扫描索引表而不用回表查询。 匹配列前缀对于前缀索引，使用索引列的前一部分进行查找也可以使用到索引，例如SELECT * FROMM table_name WHERE col1 LIKE &#39;name%&#39;;会使用到索引col1上的前缀索引。 能够实现索引匹配部分精确而其他部分进行范围匹配可以对索引列进行精确查询而非索引列进行范围查询来加快查询速度，例如SELECT * FROM table_name WHERE col1=1 AND col2&gt;100;使用到了col1上的索引。 如果列名是索引，那么使用column_name is null 就会使用索引对于索引列，使用IS NULL关键字也可以使用到索引，例如SELECT * FROM table_name WHERE col1 IS NULL; SQL语句中不会使用到索引的典型场景 以’%’开头的LIKE查询不会使用到B-Tree索引语句SELECT * FROM table_name WHERE col1 LIKE &#39;%ame%&#39;不会使用到col1上的B-Tree索引，因为使用了%开头。可以使用全文本索引（FullText）来解决。 数据类型出现隐式转换时不会使用到索引当数据类型在比较是发生隐式类型转换，也不会使用到索引，特别是字符串类型和其他类型的比较。例如SELECT * FROM table_name col1=1,由于col1是字符串类型，而1是整型，会发生隐式转换，不会使用到col1上的索引，而修改为SELECT * FROM table_name col1=&#39;1&#39;; 不满足最左匹配原则是不会使用到索引复合索引中不包含最左边的列，不会使用到索引。 如果MySQL预计到使用索引比全表扫描更慢则不会使用到索引例如语句SELECT * FROM table_name WHERE col1 LIKE &#39;N%&#39;查找所有N开头的行，MySQL判定使用索引比全表扫描更慢，则不使用索引。 使用or语句中，or前的列有索引而后面的列没有索引页不会用到索引对于WHERE中使用OR连接的查询条件，如果前面的列含有索引而后面的列没有索引，则不会使用到任何索引，因为后面的查询肯定要使用到全表扫描，所以依旧会使用全表扫描。 SQL语句的优化在mysql中，可以使用explain extended SQL语句命令然后执行show warning命令，来迅速获取一个更加清晰易读的sql语句，这是MySql优化过后的语句： 同时可以使用explain SQL语句查看key字段明确查询使用的索引类型等详细信息。","categories":[{"name":"Database","slug":"Database","permalink":"https://super-aviator.github.io/categories/Database/"}],"tags":[{"name":"数据库优化","slug":"数据库优化","permalink":"https://super-aviator.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"}],"author":"熊乾坤"},{"title":"HTTP中GET和POST区别（转）","slug":"TTP中GET和POST区别","date":"2018-10-01T06:44:00.000Z","updated":"2021-02-23T13:00:02.000Z","comments":true,"path":"2018/10/01/TTP中GET和POST区别/","link":"","permalink":"https://super-aviator.github.io/2018/10/01/TTP%E4%B8%ADGET%E5%92%8CPOST%E5%8C%BA%E5%88%AB/","excerpt":"","text":"原贴地址:http中的get和post 面试中，可能大家经常会被问到GET和POST的区别，但是每次问完后，大家都会感觉到自己知道一点，但是又不是完全知道，今天我就来完整的说一说。 GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。 最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。 自己以为的标准答案 GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST没有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。（本标准答案参考自w3schools） 以上可能是大部分面试者会给出的回答，但是假如面试官告诉你。(“很遗憾，这不是我们要的回答！”)是不是懵了，假如这时候面试官告诉你GET和POST本质上没有区别你信吗？(下面一节给出具体说明) GET和POST的本质GET和POST是什么？HTTP协议中的两种发送请求的方法。 HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。 HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 下面这两段话，是我在网上看到的一个比喻，感觉很好，分享一下: “在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。” “在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。” 说到这里:其实GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 最重要的区别GET产生一个TCP数据包；POST产生两个TCP数据包。 具体的说： 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据） 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？ GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。","categories":[{"name":"NetWork","slug":"NetWork","permalink":"https://super-aviator.github.io/categories/NetWork/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://super-aviator.github.io/tags/HTTP/"},{"name":"面试","slug":"面试","permalink":"https://super-aviator.github.io/tags/%E9%9D%A2%E8%AF%95/"}],"author":"熊乾坤"},{"title":"正则表达式匹配* .算法","slug":"正则表达式匹配-算法","date":"2018-09-29T14:22:00.000Z","updated":"2021-02-23T13:00:10.000Z","comments":true,"path":"2018/09/29/正则表达式匹配-算法/","link":"","permalink":"https://super-aviator.github.io/2018/09/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-%E7%AE%97%E6%B3%95/","excerpt":"","text":"在牛客网在线编程中有一道简单正则表达式的题目，在LeetCode中也有相应的习题，自己想了一个复杂的算法，问题描述如下： 问题描述请实现一个函数用来匹配包括.和*的正则表达式。模式中的字符.表示任意一个字符，而*表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但是与”aa.a”和”ab*a”均不匹配 解决思路看一下所有字符的所有可能的组合：.,字符,字符*,.*。将含有正则表达式的字符串称为模式字符串，待匹配字符串称为匹配字符串。 首先需要考虑到，如果对字符串从左到右匹配时，要解决的问题是，模式字符串中含有.*,并且最右边字符与匹配字符串部分相等的情况，例如:aaa和aa*a两个示例，由于模式字符串中a*能够匹配任意多个a字符，所以模式字符串可能会将最右边的字符a剩余下来，从而在影响后面对剩余模式字符串的合法性的判断，所以首先需要将两个字符串中最右边相等的字符删除。 然后应当设立两个指针i和j，一个指向匹配字符串(i)，另一个指向模式字符串(j)，在循环中，需要考虑两个指针所指向的字符是否相等。 如果i指向的字符与j指向的字符相等，则需要判断： j+1指向的字符是否为*,如果为*，则需要将i的位置加一，因为字符*组合能够匹配一个或多个相同的字符。 如果不相等，则需要将i和j都加一,继续匹配下一个字符。 如果i指向的字符与j指向的字符不相等，则需要判断： j指向的字符是否为.并且j+1是否为*，如果是，则可以直接跳出循环，直接检查剩余模式字符串是否合法，因为.*能够匹配任何字符组合，无论匹配字符串是任何字符。 如果j指向的字符为.,则将i和j都加一。因为.可以匹配任意一个字符。（这一步和上一步顺序不能交换） 如果j+1指向的字符为*,则需要直接将j加上2，y因为字符*能够匹配一个多个相同的字符。 如果上面两个条件都不满足，则说明i指向的字符与j指向的字符不相等，此时直接返回false。 在上面的循环后，肯定有一个字符串到达了末尾，如果匹配字符串没有达到末尾，则表明两个字符串不能匹配，直接返回false。 如果模式字符串没有到达末尾而匹配字符串达到了末尾，则需要对剩余的模式字符串进行检测： 如果是字符*的组合，则跳过所有字符*的组合 如果含有.则表明两个字符串不匹配，返回false 上面两个条件都不满足，则表明剩余的模式字符串中含有非法字符，直接返回false 最后，如果上面的步骤都没有返回，则表明两个字符串匹配，返回true; 代码实现 public static boolean match(char[] str, char[] pattern)&#123; int i=0,j=0,N1=str.length,N2=pattern.length; if(N1==0&amp;&amp;N2==0) return true; if(N1!=0&amp;&amp;N2!=0) //消除两个字符串末尾相同的字符 while(N1&gt;0&amp;&amp;N2&gt;0&amp;&amp;str[N1-1]==pattern[N2-1]) &#123;N1--;N2--;&#125; while(i&lt;N1&amp;&amp;j&lt;N2)&#123;//进行从左到右开始匹配 if(str[i]==pattern[j])&#123; //如果字母相等并且模式的字母后面有*，则i++,继续匹配下一个字符 if(j&lt;N2-1&amp;&amp;pattern[j+1]==&#39;*&#39;) i++; else &#123; i++;j++;&#125; //两个字符匹配，继续匹配下一个字符 &#125;else&#123; //.*能匹配任何字符，故直接跳出 if(pattern[j]==&#39;.&#39;&amp;&amp;j&lt;N2-1&amp;&amp;pattern[j+1]==&#39;*&#39;) &#123; i=N1;break; &#125; else if(pattern[j]==&#39;.&#39;) &#123; i++;j++; &#125; //如果模式为&#39;.&#39;,则匹配下一个字符 else if(j&lt;N2-1&amp;&amp;pattern[j+1]==&#39;*&#39;) j+=2; //跳过&#39;字母*&#39;的组合 else return false; //两个字符串不匹配 &#125; &#125; if (i != N1) return false; // 如果模式字符串匹配完而待匹配字符串没有匹配完，则返回false while(j&lt;N2) &#123; //处理剩余的模式字符串 if(j&lt;N2-1&amp;&amp;pattern[j+1]==&#39;*&#39;) j+=2; //跳过&#39;字母*&#39;的组合 else if(pattern[j]==&#39;.&#39;) return false; //剩余的模式包含&#39;.&#39;则两个字符串不匹配 else return false; //剩余有字符，则两个字符串不匹配 &#125; return true; &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://super-aviator.github.io/categories/Algorithm/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://super-aviator.github.io/tags/%E9%9D%A2%E8%AF%95/"}],"author":"熊乾坤"},{"title":"HashMap和HashTable异同（转）","slug":"HashMap和HashTable异同（转）","date":"2018-09-22T03:35:00.000Z","updated":"2021-02-23T13:00:08.000Z","comments":true,"path":"2018/09/22/HashMap和HashTable异同（转）/","link":"","permalink":"https://super-aviator.github.io/2018/09/22/HashMap%E5%92%8CHashTable%E5%BC%82%E5%90%8C%EF%BC%88%E8%BD%AC%EF%BC%89/","excerpt":"","text":"原文地址 概要学完了Map的全部内容，我们再回头开开Map的框架图。这里写图片描述 第1部分 Map概括(01) Map 是“键值对”映射的抽象接口。(02) AbstractMap 实现了Map中的绝大部分函数接口。它减少了“Map的实现类”的重复编码。(03) SortedMap 有序的“键值对”映射接口。(04) NavigableMap 是继承于SortedMap的，支持导航函数的接口。(05) HashMap, Hashtable, TreeMap, WeakHashMap这4个类是“键值对”映射的实现类。它们各有区别！ HashMap 是基于“拉链法”实现的散列表。一般用于单线程程序中。 Hashtable 也是基于“拉链法”实现的散列表。它一般用于多线程程序中。 WeakHashMap 也是基于“拉链法”实现的散列表，它一般也用于单线程程序中。相比HashMap，WeakHashMap中的键是“弱键”，当“弱键”被GC回收时，它对应的键值对也会被从WeakHashMap中删除；而HashMap中的键是强键。 TreeMap 是有序的散列表，它是通过红黑树实现的。它一般用于单线程中存储有序的映射。 第2部分 HashMap和Hashtable异同1部分 HashMap和Hashtable的相同点HashMap和Hashtable都是存储“键值对(key-value)”的散列表，而且都是采用拉链法实现的。 存储的思想都是：通过table数组存储，数组的每一个元素都是一个Entry；而一个Entry就是一个单向链表，Entry链表中的每一个节点就保存了key-value键值对数据。 添加key-value键值对：首先，根据key值计算出哈希值，再计算出数组索引(即，该key-value在table中的索引)。然后，根据数组索引找到Entry(即，单向链表)，再遍历单向链表，将key和链表中的每一个节点的key进行对比。若key已经存在Entry链表中，则用该value值取代旧的value值；若key不存在Entry链表中，则新建一个key-value节点，并将该节点插入Entry链表的表头位置。 删除key-value键值对：删除键值对，相比于“添加键值对”来说，简单很多。首先，还是根据key计算出哈希值，再计算出数组索引(即，该key-value在table中的索引)。然后，根据索引找出Entry(即，单向链表)。若节点key-value存在与链表Entry中，则删除链表中的节点即可。 上面介绍了HashMap和Hashtable的相同点。正是由于它们都是散列表，我们关注更多的是“它们的区别，以及它们分别适合在什么情况下使用”。那接下来，我们先看看它们的区别。 第2.2部分 HashMap和Hashtable的不同点1 继承和实现方式不同HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。 HashMap的定义: public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; ... &#125; Hashtable的定义: public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; ... &#125; 从中，我们可以看出： 1.1 HashMap和Hashtable都实现了Map、Cloneable、java.io.Serializable接口 实现了Map接口，意味着它们都支持key-value键值对操作。支持“添加key-value键值对”、“获取key”、“获取value”、“获取map大小”、“清空map”等基本的key-value键值对操作。 实现了Cloneable接口，意味着它能被克隆。 实现了java.io.Serializable接口，意味着它们支持序列化，能通过序列化去传输。 1.2 HashMap继承于AbstractMap，而Hashtable继承于Dictionary Dictionary是一个抽象类，它直接继承于Object类，没有实现任何接口。Dictionary类是JDK 1.0的引入的。虽然Dictionary也支持“添加key-value键值对”、“获取value”、“获取大小”等基本操作，但它的API函数比Map少；而且Dictionary一般是通过Enumeration(枚举类)去遍历，Map则是通过Iterator(迭代器)去遍历。 然而‘由于Hashtable也实现了Map接口，所以，它即支持Enumeration遍历，也支持Iterator遍历。关于这点，后面还会进一步说明。 AbstractMap是一个抽象类，它实现了Map接口的绝大部分API函数；为Map的具体实现类提供了极大的便利。它是JDK 1.2新增的类。 2 线程安全不同Hashtable的几乎所有函数都是同步的，即它是线程安全的，支持多线程。而HashMap的函数则是非同步的，它不是线程安全的。若要在多线程中使用HashMap，需要我们额外的进行同步处理。对HashMap的同步处理可以使用Collections类提供的synchronizedMap静态方法，或者直接使用JDK 5.0之后提供的java.util.concurrent包里的ConcurrentHashMap类。 3 对null值的处理不同HashMap的key、value都可以为null。Hashtable的key、value都不可以为null。 我们先看看HashMap和Hashtable “添加key-value”的方法HashMap的添加key-value的方法 1 // 将“key-value”添加到HashMap中 2 public V put(K key, V value) &#123; 3 // 若“key为null”，则将该键值对添加到table[0]中。 4 if (key == null) 5 return putForNullKey(value); 6 // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 7 int hash = hash(key.hashCode()); 8 int i = indexFor(hash, table.length); 9 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; 10 Object k; 11 // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ 12 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; 13 V oldValue = e.value; 14 e.value = value; 15 e.recordAccess(this); 16 return oldValue; 17 &#125; 18 &#125; 19 20 // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 21 modCount++; 22 addEntry(hash, key, value, i); 23 return null; 24 &#125; 25 26 // putForNullKey()的作用是将“key为null”键值对添加到table[0]位置 27 private V putForNullKey(V value) &#123; 28 for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; 29 if (e.key == null) &#123; 30 V oldValue = e.value; 31 e.value = value; 32 // recordAccess()函数什么也没有做 33 e.recordAccess(this); 34 return oldValue; 35 &#125; 36 &#125; 37 // 添加第1个“key为null”的元素都table中的时候，会执行到这里。 38 // 它的作用是将“设置table[0]的key为null，值为value”。 39 modCount++; 40 addEntry(0, null, value, 0); 41 return null; 42 &#125; Hashtable的添加key-value的方法 1 // 将“key-value”添加到Hashtable中 2 public synchronized V put(K key, V value) &#123; 3 // Hashtable中不能插入value为null的元素！！！ 4 if (value == null) &#123; 5 throw new NullPointerException(); 6 &#125; 7 8 // 若“Hashtable中已存在键为key的键值对”， 9 // 则用“新的value”替换“旧的value” 10 Entry tab[] = table; 11 // Hashtable中不能插入key为null的元素！！！ 12 // 否则，下面的语句会抛出异常！ 13 int hash = key.hashCode(); 14 int index = (hash &amp; 0x7FFFFFFF) % tab.length; 15 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; 16 if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; 17 V old = e.value; 18 e.value = value; 19 return old; 20 &#125; 21 &#125; 22 23 // 若“Hashtable中不存在键为key的键值对”， 24 // (01) 将“修改统计数”+1 25 modCount++; 26 // (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子) 27 // 则调整Hashtable的大小 28 if (count &gt;= threshold) &#123; 29 // Rehash the table if the threshold is exceeded 30 rehash(); 31 32 tab = table; 33 index = (hash &amp; 0x7FFFFFFF) % tab.length; 34 &#125; 35 36 // (03) 将“Hashtable中index”位置的Entry(链表)保存到e中 Entry&lt;K,V&gt; e = tab[index]; 37 // (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置” //并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。 38 tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); 39 // (05) 将“Hashtable的实际容量”+1 40 count++; 41 return null; 42 &#125; 根据上面的代码，我们可以看出： Hashtable的key或value，都不能为null！否则，会抛出异常NullPointerException。 HashMap的key、value都可以为null。 当HashMap的key为null时，HashMap会将其固定的插入table[0]位置(即HashMap散列表的第一个位置)；而且table[0]处只会容纳一个key为null的值，当有多个key为null的值插入的时候，table[0]会保留最后插入的value。 4 支持的遍历种类不同HashMap只支持Iterator(迭代器)遍历。而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。 Enumeration 是JDK 1.0添加的接口，只有hasMoreElements(), nextElement() 两个API接口，不能通过Enumeration()对元素进行修改 。而Iterator 是JDK 1.2才添加的接口，支持hasNext(), next(), remove() 三个API接口。HashMap也是JDK 1.2版本才添加的，所以用Iterator取代Enumeration，HashMap只支持Iterator遍历。 5 通过Iterator迭代器遍历时，遍历的顺序不同HashMap是“从前向后”的遍历数组；再对数组具体某一项对应的链表，从表头开始进行遍历。 Hashtabl是“从后往前”的遍历数组；再对数组具体某一项对应的链表，从表头开始进行遍历。 HashMap和Hashtable都实现Map接口，所以支持获取它们“key的集合”、“value的集合”、“key-value的集合”，然后通过Iterator对这些集合进行遍历。 由于“key的集合”、“value的集合”、“key-value的集合”的遍历原理都是一样的；下面，我以遍历“key-value的集合”来进行说明。 HashMap 和Hashtable 遍历”key-value集合”的方式是：(01) 通过entrySet()获取“Map.Entry集合”。 (02) 通过iterator()获取“Map.Entry集合”的迭代器，再进行遍历。 HashMap的实现方式：先“从前向后”的遍历数组；对数组具体某一项对应的链表，则从表头开始往后遍历。 1 // 返回“HashMap的Entry集合” 2 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; 3 return entrySet0(); 4 &#125; 5 // 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象 6 private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123; 7 Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet; 8 return es != null ? es : (entrySet = new EntrySet()); 9 &#125; 10 // EntrySet对应的集合 11 // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。 12 private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; 13 ... 14 public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; 15 return newEntryIterator(); 16 &#125; 17 ... 18 &#125; 19 // 返回一个“entry迭代器” 20 Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator() &#123; 21 return new EntryIterator(); 22 &#125; 23 // Entry的迭代器 24 private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; 25 public Map.Entry&lt;K,V&gt; next() &#123; 26 return nextEntry(); 27 &#125; 28 &#125; 29 private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; 30 // 下一个元素 31 Entry&lt;K,V&gt; next; 32 // expectedModCount用于实现fail-fast机制。 33 int expectedModCount; 34 // 当前索引 35 int index; 36 // 当前元素 37 Entry&lt;K,V&gt; current; 38 39 HashIterator() &#123; 40 expectedModCount = modCount; 41 if (size &gt; 0) &#123; // advance to first entry 42 Entry[] t = table; 43 // 将next指向table中第一个不为null的元素。 44 // 这里利用了index的初始值为0，从0开始向后遍历，直到找到不为null的元素就退出循环。 45 while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) 46 ; 47 &#125; 48 &#125; 49 50 public final boolean hasNext() &#123; 51 return next != null; 52 &#125; 53 54 // 获取下一个元素 55 final Entry&lt;K,V&gt; nextEntry() &#123; 56 if (modCount != expectedModCount) 57 throw new ConcurrentModificationException(); 58 Entry&lt;K,V&gt; e = next; 59 if (e == null) 60 throw new NoSuchElementException(); 61 62 // 注意！！！ 63 // 一个Entry就是一个单向链表 64 // 若该Entry的下一个节点不为空，就将next指向下一个节点; 65 // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。 66 if ((next = e.next) == null) &#123; 67 Entry[] t = table; 68 while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) 69 ; 70 &#125; 71 current = e; 72 return e; 73 &#125; 74 75 ... 76 &#125; Hashtable的实现方式：先从“后向往前”的遍历数组；对数组具体某一项对应的链表，则从表头开始往后遍历。 1 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; 2 if (entrySet==null) 3 entrySet = Collections.synchronizedSet(new EntrySet(), this); 4 return entrySet; 5 &#125; 6 7 private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; 8 public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; 9 return getIterator(ENTRIES); 10 &#125; 11 ... 12 &#125; 13 14 private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; &#123; 15 // 指向Hashtable的table 16 Entry[] table = Hashtable.this.table; 17 // Hashtable的总的大小 18 int index = table.length; 19 Entry&lt;K,V&gt; entry = null; 20 Entry&lt;K,V&gt; lastReturned = null; 21 int type; 22 23 // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志 24 // iterator为true，表示它是迭代器；否则，是枚举类。 25 boolean iterator; 26 27 // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。 28 protected int expectedModCount = modCount; 29 30 Enumerator(int type, boolean iterator) &#123; 31 this.type = type; 32 this.iterator = iterator; 33 &#125; 34 35 // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。 36 public boolean hasMoreElements() &#123; 37 Entry&lt;K,V&gt; e = entry; 38 int i = index; 39 Entry[] t = table; 40 /* Use locals for faster loop iteration */ 41 while (e == null &amp;&amp; i &gt; 0) &#123; 42 e = t[--i]; 43 &#125; 44 entry = e; 45 index = i; 46 return e != null; 47 &#125; 48 49 // 获取下一个元素 50 // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式” 51 // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。 52 // 然后，依次向后遍历单向链表Entry。 53 public T nextElement() &#123; 54 Entry&lt;K,V&gt; et = entry; 55 int i = index; 56 Entry[] t = table; 57 /* Use locals for faster loop iteration */ 58 while (et == null &amp;&amp; i &gt; 0) &#123; 59 et = t[--i]; 60 &#125; 61 entry = et; 62 index = i; 63 if (et != null) &#123; 64 Entry&lt;K,V&gt; e = lastReturned = entry; 65 entry = e.next; 66 return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e); 67 &#125; 68 throw new NoSuchElementException(&quot;Hashtable Enumerator&quot;); 69 &#125; 70 71 // 迭代器Iterator的判断是否存在下一个元素 72 // 实际上，它是调用的hasMoreElements() 73 public boolean hasNext() &#123; 74 return hasMoreElements(); 75 &#125; 76 77 // 迭代器获取下一个元素 78 // 实际上，它是调用的nextElement() 79 public T next() &#123; 80 if (modCount != expectedModCount) 81 throw new ConcurrentModificationException(); 82 return nextElement(); 83 &#125; 84 85 ... 86 87 &#125; 6 容量的初始值 和 增加方式都不一样HashMap默认的容量大小是16；增加容量时，每次将容量变为“原始容量x2”。 Hashtable默认的容量大小是11；增加容量时，每次将容量变为“原始容量x2 + 1”。 HashMap默认的“加载因子”是0.75, 默认的容量大小是16。 1 // 默认的初始容量是16，必须是2的幂。 2 static final int DEFAULT_INITIAL_CAPACITY = 16; 3 4 // 默认加载因子 5 static final float DEFAULT_LOAD_FACTOR = 0.75f; 6 7 // 指定“容量大小”的构造函数 8 public HashMap(int initialCapacity) &#123; 9 this(initialCapacity, DEFAULT_LOAD_FACTOR); 10 &#125; 当HashMap的 “实际容量” &gt;= “阈值”时，(阈值 = 总的容量 * 加载因子)，就将HashMap的容量翻倍。 1 // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 2 void addEntry(int hash, K key, V value, int bucketIndex) &#123; 3 // 保存“bucketIndex”位置的值到“e”中 4 Entry&lt;K,V&gt; e = table[bucketIndex]; 5 // 设置“bucketIndex”位置的元素为“新Entry”， 6 // 设置“e”为“新Entry的下一个节点” 7 table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); 8 // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小 9 if (size++ &gt;= threshold) 10 resize(2 * table.length); 11 &#125; Hashtable默认的“加载因子”是0.75, 默认的容量大小是11。 1 // 默认构造函数。 2 public Hashtable() &#123; 3 // 默认构造函数，指定的容量大小是11；加载因子是0.75 4 this(11, 0.75f); 5 &#125; 当Hashtable的 “实际容量” &gt;= “阈值”时，(阈值 = 总的容量 x 加载因子)，就将变为“原始容量x2 + 1”。 1 // 调整Hashtable的长度，将长度变成原来的(2倍+1) 2 // (01) 将“旧的Entry数组”赋值给一个临时变量。 3 // (02) 创建一个“新的Entry数组”，并赋值给“旧的Entry数组” 4 // (03) 将“Hashtable”中的全部元素依次添加到“新的Entry数组”中 5 protected void rehash() &#123; 6 int oldCapacity = table.length; 7 Entry[] oldMap = table; 8 9 int newCapacity = oldCapacity * 2 + 1; 10 Entry[] newMap = new Entry[newCapacity]; 11 12 modCount++; 13 threshold = (int)(newCapacity * loadFactor); 14 table = newMap; 15 16 for (int i = oldCapacity ; i-- &gt; 0 ;) &#123; 17 for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) &#123; 18 Entry&lt;K,V&gt; e = old; 19 old = old.next; 20 21 int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; 22 e.next = newMap[index]; 23 newMap[index] = e; 24 &#125; 25 &#125; 26 &#125; 7 添加key-value时的hash值算法不同HashMap添加元素时，是使用自定义的哈希算法。Hashtable没有自定义哈希算法，而直接采用的key的hashCode()。 HashMap添加元素时，是使用自定义的哈希算法。 1 static int hash(int h) &#123; 2 h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); 3 return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); 4 &#125; 5 6 // 将“key-value”添加到HashMap中 7 public V put(K key, V value) &#123; 8 // 若“key为null”，则将该键值对添加到table[0]中。 9 if (key == null) 10 return putForNullKey(value); 11 // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 12 int hash = hash(key.hashCode()); 13 int i = indexFor(hash, table.length); 14 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; 15 Object k; 16 // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ 17 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; 18 V oldValue = e.value; 19 e.value = value; 20 e.recordAccess(this); 21 return oldValue; 22 &#125; 23 &#125; 24 25 // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 26 modCount++; 27 addEntry(hash, key, value, i); 28 return null; 29 &#125; Hashtable没有自定义哈希算法，而直接采用的key的hashCode()。 1 public synchronized V put(K key, V value) &#123; 2 // Hashtable中不能插入value为null的元素！！！ 3 if (value == null) &#123; 4 throw new NullPointerException(); 5 &#125; 6 7 // 若“Hashtable中已存在键为key的键值对”， 8 // 则用“新的value”替换“旧的value” 9 Entry tab[] = table; 10 int hash = key.hashCode(); 11 int index = (hash &amp; 0x7FFFFFFF) % tab.length; 12 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; 13 if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; 14 V old = e.value; 15 e.value = value; 16 return old; 17 &#125; 18 &#125; 19 20 // 若“Hashtable中不存在键为key的键值对”， 21 // (01) 将“修改统计数”+1 22 modCount++; 23 // (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子) 24 // 则调整Hashtable的大小 25 if (count &gt;= threshold) &#123; 26 // Rehash the table if the threshold is exceeded 27 rehash(); 28 29 tab = table; 30 index = (hash &amp; 0x7FFFFFFF) % tab.length; 31 &#125; 32 33 // (03) 将“Hashtable中index”位置的Entry(链表)保存到e中 34 Entry&lt;K,V&gt; e = tab[index]; 35 // (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置” //并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。 36 tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); 37 // (05) 将“Hashtable的实际容量”+1 38 count++; 39 return null; 40 &#125; 8 部分API不同Hashtable支持contains(Object value)方法，而且重写了toString()方法；而HashMap不支持contains(Object value)方法，没有重写toString()方法。 最后，再说说“HashMap和Hashtable”使用的情景。其实，若了解它们之间的不同之处后，可以很容易的区分根据情况进行取舍。例如： 若在单线程中，我们往往会选择HashMap；而在多线程中，则会选择Hashtable。 若不能插入null元素，则选择Hashtable；否则，可以选择HashMap。 但这个不是绝对的标准。例如，在多线程中，我们可以自己对HashMap进行同步，也可以选择ConcurrentHashMap。当HashMap和Hashtable都不能满足自己的需求时，还可以考虑新定义一个类，继承或重新实现散列表；当然，一般情况下是不需要的了。 第3部分 HashMap和WeakHashMap异同3.1 HashMap和WeakHashMap的相同点1 它们都是散列表，存储的是“键值对”映射。2 它们都继承于AbstractMap，并且实现Map基础。3 它们的构造函数都一样。它们都包括4个构造函数，而且函数的参数都一样。4 默认的容量大小是16，默认的加载因子是0.75。5 它们的“键”和“值”都允许为null。6 它们都是“非同步的”。 3.2 HashMap和WeakHashMap的不同点1 HashMap实现了Cloneable和Serializable接口，而WeakHashMap没有。HashMap实现Cloneable，意味着它能通过clone()克隆自己。HashMap实现Serializable，意味着它支持序列化，能通过序列化去传输。 2 HashMap的“键”是“强引用(StrongReference)”，而WeakHashMap的键是“弱引用(WeakReference)”。WeakReference的“弱键”能实现WeakReference对“键值对”的动态回收。当“弱键”不再被使用到时，GC会回收它，WeakReference也会将“弱键”对应的键值对删除。这个“弱键”实现的动态回收“键值对”的原理呢？其实，通过WeakReference(弱引用)和ReferenceQueue(引用队列)实现的。 首先，我们需要了解WeakHashMap中： 第一，“键”是WeakReference，即key是弱键。第二，ReferenceQueue是一个引用队列，它是和WeakHashMap联合使用的。当弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 WeakHashMap中的ReferenceQueue是queue。第三，WeakHashMap是通过数组实现的，我们假设这个数组是table。 接下来，说说“动态回收”的步骤。 新建WeakHashMap，将“键值对”添加到WeakHashMap中。将“键值对”添加到WeakHashMap中时，添加的键都是弱键。实际上，WeakHashMap是通过数组table保存Entry(键值对)；每一个Entry实际上是一个单向链表，即Entry是键值对链表。 当某“弱键”不再被其它对象引用，并被GC回收时。在GC回收该“弱键”时，这个“弱键”也同时会被添加到queue队列中。例如，当我们在将“弱键”key添加到WeakHashMap之后；后来将key设为null。这时，便没有外部外部对象再引用该了key。接着，当Java虚拟机的GC回收内存时，会回收key的相关内存；同时，将key添加到queue队列中。 当下一次我们需要操作WeakHashMap时，会先同步table和queue。table中保存了全部的键值对，而queue中保存被GC回收的“弱键”；同步它们，就是删除table中被GC回收的“弱键”对应的键值对。 例如，当我们“读取WeakHashMap中的元素或获取WeakReference的大小时”，它会先同步table和queue，目的是“删除table中被GC回收的‘弱键’对应的键值对”。删除的方法就是逐个比较“table中元素的‘键’和queue中的‘键’”，若它们相当，则删除“table中的该键值对”。 3.3 HashMap和WeakHashMap的比较测试程序 1 import java.util.HashMap; 2 import java.util.Iterator; 3 import java.util.Map; 4 import java.util.WeakHashMap; 5 import java.util.Date; 6 import java.lang.ref.WeakReference; 7 8 /** 9 * @desc HashMap 和 WeakHashMap比较程序 10 * 11 * @author skywang 12 * @email kuiwu-wang@163.com 13 */ 14 public class CompareHashmapAndWeakhashmap &#123; 15 16 public static void main(String[] args) throws Exception &#123; 17 18 // 当“弱键”是String时，比较HashMap和WeakHashMap 19 compareWithString(); 20 // 当“弱键”是自定义类型时，比较HashMap和WeakHashMap 21 compareWithSelfClass(); 22 &#125; 23 24 /** 25 * 遍历map，并打印map的大小 26 */ 27 private static void iteratorAndCountMap(Map map) &#123; 28 // 遍历map 29 for (Iterator iter = map.entrySet().iterator(); 30 iter.hasNext(); ) &#123; 31 Map.Entry en = (Map.Entry)iter.next(); 32 System.out.printf(&quot;map entry : %s - %s\\n &quot;,en.getKey(), en.getValue()); 33 &#125; 34 35 // 打印HashMap的实际大小 36 System.out.printf(&quot; map size:%s\\n\\n&quot;, map.size()); 37 &#125; 38 39 /** 40 * 通过String对象测试HashMap和WeakHashMap 41 */ 42 private static void compareWithString() &#123; 43 // 新建4个String字符串 44 String w1 = new String(&quot;W1&quot;); 45 String w2 = new String(&quot;W2&quot;); 46 String h1 = new String(&quot;H1&quot;); 47 String h2 = new String(&quot;H2&quot;); 48 49 // 新建 WeakHashMap对象，并将w1,w2添加到 WeakHashMap中 50 Map wmap = new WeakHashMap(); 51 wmap.put(w1, &quot;w1&quot;); 52 wmap.put(w2, &quot;w2&quot;); 53 54 // 新建 HashMap对象，并将h1,h2添加到 WeakHashMap中 55 Map hmap = new HashMap(); 56 hmap.put(h1, &quot;h1&quot;); 57 hmap.put(h2, &quot;h2&quot;); 58 59 // 删除HashMap中的“h1”。 60 // 结果：删除“h1”之后，HashMap中只有 h2 ！ 61 hmap.remove(h1); 62 63 // 将WeakHashMap中的w1设置null，并执行gc()。系统会回收w1 64 // 结果：w1是“弱键”，被GC回收后，WeakHashMap中w1对应的键值对，也会被删除。 65 //w2是“弱键”，但它不是null，不会被GC回收；也就不会被从WeakHashMap中删除。 66 // 因此，WeakHashMap中只有 w2 67 // 注意：若去掉“w1=null” 或者“System.gc()”，结果都会不一样！ 68 w1 = null; 69 System.gc(); 70 71 // 遍历并打印HashMap的大小 72 System.out.printf(&quot; -- HashMap --\\n&quot;); 73 iteratorAndCountMap(hmap); 74 75 // 遍历并打印WeakHashMap的大小 76 System.out.printf(&quot; -- WeakHashMap --\\n&quot;); 77 iteratorAndCountMap(wmap); 78 &#125; 79 80 /** 81 * 通过自定义类测试HashMap和WeakHashMap 82 */ 83 private static void compareWithSelfClass() &#123; 84 // 新建4个自定义对象 85 Self s1 = new Self(10); 86 Self s2 = new Self(20); 87 Self s3 = new Self(30); 88 Self s4 = new Self(40); 89 90 // 新建 WeakHashMap对象，并将s1,s2添加到 WeakHashMap中 91 Map wmap = new WeakHashMap(); 92 wmap.put(s1, &quot;s1&quot;); 93 wmap.put(s2, &quot;s2&quot;); 94 95 // 新建 HashMap对象，并将s3,s4添加到 WeakHashMap中 96 Map hmap = new HashMap(); 97 hmap.put(s3, &quot;s3&quot;); 98 hmap.put(s4, &quot;s4&quot;); 99 100 // 删除HashMap中的s3。 101 // 结果：删除s3之后，HashMap中只有 s4 ！ 102 hmap.remove(s3); 103 104 // 将WeakHashMap中的s1设置null，并执行gc()。系统会回收w1 105 // 结果：s1是“弱键”，被GC回收后，WeakHashMap中s1对应的键值对，也会被删除 106 // w2是“弱键”，但它不是null，不会被GC回收；也就不会被从WeakHashMap中删除。 107 // 因此，WeakHashMap中只有 s2 108 // 注意：若去掉“s1=null” 或者“System.gc()”，结果都会不一样！ 109 s1 = null; 110 System.gc(); 111 112 /* 113 // 休眠500ms 114 try &#123; 115 Thread.sleep(500); 116 &#125; catch (InterruptedException e) &#123; 117 e.printStackTrace(); 118 &#125; 119 // */ 120 121 // 遍历并打印HashMap的大小 122 System.out.printf(&quot; -- Self-def HashMap --\\n&quot;); 123 iteratorAndCountMap(hmap); 124 125 // 遍历并打印WeakHashMap的大小 126 System.out.printf(&quot; -- Self-def WeakHashMap --\\n&quot;); 127 iteratorAndCountMap(wmap); 128 &#125; 129 130 private static class Self &#123; 131 int id; 132 133 public Self(int id) &#123; 134 this.id = id; 135 &#125; 136 137 // 覆盖finalize()方法 138 // 在GC回收时会被执行 139 protected void finalize() throws Throwable &#123; 140 super.finalize(); 141 System.out.printf(&quot;GC Self: id=%d addr=0x%s)\\n&quot;, id, this); 142 &#125; 143 &#125; 144 &#125; 运行结果： -- HashMap -- map entry : H2 - h2 map size:1 -- WeakHashMap -- map entry : W2 - w2 map size:1 -- Self-def HashMap -- map entry : CompareHashmapAndWeakhashmap$Self@1ff9dc36 - s4 map size:1 -- Self-def WeakHashMap -- GC Self: id=10 addr=0xCompareHashmapAndWeakhashmap$Self@12276af2) map entry : CompareHashmapAndWeakhashmap$Self@59de3f2d - s2 map size:1","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://super-aviator.github.io/tags/%E9%9D%A2%E8%AF%95/"}],"author":"熊乾坤"},{"title":"设计模式-外观(Facade)模式和最少知识原则","slug":"计模式-外观-Facade-模式","date":"2018-09-18T00:00:00.000Z","updated":"2021-02-23T13:00:04.000Z","comments":true,"path":"2018/09/18/计模式-外观-Facade-模式/","link":"","permalink":"https://super-aviator.github.io/2018/09/18/%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82-Facade-%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"想象一下（真的也就是想象一下T_T），你拥有一些台式机的组件，如果自己想要组装一套电脑，那么你就要将cpu，风扇，显卡，硬盘，内存条等零件一件一件的插到主板上来进行组装，非常的繁琐，如果此时你将零件给电脑维修店，让他们为你组装，这样就使装配变得简单，组装电脑的一系列固定的动作交给电脑维修店的员工完成，达到一键组装的效果,这就是外观设计模式，用于简化接口，将一些复杂的动作隐藏在背后，只显露出一个干净美好的外观。 外观模式的定义 外观模式 提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。 外观设计模式的类图如下： 客户端通过外观类，可以轻松的对子系统中的类进行操纵。通过外观设计模式，简化了客户端的使用。 外观模式的例子对于一套已经拥有的家庭音影系统，如果你需要看一部电影，你需要做如下的操作： screen.up()://打开显示器 light.down();//关灯 ... //其他的操作 dvd.play();//播放电影 在看一部电影时，需要做许多的准备工作，非常的繁琐，那通过外观类，可以将这些操作封装到一个类中，对外提供方法来对操作进行一次性的执行： public class HomeTheaterFacade &#123; private Screen screen; private Light light; private DvdPlayer dvd; public HomeTheater(Screen screen, Light light, DvdPlayer dvd) &#123; this.screen = screen; this.light = light; this.dvd = dvd; &#125; public void watchMovie()&#123; screen.up();//打开屏幕 light.down();//关灯 dvd.play();//播放电影 &#125; public static void main(String[] args)&#123; HomeTheaterFacade homeTheaterFacade=new HomeTheaterFacade(); homeTheaterFacade.wacthMovie(); &#125; &#125; 最少知识原则 最少知识 只与你的密友交谈 意思是说，在设计中，不要让太多的类耦合在一起，免得牵一发而动全身，如果多个类之间相互依赖，系统就会变得难以维护。 如何做到最少知识原则，有以下几个原则，在对象方法的内部，我们应该调用属于任意一下范围的对象的方法： 该对象本身 被当做参数传进来的对象 此方法内部创建的对象 对象的任何组件（成员变量） 对于下面的代码： 方式一public float getTemp()&#123; return station.getThrermometer().getTemperature(); &#125; 方式二public float getTemp()&#123; return station.getTemperature(); &#125; 方式一中的方法getTemp()首先从气象站获得温度计，然后从温度计对象中获得温度，在使用了最少知识原则后，在气象站中直接添加了getTemperature()方法，避免了访问Thrermnmeter对象。 最少知识原则的应用在GenericServlet中，组合了ServletConfig对象，为了访问到ServletConfig对象中的ServletContext对象，GenerciServlet提供了直接访问ServletContext对象的方法。","categories":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://super-aviator.github.io/categories/DesignPattern/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://super-aviator.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"熊乾坤"},{"title":"设计模式-适配器(Adapter)模式","slug":"设计模式-适配器-Adapter-模式","date":"2018-09-17T23:59:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2018/09/18/设计模式-适配器-Adapter-模式/","link":"","permalink":"https://super-aviator.github.io/2018/09/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8-Adapter-%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"在日常生活中，常常可以看见一种手机充电器的转换器，可以把三口的充电器插头转换为两口的充电器插口，这个转换器就是今天的主角：适配器。 编程中，对于两个不兼容的接口，一个接口由厂商提供，一个接口由客户提供，此时就需要提供一个适配器，将厂商接口转换为用户接口。 适配器模式定义 适配器模式 将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作。 适配器模式进行接口的转换，让不兼容的接口变得兼容，还可以让客户从厂商接口解耦，一段时间之后，如果厂商接口发生改动，适配器可以将改动进行封装。 适配器类图如下所示： 由于适配器类组合了被适配者的接口，所以适配器类可以适配被适配接口的任何子类，比较灵活。 适配器类的实例假设有一个鸭子类（Dcuk）接口，拥有两个方法,quack()(呱呱叫)和fly()(飞翔): public interface Duck &#123; void quack(); void fly(); &#125; 还有一个火鸡类，可以咯咯叫和短距离飞行,其接口如下所示： public interface Turkey &#123; void gobble(); void fly(); &#125; 假设此时需要一个鸭子，但是手里此时只有一个火鸡，那么就需要使用火鸡来冒充鸭子，我们需要创建一个适配器将火鸡适配到鸭子，那么，写一个适配器吧： public class TurkeyAdapter implements Duck &#123; private Turkey turkey; public TurkeyAdapter(Turkey turkey) &#123; this.turkey = turkey; &#125; @Override public void quack() &#123; turkey.gobble(); &#125; @Override public void fly() &#123; turkey.fly(); &#125; &#125; 需要注意的是，火鸡适配器类实现的的接口是想要转换的类型的接口，即客户端接口，而组合的接口是想要被适配的类型，即厂商的接口。 对适配器进行测试,首先创建一个火鸡接口的实现类： public class TurkeyTemp implements Turkey &#123; @Override public void gobble() &#123; System.out.println(&quot;TurkeyTemp gobble&quot;); &#125; @Override public void fly() &#123; System.out.println(&quot;TurkeyTemp fly&quot;); &#125; &#125; 然后创建火鸡适配器并进行测试： public class TurkeyAdapterTest &#123; public static void main(String[] args) &#123; TurkeyTemp turkeyTemp=new TurkeyTemp(); TurkeyAdapter turkeyAdapter=new TurkeyAdapter(turkeyTemp); turkeyAdapter.quack(); turkeyAdapter.fly(); &#125; &#125; //output TurkeyTemp gobble TurkeyTemp fly 如上，我们在测试类中调用的是鸭子才有的方法，而得到的确实火鸡的行为，即客户与被适配者(厂商)是解耦的，客户不需要知道被适配者的具体实现。 类适配器和对象适配器上面介绍的适配器被称为对象适配器，还有一种适配器称为类是类适配器，类适配器不使用组合的方式而是使用继承的方式，适配器类继承了客户类和厂商类，由于Java中不支持多继承，所以在Java中不能实现类适配器。 类类适配器没有对象适配器灵活，因为继承将适配器与被适配者绑定。","categories":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://super-aviator.github.io/categories/DesignPattern/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://super-aviator.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"熊乾坤"},{"title":"GET和POST请求Spring中文乱码问题","slug":"Spring中中文乱码问题","date":"2018-09-17T00:15:00.000Z","updated":"2021-02-23T13:00:12.000Z","comments":true,"path":"2018/09/17/Spring中中文乱码问题/","link":"","permalink":"https://super-aviator.github.io/2018/09/17/Spring%E4%B8%AD%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"参考博客对于POST请求，在@Controller注解的控制器中，可以使用@ResponseBody注解直接返回一个字符串，但是存在字符编码的问题。在得到的字符串中的中文全部是？表示。其解决的办法如下： POST请求的乱码原因因为在方法中我们返回的是字符串，所以Spring在通过AnnotationMethodHandlerAdapter去寻找对应的HttpMessageConverter时，会找到StringHttpMessageConverter，通过查看源码得知，该类的默认编码格式是 ISO-8859-1，部分源码如下： public class StringHttpMessageConverter extends AbstractHttpMessageConverter &lt;String&gt;&#123; public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;ISO-8859-1&quot;); private final Charset defaultCharset; private final List&lt;Charset&gt; availableCharsets; private boolean writeAcceptCharset = true; /** * A default constructor that uses &quot;ISO-8859-1&quot; as the default charset. * * @see #StringHttpMessageConverter(Charset) */ public StringHttpMessageConverter() &#123; this(DEFAULT_CHARSET); &#125; /** * A constructor accepting a default charset to use if the requested * content * type does not specify one. */ public StringHttpMessageConverter(Charset defaultCharset) &#123; super(new MediaType(&quot;text&quot;, &quot;plain&quot;, defaultCharset), MediaType.ALL); this.defaultCharset = defaultCharset; this.availableCharsets = new ArrayList&lt;Charset&gt; (Charset.availableCharsets().values()); &#125; POST请求中文乱码的解决办法使用xml配置文件（推荐使用）在 spring mvc 配置文件中，添加如下配置： &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 说明：其实是指定 StringHttpMessageConverter 类构造函数的参数值为 UTF-8，该方法对代码侵入性低，且一劳永逸，故推荐！ 使用注解的方式在 @RequestMapping 中添加 produces 字段，如下： @RequestMapping(value = “/xxxx.do”, produces = “text/html;charset=UTF-8”) 但是此方法需要为每一个返回String字符串的Controller控制器添加此字段，所以比较繁琐。 使用HttpServletResponse采用原始的做法，在方法中，增加 HttpServletResponse 参数，然后由 HttpServletResponse 对象输出回复内容，如下： @RequestMapping(value = &quot;/xxxx.do&quot;) @ResponseBody public String fetchFlowPackage(@RequestParam(required = true) String param, HttpServletResponse response) &#123; response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setContentType(&quot;text/html;charset=UTF-8&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); try &#123; PrintWriter out = null; out = response.getWriter(); out.write(&quot;回复的内容xxxx&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; GET请求中文乱码的解决办法以上解决方法都是针对POST请求的，而对于GET请求尝试过很多办法：修改TOMCAT配置文件、@ResponseBody中使用注解、使用Filter等等都没有解决乱码问题，因为GET请求不经过StringHttpMessageConverter进行转换，需要使用增加HTTP头部的方式进行转码,而如果使用Filter进行头部的添加，一劳永逸，结果试了一下也没有结局问题，而在网上的扫地僧的回复中得知: filter是请求到达前做一次处理，请求完成后再做一次处理，而httpResponse.setCharacterEncoding(encoding); // encoding为utf-8httpResponse.setContentType(&quot;text/html; charset=utf-8&quot;); 必须在请求处理完成前设置才能有效的，所以用filter是不行的。 我想到的解决办法是在Controller中使用HttpServletResponse对象直接写入String，代码如下： @Controller @RequestMapping(value = &quot;/user-info&quot;) public class GetUserInfo &#123; @RequestMapping(method = RequestMethod. GET ) public void getUserInfo(@RequestParam(&quot;id&quot;) long id, HttpServletResponse response) throws IOException &#123; response.setContentType(&quot;text/html;charset=UTF-8&quot;);//写入头部 response.setCharacterEncoding(&quot;UTF-8&quot;);//设置编码格式，必须在请求处理完成前设置才有效 try &#123; String result = new UserDAOImp().getUserInfo(id, 0); System.out.println(result); response.getWriter().write(result); &#125; catch (Exception e) &#123; e.printStackTrace(); response .getWriter().write(new UserDAOImp().getUserInfo(id, 1)); &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://super-aviator.github.io/tags/Spring/"}],"author":"熊乾坤"},{"title":"跨域请求问题及其解决方法","slug":"跨域请求问题及其解决方法","date":"2018-09-15T23:47:00.000Z","updated":"2021-02-23T12:59:58.000Z","comments":true,"path":"2018/09/16/跨域请求问题及其解决方法/","link":"","permalink":"https://super-aviator.github.io/2018/09/16/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"参考地址 参考地址 参考地址昨天在对以前的小小小小项目使用Mybatis+Spring进行重写时，依旧是遇到了跨域访问的问题，记得以前的解决方法是在HttpServletResponse中添加头部Access-Control-Allow-Origin，其值为*，在使用Spring时却不知道怎么去做了，在百度了一下别人的博客之后，发现可以通过过滤器来为每一个Response添加头部来实现跨域访问或者使用xml配置文件的方式解决。 问题描述JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。这里把涉及到跨域的一些问题简单地整理一下： 首先什么是跨域，简单地理解就是因为JavaScript同源策略的限制，同域的概念又是什么呢?_? 简单的解释就是相同域名,端口相同,协议相同,也就是说a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。更详细的说明可以看下表： 如果是协议和端口造成的跨域问题“前台”是无能为力的， 在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。 后端的解决办法一、注解方式推荐这种方法，简单快捷，但Spring版本需要4.2以上，只需在spring-context.xml文件中添加如下配置即可，然后初始化时扫描这个文件 &lt;!-- 解决跨域请求问题，spring版本需4.2以上 --&gt; &lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/**/**&quot; allowed-origins=&quot;*&quot; allowed-methods=&quot;POST, GET, OPTIONS, DELETE, PUT&quot; allowed-headers=&quot;Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With&quot; allow-credentials=&quot;true&quot; /&gt; &lt;/mvc:cors&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:config/spring-*.xml &lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 二、拦截器方式这种方法需要实现 Filter的doFilter方法，如下，即在web.xml文件中添加过滤器的配置，其中“ssm.util.filter.CORSFilter”是CORSFilter的引用位置 public class CORSFilter implements Filter &#123; @Override public void init(FilterConfig var1) throws ServletException &#123;&#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletResponse response = (HttpServletResponse) servletResponse; response.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); filterChain.doFilter(servletRequest, servletResponse); &#125; public void destroy() &#123;&#125; &#125; &lt;!--解决跨域访问--&gt; &lt;!--在web.xml中声明过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;CORSFilter&lt;/filter-name&gt; &lt;filter-class&gt;ssm.util.filter.CORSFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CORSFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Java Web","slug":"Java-Web","permalink":"https://super-aviator.github.io/tags/Java-Web/"}],"author":"熊乾坤"},{"title":"对象的构造过程","slug":"继承结构中对象的构造顺序‘’","date":"2018-09-08T07:07:00.000Z","updated":"2021-02-23T13:00:04.000Z","comments":true,"path":"2018/09/08/继承结构中对象的构造顺序‘’/","link":"","permalink":"https://super-aviator.github.io/2018/09/08/%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F%E2%80%98%E2%80%99/","excerpt":"","text":"前几天在网上看到一个博客写了阿里的一个基础的面试题，考的是继承中构造器的加载顺序和多态的知识，自己不会做，所以我结合了《Thinking in java》和看过的一点点虚拟机知识，对这个题进行了如下总结 类的加载过程中的初始化在类加载过程中，主要分为以下几个步骤： 加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载 类的加载过程只会执行静态初始化，其中重要的步骤如下所述： 首先，在访问类的静态成员或者静态方法（包括构造器方法）后，如果这个类还没有被虚拟机加载，虚拟机则会在classpath中查找这个类的class文件并将其加载到虚拟机内存中，其过程涉及到上面的步骤。 在对class文件进行加载和验证之后，重要的是在准备阶段，在准备阶段会为类变量（static修饰的变量）分配内存，并为类变量分配零值，所以static int i=20 , i此时为0 ，声明为static final的变量在这个阶段会直接赋值为所设定值而不是零值。所以static fianl int i=20在此时i直接赋值为20。 然后在初始化阶段，会执行静态初始化，会对静态初始化块和类变量赋值为指定的值，如static int i=20,此时i为20。 单个对象的创建过程与类加载过程不同的是，对象的创建需要进行实例初始化，而不仅仅只进行静态初始化。其总的过程在《Thinking in java》中总结如下： 显式的调用静态字段或者方法，java解释器会查找类路径，定位类的class文件 加载类.class文件，执行上面所说的静态初始化，并且只会在class文件加载时进行一次。 当使用new关键字创建对象时，首先为对象在对上分配足够的存储空间。 这片存储空间会被清空,即自动为实例变量设置零值。 执行所有出现于字段定义出的初始化动作,即将实例变量初始化为所设置的值 执行构造器。 java会保证实例变量和类变量在构造器执行之前都已经被初始化 继承结构中对象的创建过程在继承结构中，创建导出类的对象时，在调用导出类的构造器之前，会执行以下几个步骤： 首先会调用基类的构造器，在调用基类构造器之前，按声明的顺序初始化基类的实例成员，这个步骤会不断的反复递归下去，直到到达最底层的类。 按声明的顺序初始化导出类的实例成员。 执行导出类构造器。 java保证超类构造器和导出类字段会在导出类构造器调用者之前初始化。 举一个例子如下: public class Test &#123; public static void main(String[] args) &#123; new Sub(); &#125; &#125; class Temp &#123; public Temp(String meg) &#123; System.out.println(&quot;Temp(&quot;+meg+&quot;)&quot;); &#125; &#125; class Sub extends Super &#123; Temp t = new Temp(&quot;Sub&quot;); public Sub() &#123; super(); System.out.println(&quot;Sub()&quot;); &#125; &#125; class Super &#123; Temp t=new Temp(&quot;Super&quot;); public Super() &#123; System.out.println(&quot;Super()&quot;); &#125; &#125; 输出结果为： Temp(Super) Super() Temp(Sub) Sub() 结果验证了我们上面的总结。 阿里面试题题目如下： package com.test; public class DispatchTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Base b=null; //此处如果 换成 Sub b=null，则b.x=40;不再是20 b=new Sub(); System.out.println(b.x); &#125; static class Base &#123; int x =10; public Base()&#123; this.printMessage(); x=20; &#125; public void printMessage()&#123; System.out.println(&quot;Base.x=&quot;+x); &#125; &#125; static class Sub extends Base&#123; int x =30; public Sub()&#123; super();//此处的super()；去掉也可以，默认执行super(); //而且只能在构造函数的第一行，如果放在其他行，编译错误， this.printMessage(); x=40; &#125; public void printMessage()&#123; System.out.println(&quot;Sub.x=&quot;+x); &#125; &#125; &#125; 输出结果是： Sub.x=0 Sub.x=30 20 其具体解释如下： 在执行new Sub()时，会为Sub对象创建存储空间并为实例变量i赋予零值0。 然后首先调用超类的构造器，因为超类构造器会在导出类的实例变量初始化和构造函数调用之前调用，在执行Base超类的构造器时，使用了this关键字，注意这里的this并不是超类的this而是导出类的this（通过增加this.getClass().getName()方法可以看到结果）,这是因为非静态方法调用的等价调用方式为类名.方法名(this,参数)其中this参数便是调用此方法的引用，所以这时调用this.printMessage();实际是调用导出类的printMessage(),但此时i在导出类中还没有执行初始化，所以会输出Sub.x=0。 执行17行，基类的x被设置为20。 根据我们总结的规则，调用基类构造器之后，会对导出类进行初始化，那么会执行28行，导出类x被设置为30。 此时，会执行基类构造器，第一行基类构造器已经被执行，则继续执行33行，打印出Sub.x=30。 继续执行34行导出类的x被设置为40，此时对象b构造完毕。 最后在第9行，因为b进行了向上转型，有多态的属性，但是java中只有方法访问是多态的，而域访问和静态方法访问并不是多态的，所以b.x会打印b的基类对象的x值：20而不是导出类对象的x：40。","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://super-aviator.github.io/tags/%E9%9D%A2%E8%AF%95/"}],"author":"熊乾坤"},{"title":"Spring-编写控制器","slug":"Spring-编写控制器","date":"2018-09-06T04:30:00.000Z","updated":"2021-02-23T13:00:02.000Z","comments":true,"path":"2018/09/06/Spring-编写控制器/","link":"","permalink":"https://super-aviator.github.io/2018/09/06/Spring-%E7%BC%96%E5%86%99%E6%8E%A7%E5%88%B6%E5%99%A8/","excerpt":"","text":"在前一节完成了SpringMVC框架的搭建，接下来就是非常重要的控制器的编写了，和HttpServlet一样，控制器负责进行业务逻辑的处理，并产生需要的数据模型和视图。控制器就是使用@Controller注解标示的类，由于在配置类WebConfig中开启了组件扫描，所以所有的控制器都会被Spring自动发现。 编写控制器如下就是一个最简单的控制器 package spring_mvc.spittr.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import static org.springframework.web.bind.annotation.RequestMethod.GET; //定义一个控制器 @Controller //指定映射 @RequestMapping(&#123;&quot;/home&quot;,&quot;/homepage&quot;&#125;) public class HomeController &#123; //指定方法 @RequestMapping(method = GET) public String home()&#123; //System.out.println(&quot;Home Controller&quot;); return &quot;home&quot;; &#125; &#125; @RequestMapping 注解默认会映射所有的HTTP请求方法。如果仅想接收某种请求方法，请在注解中指定 @RequestMapping(method=GET) 以缩小范围。 在上面的代码中，在类级别上使用RequestMapping(&#123;&quot;/home&quot;,&quot;/homepage&quot;&#125;)注解来声明控制器所处理的url路径，需要注意的是可以指定两个路径；在方法上，使用方法级别的RequestMapping(method = GET)解来声明http方法为get时调用此方法。当然，也可以在方法上使用RequestMapping(value=&#123;&quot;/home&quot;,&quot;/homepage&quot;&#125;,method=GET)指定方法的映射以及对应的方法。 上面的方法中，返回了名为home的视图，由于我们配置了视图解析器，所以会在配置的视图文件夹中进行查找home.jsp视图。 下面的测试代码都在HomeController类中编写。 在控制器中返回模型因为控制器在处理完请求之后，可能会返回一些数据模型和视图名给DispatcherServlet，DispatcherServlet将其转发给视图解析器进行解析，所以如果在控制器中需要返回模型要怎么实现呢？其方法如下所示： import org.springframework.ui.Model; import static org.springframework.web.bind.annotation.RequestMethod.GET; @RequestMapping(method= GET) public String spittles(Model model)&#123; List&lt;Spittle&gt; list=sp.findSpittles(Long.MAX_VALUE,20); model.addAttribute(&quot;SpittleList&quot;,list); return &quot;spittles&quot;; &#125; 在上面的方法中，传递了Model类型的参数，并将想要存入模型的数据使用addAttribute方法存入到模型中，也可以使用java。util包中的Map进行存放： import static org.springframework.web.bind.annotation.RequestMethod.GET; @RequestMapping(method= GET) public String spittles(Map map)&#123; List&lt;Spittle&gt; list=sp.findSpittles(Long.MAX_VALUE,20); model.put(&quot;SpittleList&quot;,list); return &quot;spittles&quot;; &#125; 因为Model实际上就是一个Map,所以两种方式的作用相同，它们都会传递数据给视图。 接受客户端的请求在web网页中，常常进行一些点击和提交，这时，就会将数据发送到web服务器，此时，就需要服务器去接受客户端提交的数据来进行处理，常用的有三种方式进行接受客户端的输入，下面依次进行学习。 通过查询参数接受输入在url中，有一个字段为查询字段，它用于向服务器传输键值对的数据，格式如http://localhost:8080/home?username=xqk&amp;password=123,这样，就把参数username=xqk,password=123传递给了服务器。服务器端可以使用如下代码进行获取： @RequestMapping(method= GET) public String spittles(//获取查询参数 @RequestParam(&quot;id&quot; ) long id, @RequestParam(&quot;name&quot;) String name )&#123; System.out.println(id+&quot;:&quot;+name); return &quot;spittles&quot;;//返回视图逻辑名 &#125; &#125; 如果想要在参数不存在时指定默认值，可以使用defaultValue进行指定： @RequestMapping(method= GET) public String spittles(//获取查询参数 @RequestParam(value = &quot;id&quot; , defaultValue =&quot;20&quot;) long id, @RequestParam(value = &quot;name&quot; ,defaultValue = &quot;xqk&quot;) String name )&#123; System.out.println(id+&quot;:&quot;+name); return &quot;spittles&quot;;//返回视图逻辑名 &#125; 需要注意的是，defaultValue需要写成字符串的形式，Spring会将其自动转换成所需的数据格式。 通过路径参数接受输入路径参数又叫URL模板,在上面的方式中，如果只向服务器传入一个id参数服务器根据id参数查询资源，那么使用查询字段的方式获取数据服务器则会捕获http://localhost:8080/home?id=123类型的url,但是正规的资源访问应该是使用形如http://localhost:8080/home/123这样的路径参数进行查询而不是查询参数进行，这时就是通过路径参数的方式进行接收客户端输入，其实现方式如下； @RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.GET) public String spittles( @PathVariable(&quot;id&quot;) long SpittleId )&#123; System.out.println(SpittleId); return &quot;spittles&quot;; &#125; 上面的代码中，id是一个占位符，当url为http://localhost:8080/home/123时，id的值便是123，不管路径参数是什么，都会传递到id中去。 同时，一个方法可以拥有任意数量的 @PathVariable 注解： @RequestMapping(path = &quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;&quot;,method = RequestMethod.GET) public String findPet(@PathVariable String ownerId,@PathVariable String petId, Model model) &#123; Owner owner = ownerService.findOwner(ownerId); Pet pet = owner.getPet(petId); model.addAttribute(&quot;pet&quot;, pet); return &quot;displayPet&quot;; &#125; &#125; URI模板可以从类级别和方法级别的 @RequestMapping 注解获取数据。因此，像这样 的 findPet() 方法可以被类似于 /owners/42/pets/21 这样的URL路由并调用到： @Controller @RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;) public class RelativePathUriTemplateController &#123; @RequestMapping(&quot;/pets/&#123;petId&#125;&quot;) public void findPet( @PathVariable String ownerId, @PathVariable String petId, Model model) &#123; // 方法实现体这里忽略 &#125; &#125; 有时候你可能需要更准确地描述一个URI模板的变量，比如说这个URL： &quot;/springweb/spring-web-3.0.5.jar 。你要怎么把它分解成几个有意义的部分呢？@RequestMapping 注解支持你在URI模板变量中使用正则表达式。语法是 &#123;varName:regex&#125; ，其中第一部分定义了变量名，第二部分就是你所要应用的正则表达式。比如下面的代码样 例： @RequestMapping(&quot;/spring-web/&#123;symbolicName:[a-z-]+&#125;-&#123;version:\\\\d\\\\.\\\\d\\\\.\\\\d&#125; &#123;extensio n:\\\\.[a-z]+&#125;&quot;) public void handle(@PathVariable String version, @PathVariable String extension) &#123; // 代码部分省略... &#125; &#125; 通过表单参数接受输入在注册或者其他提交大量的信息时，就会使用到表单，在Spring中提供了处理表单的非常便捷的方式，来将数据封装成POJO。例如，有如下的表单： &lt;form method=&quot;POST&quot;&gt; First Name: &lt;input type=&quot;text&quot; name=&quot;firstName&quot;/&gt; &lt;br/&gt; Last Name:&lt;input type=&quot;text&quot; name=&quot;lastName&quot;/&gt; &lt;br/&gt; Username:&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;br/&gt; Password:&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;Register&quot;/&gt; &lt;/form&gt; 我们在服务端只需要编写一个POJO,Spring会自动将表单中数据按照名称匹配封装进POJO中，如下所示。Spitter类： package spring_mvc.spittr.pojo; import java.io.UnsupportedEncodingException; import java.nio.charset.Charset; public class Spitter &#123; private String firstName; private String lastName; private String username; private String password; public Spitter ()&#123;&#125; //使用setter方法进行初始化，转码 public void setFirstName(String firstName) throws UnsupportedEncodingException &#123; this.firstName = new String(firstName.getBytes(&quot;iso-8859-1&quot;), &quot;utf-8&quot; ); &#125; public void setLastName(String lastName) throws UnsupportedEncodingException &#123; this.lastName = new String(lastName.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot; ); &#125; public void setUsername(String username) throws UnsupportedEncodingException &#123; this.username = new String(username.getBytes(&quot;iso-8859-1&quot;) , &quot;utf-8&quot; ); &#125; public void setPassword(String password) throws UnsupportedEncodingException &#123; this.password = new String(password.getBytes(&quot;iso-8859-1&quot;) , &quot;utf-8&quot;); &#125; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125; public String getUsername() &#123; return username; &#125; public String getPassword() &#123; return password; &#125; &#125; 需要注意的是，http协议默认使用的编码为iso-8859-1,在POJO中需要对其进行转码。 接下来就是处理表单的方法： @RequestMapping(value = &quot;/register&quot;, method = POST) public String processRegister(Spitter spitter)&#123; System.out.println(&quot;get a spitter:&quot;); System.out.println(spitter.getFirstName()); System.out.println(spitter.getLastName()); System.out.println(spitter.getUsername()); System.out.println(spitter.getPassword()); return &quot;redirect:/home/&quot;+spitter.getUsername(); &#125; 上面的方法中，将method设置为POST,然后方法参数直接设置为Siptter对象，Spring会自动按照字段名匹配将数据包装进spitter对象。 值得一提的是，在方法返回的字符串中，使用了重定向&quot;redirect:/spitter/&quot;+spitter.getUsername(),Spring会自动识别redirect:并进行转发。 验证表单数据在使用表单参数接受到客户端提交的数据之后，如果对数据不进行验证或者手动进行验证都是有缺陷或者繁琐的行为，Spring中提供了数据校验的API，可以退表单数据进行编码非常简单的验证，需要给项目添加依赖javax.validation，如下为API列表： 注解 描述 @AssertFalse 所注解的元素必须为boolean类型，并且值为false @AssertTrue 所注解的元素必须为boolean类型，并且值为true @DecimalMax 所注解的元素必须为数字，并且值要小于或等于给定的BigDecimalString值 @DecimalMin 所注解的元素必须为数字，并且值要大于或等于给定的BigDecimalString值 @Digits 所注解的元素必须为数字，并且它的值必须有指定的位数 @Future 所注解的元素必须为一个将来的日期 @Max 所注解的元素必须为数字，并且值要小于或等于给定的值 @Min 所注解的元素必须为数字，并且值要大于或等于给定的值 @NotNull 所注解的元素不能为null @Null 所注解的元素必须为null @Past 所注解的元素的值必须是一个已过去的日期 @Pattern 所注解的元素必须匹配给定的正则表达式 @Size 所注解的元素必须是String、数组、集合，并且长度在给定范围内 例如，如下是使用表单验证的POJO： public class Spitter &#123; @NotNull //非空 @Size(min=5,max=16)//必须为字符串，长度从5到16个 private String firstName; @NotNull @Size(min=10,max=16) private String lastName; @NotNull @Size(min=6,max=10) private String username; @NotNull @Size(min=5,max=16) private String password; 接下来需要修改处理注册的方法来应用校验功能： @RequestMapping(value = &quot;/register&quot;, method = POST) public String processRegister( @Valid Spitter spitter, Errors errors)&#123; if(errors.hasErrors())//如果表单验证不通过，则重定向到注册页面 return &quot;redirect:/registerForm&quot;; System.out.println(&quot;get a spitter:&quot;); System.out.println(spitter.getFirstName()); System.out.println(spitter.getLastName()); System.out.println(spitter.getUsername()); System.out.println(spitter.getPassword()); return &quot;redirect:/spitter/&quot;+spitter.getUsername(); //return &quot;registerForm&quot;; &#125; 需要注意的是，Errors参数必须要紧跟在带有@Valid注解的参数后面，@Valid注解所标注的就是要验证的参数。在方法中，第一步必须要确定表单验证是否有错误，如果有错误就需要重新进行注册。 返回JSON格式的数据如今的web应用中，已经使用了前后端分离的模式进行开发，后端的开发人员不在需要接触到前端页面，而是将数据以JSON的格式进行封装，然后发送给前端，前端在得到JSON数据后进行渲染。下面要学习的就是在Spring中发送JSON格式的数据。 返回单个对象的JSON数据在Spring中可以使用@ResponseBody直接返回一简单的个对象，然后Spring将自动会自动为我们打包为对象，在开始之前，需要导入依赖： &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;20140107&lt;/version&gt; &lt;/dependency&gt; 然后在方法中加入@ResponseBody注解： @RequestMapping(value = &quot;/json&quot;, method = GET) public @ResponseBody Spitter getSpitter() throws UnsupportedEncodingException &#123; System.out.println(&quot;get a json&quot;); Spitter s = new Spitter(); s.setFirstName(&quot;xqk&quot;); s.setLastName(&quot;df&quot;); s.setPassword(&quot;234&quot;); s.setUsername(&quot;fefdsfa&quot;); return s; &#125; 上面的方法中返回了一个对象Spitter,Spring会将其解析成JSON的格式，如下： 返回多个对象的JSON数据返回多个对象可以使用阿里巴巴公司开源的类库FASTJSON,据说是java中处理JSON速度最快的库，使用也非常简单，只需利用JSONArray对象，就可以简单的返回多个对象的JSON数据： @RequestMapping(method= RequestMethod.GET) @ResponseBody public String getSpitter() throws Exception&#123; HashMap map=new HashMap(); Spitter s1=new Spitter(); s1.setFirstName(&quot;xqk123&quot;); s1.setLastName(&quot;df&quot;); s1.setPassword(&quot;234&quot;); s1.setUsername(&quot;fefdsfa&quot;); Spitter s2 = new Spitter(); s2.setFirstName(&quot;xqk123&quot;); s2.setLastName(&quot;df&quot;); s2.setPassword(&quot;234&quot;); s2.setUsername(&quot;fefdsfa&quot;); map.put(&quot;s1&quot;,s1); map.put(&quot;s2&quot;,s2); JSONArray array=new JSONArray().fluentAdd(s1); array.fluentAdd(s2); return array.toJSONString(); &#125; &#125; 浏览器端显示如下；","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Java Web","slug":"Java-Web","permalink":"https://super-aviator.github.io/tags/Java-Web/"},{"name":"Spring","slug":"Spring","permalink":"https://super-aviator.github.io/tags/Spring/"}],"author":"熊乾坤"},{"title":"Spring-SpringMVC的框架搭建","slug":"ng-基于java的Spring-MVC配置","date":"2018-09-06T02:07:00.000Z","updated":"2021-02-23T13:00:04.000Z","comments":true,"path":"2018/09/06/ng-基于java的Spring-MVC配置/","link":"","permalink":"https://super-aviator.github.io/2018/09/06/ng-%E5%9F%BA%E4%BA%8Ejava%E7%9A%84Spring-MVC%E9%85%8D%E7%BD%AE/","excerpt":"","text":"在Web应用中，使用的较多的就是SpringMVC框架，MVC分别代表Model-View-Controller，本节就来学习一下Spring MVC框架的最基本的搭建过程。 SpringMVC的请求跟踪如上为请求在web服务器中的处理流程，其分为一下几个步骤： 请求会首先到达前端控制器，Spring中前端控制器为DispatcherServlet,DispatcherServlet负责查询处理器映射并将请求转发给对应的控制器，是请求进入Web服务器最早接触到的组件。 前端控制器查找处理器映射，查找到请求对应的控制器。 控制器会解析请求中的数据，进行业务处理，将需要返回给浏览器的数据打包为模型,并返回一个视图逻辑名。 前端控制器将得到的模块和视图名转发给视图解析器，视图解析器根据视图名和包含数据的模型构造出视图,并返回给前端控制器。 最后前端控制器将视图返回给浏览器进行显示。 搭建SpringMVCSpringMVC中最重要的就是配置DispatcherServlet，因为DispathcerServlet是请求接触到的第一个组件，并且它负责将请求路由到其他的组件中去，所以非常重要，DispatcherServlet 其实就是个 Servlet （它继承自 HttpServlet 基类），如下是配置DispatcherServlet的代码： package spring_mvc.spittr.config; import org.springframework.web.servlet.support. AbstractAnnotationConfigDispatcherServletInitializer; import javax.servlet.MultipartConfigElement; import javax.servlet.ServletRegistration; //定义DispatcherServlet类 public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; //加载ContextLoaderListener应用上下文 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;RootConfig.class&#125;; &#125; //加载DispatcherServlet应用上下文 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;WebConfig.class&#125;; &#125; //定义DispatcherServlet的映射 @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125; &#125; 如果一个类继承自AbstractAnnotationConfigDispatcherServletInitializer(不用数了，一共只有6个单词T_T)，则Spring会加载这个类作为DispatcherServlet的配置类。关于这个类的解析请看下面的说明： Servlet3.0会查找javax.servlet.ServletContainerInitializer接口作为DispatcherServlet的配置类，Spring提供了这个接口来的基本实现：SpringServletContainerInitializer,而这个类会查找WebApplicationInitializer来进行配置，Spring3.2引入了WebApplicationInitializer的基础实现，也就是AbstractAnnotationConfigDispatcherServletInitializer，当部署到Servlet3.0时，容器会自动加载它并用来来配置Spring应用上下文。 getServletMappings()方法指明了DispatcherServlet类映射到根路径”/“，即所有的请求都由此DispatcherServlet来处理。 在Sring中有两个应用上下文，一个是DispatcherServlet加载时创建的Spring应用上下文，它负责加载SpringMVC中的组件，例如视图解析器、控制器等。另外一个是有ContextLoaderListener监听器加载时创建的上下文，他负责加载其他的非MVC的Spring bean。 在上面的代码中，getServletConfigClasses()方法指定DispatcherServlet的配置类， getServletMappings()方法指定ContextLoaderListener的配置类，接下来看看两个类如何进行配置。 WebConfig的配置类： import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.test.context.ContextConfiguration; import org.springframework.web.servlet.ViewResolver; import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer; import org.springframework.web.servlet.config.annotation.EnableWebMvc; import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter; import org.springframework.web.servlet.view.InternalResourceViewResolver; import spring_mvc.spittr.interfaces.SpittleRepository; import spring_mvc.spittr.pojo.SpittleRepositoryImp; @Configuration @EnableWebMvc @ComponentScan(basePackages = &quot;spring_mvc.spittr&quot;) public class WebConfig extends WebMvcConfigurerAdapter&#123; //配置静态资源处理器 @Override public void configureDefaultServletHandling( DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125; //配置视图解析器 @Bean public ViewResolver viewResolver()&#123; InternalResourceViewResolver resolver=new InternalResourceViewResolver(); resolver.setPrefix(&quot;/WEB-INF/views/&quot;); resolver.setSuffix(&quot;.jsp&quot;); resolver.setExposeContextBeansAsAttributes(true); return resolver; &#125; &#125; 首先，使用@Configuration注解来将其申明为配置类，并使用@ComponentScan注解来开启组件扫描，来查找我们的@Controller注解标注的控制器，使用@EnableWebMvc注解开启SpringMVC。在使用xml配置时，需要使用&lt;mvc:annotation-driven /&gt;来开启SpringMVC并引入xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;。 在上面的代码中，配置了一个视图解析器，并设置了前缀和后缀，指明要查找的视图的路径和后缀，当得到视图名时，会和已经配置的前缀和后缀组合得到所需的视图。 因为我们的DispatcherServlet会处理所有的请求，包括图片和其他资源的加载，这并不是我们想要的，我们要将图片或其他静态资源设置交给其他处理器，所以我们将WebConfig继承了WebMvcConfigurerAdapter类，并覆盖configureDefaultServletHandling方法，并使用参数的enable()方法配置了静态资源的默认处理器。 RootConfig类： import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.FilterType; import org.springframework.web.servlet.config.annotation.EnableWebMvc; import spring_mvc.spittr.interfaces.SpittleRepository; import spring_mvc.spittr.pojo.SpittleRepositoryImp; @Configuration @ComponentScan(basePackages = &quot;spring_mvc.spittr&quot;, excludeFilters = &#123; @ComponentScan.Filter(type= FilterType.ANNOTATION,value = EnableWebMvc.class) &#125;) public class RootConfig &#123; &#125; RootConfig类比较简单，需要注意的是，所有与SpringMVC组件无关的bean都可以在这个配置类中进行显式的创建。 如上就使用java的方式完成了SpringMVC框架的最简单的搭建。 使用xml文件搭建SpringMVC框架在老项目中，会使用到基于xml的Spring配置，所以还是要学习滴。 纯xml配置在项目的web.xml配置文件中配置ClassLoadListener和DispatcherServlet: &lt;!--定义根应用上下文--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/root-context.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--定义ClassLoadListener--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--定义DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;application&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--定义DispatcherServlet映射路径--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;application&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 我们知道，ClassLoadListener和DispatcherServlet各自都会加载一个应用上下文，前者加载非mvc组件的bean，后者加载mvc组件的bean，上面配置中的根应用上下文由ClassLoadListener加载，DispatcherServlet则会在/WEB-INF/路径下自动找到servlet名字-servlet.xml的配置文件，也就是/WEB-INF/application-servlet.xml文件。 如果想要自定义DispatcherServlet的配置问价路径，则需要加上contextConfigLocation的初始化参数，即使用下面的配置： &lt;servlet&gt; &lt;servlet-name&gt;application&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--定义contextConfigLocation的初始化参数--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;application-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 注意：上面的&lt;init-param&gt;必须放到&lt;load-on-startup&gt;标签之上。 xml加上java类混合配置如果我们希望从xml文件中配置，ClassLoadListener和DispatcherServlet,然后从java类中加载应用上下文而不是xml文件中加载,即从带有@Configuration注解的类中加载配置，这时就是xml加上java类的混合配置。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;context-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt;org.springframework.web.context.support. AnnotationConfigWebApplicationContext&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--定义根应用上下文--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.spring.mvc.RootConfig&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--定义ClassLoadListener--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--定义DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;application&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt;org.springframework.web.context.support .AnnotationConfigWebApplicationContext&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--定义contextConfigLocation的初始化参数--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.spring.mvc.WebConfig&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--定义DispatcherServlet映射路径--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;application&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 上面的配置类中，如果需要使用混合配置，则需要首先加上AnnotationConfigWebApplicationContext的context-param和init-param的参数，然后将contextConfigLocation标签的配置路径指向含有@Configuration的java配置类。","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Java Web","slug":"Java-Web","permalink":"https://super-aviator.github.io/tags/Java-Web/"},{"name":"Spring","slug":"Spring","permalink":"https://super-aviator.github.io/tags/Spring/"}],"author":"熊乾坤"},{"title":"设计模式-单例(Singleton)模式","slug":"设计模式-单例-Singleton-模式","date":"2018-09-05T11:57:00.000Z","updated":"2021-02-23T13:00:10.000Z","comments":true,"path":"2018/09/05/设计模式-单例-Singleton-模式/","link":"","permalink":"https://super-aviator.github.io/2018/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B-Singleton-%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"在编程时，对于一些敏感的资源，我们需要限制类的对象的个数为一个，例如电视机的遥控器，Mybatis中的SqlSessionFactory对象等，此时就需要使用单例设计模式，虽然不是常常使用单例模式，但是依旧值得我们深入研究。 值得一提的是，可能有人会觉得使用静态全局变量可以替换单例模式，其实使用静态全局变量的这种方式是有缺点的，例如，全局变量需要在程序一开始就创建好对象，万一这个对象非常消耗资源，而程序在执行过程中又一直没有用到它，这就形成资源的浪费。 单例模式定义单例模式定义如下： 确保一个类只有一个实例，并提供一个全局访问点。 常用的单例模式模板常见的单例模式如下，此方式也叫作懒汉模式，是指在getInstance()方法运行时才会创建我们的单例对象： public class Singleton &#123; private static Singleton instance; private Singleton() &#123; &#125; public Singleton getInstance() &#123; if (instance == null) instance = new Singleton(); return instance; &#125; &#125; 如上的代码中，我们有一个静态的全局变量instance,并将构造器设置为private修饰的，然后提供一个访问instance的唯一方法getInstance()，在getInstance()中，首次判断instance为空，则会创建一个唯一的对象，第二次调用getInstance()方法时，则直接返回已经创建的instance。 注意，当处于多线程时，上面的方法可能会得到多个Singleton实例，例如，线程一调用getInstance()方法并进行判断，在此时线程二同样调用getInstance()方法并进行判断，由于这时都没有创建Singleton实例，所以instance都判断为空，两个线程会同时创建Singleton对象，此时也就是拥有了两个Singleton实例。 使用同步方法解决多线程问题可以对getInstance()方法进行同步来解决多线程问题，对方法使用synchronized关键字修饰可以防止两个线程同时执行同一个方法，从而解决线程中的同步问题： public class Singleton &#123; private Singleton instance; private Singleton() &#123; &#125; public synchronized Singleton getInstance() &#123; if (instance == null) instance = new Singleton(); return instance; &#125; &#125; 但是对方法进行同步的解决方案也是有缺陷的，因为同步一个方法会使程序执行效率下降100倍，而且我们只需要在第一次运行getInstance()方法时才需要同步，以后调用getInstance()不需要进行同步，但是上面的代码中每次调用都会进行同步，势必会造成性能损失。 使用急切实例化解决多线程问题急切实例化也叫作饿汉模式，其实现方式和懒汉模式类似，只是将创建单例对象的时间提前到类加载的时候，而省去getInstance()方法中的对引用为null的判断。 public class Singleton &#123; private Singleton instance=new Singleton(); private Singleton() &#123; &#125; public Singleton getInstance() &#123; return instance; &#125; &#125; 因为在类加载时就创建了单例对象，所以就不存在线程同步的问题。但是在单例对象创建非常消耗资源，而程序在执行过程中又一直没有用到它时，这就形成资源的浪费。 使用双重检查加锁解决多线程问题还可以使用一种更加高级的方式解决多线程中的同步问题，这就是双重检查加锁的方式，其实现如下: public class Singleton &#123; private volatile Singleton instance; private Singleton() &#123; &#125; public Singleton getInstance() &#123; if (instance == null)&#123; synchronized(Singleton.class)&#123; if(instance==null) instance=new Singleton(); &#125; &#125; return instance; &#125; &#125; 上面的代码中，首先将instance引用设置为volatile，这是为了解决可视性问题，然后在getInstance()方法中，首先对instance引用进行判空，如果为空，则进入同步快中，再次判空，如果此时依旧为空，则创建单例对象，在第二次调用时，就不会再次进入同步块中，也就解决了性能的问题。 上面的代码中，使用volatile关键字的原因是，当两个方法同时准备进入同步块时，会有一个进程阻塞，另外一个进程进入，然后进入的同步块的线程将会创建单例对象，然后退出进程同步块，然后另外一个线程进入同步块，如果不将其设置为volatile，后进入的线程会看不到已经被创建的单例对象，就会再次创建一个对象，也就无法达到单例的效果，并获得两个单例对象。 使用静态内部类可以使用静态内部类来实现单例模式，静态内部类在初次调用时才会进行初始化，可以避免饿汉模式资源浪费问题，而且由于是静态成员，所以可以防止并发的同步问题： public class Singleton&#123; private Singleton()&#123;&#125; private static class SingletonInnerClass&#123; private static Singleton instance=new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonInnerClass.instance; &#125; &#125;","categories":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://super-aviator.github.io/categories/DesignPattern/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://super-aviator.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"熊乾坤"},{"title":"Spring-bean高级装配","slug":"Spring-bean高级装配","date":"2018-09-02T12:45:00.000Z","updated":"2021-02-23T13:00:00.000Z","comments":true,"path":"2018/09/02/Spring-bean高级装配/","link":"","permalink":"https://super-aviator.github.io/2018/09/02/Spring-bean%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D/","excerpt":"","text":"在学习了基本的装配bean的方式之后，接下来就是bean高级装配的知识了，包括了Spring profile,条件化创建bean,自动装配与歧义性，bean作用域，SpringEL表达式等。 Spring Profile在项目的开发，测试，生产环境中，相同类型的bean的创建方式有时并不相同，我们必须要有一种方法来在不同的环境下创建不相同的bean。这就是Spring Profile所应用的地方，可以在自动装配，java类配置以及xml中使用Spring Profile条件化配置bean的产生方式，只需要加上@Profile注解即可，需要注意的是，没有任何@Profile注解的bean始终都会被创建，不管激活那个Profile 如下所示： 使用@Profile注解 自动装配方式使用Profile注解 @Component @Profile(&quot;dev&quot;)//设置此bean的对应的Profile为开发环境 public class PrintWorldProfileBean implements ProfileBean &#123; private String title; public PrintWorldProfileBean(String title)&#123; title=title; &#125; @Override public void doWork() &#123; System.out.println(&quot;World&quot;); &#125; &#125; 在java类配置方式中使用Profile @Configuration @ComponentScan(basePackageClasses = &#123;PrintWorldProfileBean.class&#125;) @Profile(&quot;dev&quot;)//类级别的注解 public class ProfileBeanConfig &#123; @Bean @Profile(&#123;&quot;beta &quot;,&quot;dev&quot;&#125;) //配置在测试和开发环境中都有效 @Profile(&quot;beta&quot;)//测试环境 public PrintHelloProfileBean getPrintHelloProfileBean()&#123; return new PrintHelloProfileBean(); &#125; @Bean @Profile(&quot;dev&quot;)//生产环境 public PrintWorldProfileBean getPrintWorldProfileBean()&#123; return new PrintWorldProfileBean(); &#125; &#125; 基于java类配置的方式可以使用类级别或者方法级别的Profile注解。 基于xml文件的配置方式使用Profile &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/springbeans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开发环境的Profile--&gt; &lt;beans profile=&quot;dev&quot;&gt; &lt;bean id=&quot;printHelloProfileBean&quot; class=&quot;chapter3.profile.PrintHelloProfileBean&quot; /&gt; &lt;/beans&gt; &lt;!--生产环境的Profile--&gt; &lt;beans profile=&quot;beta&quot;&gt; &lt;bean id=&quot;printWorldProfileBean&quot; class=&quot;chapter3.profile.PrintWorldProfileBean&quot; /&gt; &lt;/beans&gt; &lt;/beans&gt; xml中使用Profile必须在&lt;beans&gt;元素的profile属性中使用。 激活ProfileSpring中要确定那个profile处于激活状态，依赖于两个独立的属性，spring.profiles.active和spring.profiles.default,首先查找spring.profiles.active，如果没有设置，则查找spring.profiles.default，如果都没有设置，则没有激活profile。 激活有几种方法，《Spring in action》作者推荐了一种激活profile的方式，如下所示： 在DispatcherServlet中配置激活的Profile &lt;servlet&gt; &lt;servlet-name&gt;scdp-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 在ContextLoaderListener中激活Profile &lt;context-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/context-param&gt; 如果使用javaConfig配置的话，则在AbstractAnnotationConfigDispatcherServletInitializer的子类里 重写onStartup方法，如下： @Override public void onStartup(ServletContext servletContext) throws ServletException &#123; super.onStartup(servletContext); servletContext.setInitParameter(&quot;spring.profiles.active&quot;, &quot;live&quot;); //Set multiple active profile //servletContext.setInitParameter(&quot;spring.profiles.active&quot;, &quot;dev, testdb&quot;); &#125; 亦或是重写createRootApplicationContext方法，在context创建时将环境变量传入： //如果RootApplicationContext需要加载带有@Profile的bean时， 例如spring的ApplicationContext配置类 @Override protected WebApplicationContext createRootApplicationContext() &#123; WebApplicationContext context = (WebApplicationContext)super.createRootApplicationContext(); ((ConfigurableEnvironment)context.getEnvironment()).setActiveProfiles(&quot;live&quot;); //Set multiple active profiles //((ConfigurableEnvironment)context.getEnvironment()) // .setActiveProfiles(new String[]&#123;&quot;live&quot;, &quot;testdb&quot;&#125;); return context; &#125; //如果ServletApplicationContext需要加载带有@Profile的bean时，例如springMVC的配置类 /* @Override protected WebApplicationContext createServletApplicationContext() &#123; WebApplicationContext context = (WebApplicationContext)super.createServletApplicationContext(); ((ConfigurableEnvironment)context.getEnvironment()).setActiveProfiles(&quot;dev&quot;); return context; &#125;*/ Conditional 条件化的bean有时需要通过确认某一个环境变量存在时才创建特定的bean，此时需要使用@Conditional注解来实现，他可以用到@Bean注解的方法上，如果给定的条件计算结果为ture,则创建这个bean,为false则不创建这个bean。使用方法如下： import org.springframework.context.annotation.*; @Configuration public class ProfileBeanConfig &#123; @Bean @Conditional(MagicExistsCondition.class)//条件化的bean public PrintHelloProfileBean getPrintHelloProfileBean()&#123; return new PrintHelloProfileBean(); &#125; @Bean public PrintWorldProfileBean getPrintWorldProfileBean()&#123; return new PrintWorldProfileBean(); &#125; &#125; 设置给@Conditional的类需要实现Condition接口，并通过接口中matches方法返回值来决定是否创建此bean了，如果为true则创建bean,为false则不创建 import org.springframework.context.annotation.Condition; import org.springframework.context.annotation.ConditionContext; import org.springframework.core.type.AnnotatedTypeMetadata; public class MagicExistsCondition implements Condition &#123; @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; return true; &#125; &#125; 当然也可以通过ConditionContext 和AnnotatedTypeMetadata 参数进行更加详细的判断。 处理自动装配的歧义性在一个接口对应有多个相同的bean时，使用自动装配将产生歧义，Spring并不知道我们是否需要装配哪个bean,就是抛出异常NoUniqueBeanDefinitionException,例如： @Component public class Cake implements Dessert&#123;&#125; @Component public class Cookie implements Dessert&#123;&#125; @Component public class IceCream implements Dessert&#123;&#125; 如果在装配时，如下的代码会产生歧义： @Autowired public void setDessert(Dessert dessert)&#123; this.dessert=dessert; &#125; 当产生歧义时，就需要明确告诉Spring当装配遇到歧义时需要首选某个bean或者使用限定符将可选范围缩小到只有一个bean。 使用@Primary解决装配歧义@Primary注解可以和@Component或者@Bean一起使用,或者xml中&lt;bean&gt;元素的primary属性也可以达到相同的效果，它告诉Spring当遇到装配歧义时首选此bean. @@Component @Primary public class Cake implements Dessert&#123;&#125; @Bean @Primary public Dessert getDessert()&#123; return new Cake(); &#125; xml中使用primary属性： &lt;beans &gt; &lt;bean id=&quot;cake&quot; class=&quot;chapter3.qualifier.Cake&quot; primary=&quot;true&quot; /&gt; &lt;/beans&gt; 使用限定符@Qualifier解决装配歧义Spring中还可以使用@Qualifier注解来使用限定符解决装配歧义。，它比@Primary功能更加强大。在@Component注解或者@Bean注解中，可以使用@Qualifier给bean设定限定符，注意，如果不显式的为bean设定限定符，则Spring会自动赋予bean一个与ID相同的限定符，如下所示： 与@Component配合使用 package chapter3.qualifier; import chapter3.interfaces.Dessert; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Component; @Component @Qualifier(&quot;HappyBirthday&quot;)//设置Bean的限定符 public class Cookies implements Dessert &#123; &#125; 与@Bean配合使用 package chapter3.qualifier; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class QualifierConfig &#123; @Bean @Qualifier(&quot;iceCream&quot;) public IceCream getIceCream()&#123; return new IceCream(); &#125; &#125; 在为bean设置限定符之后，在装配时就需要使用@Qualifier注解指明想要装配的bean的限定符: package chapter3.qualifier; import chapter3.interfaces.Dessert; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes=QualifierConfig.class) public class QualifierTest &#123; @Autowired //@Inject @Qualifier(&quot;HappyBirthday&quot;)//使用限定符来装配指定的Bean private Dessert d; @Test public void test()&#123; System.out.println(d.getClass().getName()); &#125; &#125; bean作用域Spring 中bean有四种作用域： 单例(singleton) 在整个web应用的生命周期中，只创建一个bean的实例 (默认作用域) 原型(prototype) 没次注入或者通过Spring应用上下文获取时，都创建一个实例 会话(session)web应用中每个会话创建一次 请求(request)web应用中每一请求创建一次 要指定一个bean的作用域，可以在@Bean或者@Component注解下使用@Scope来指定bean作用域，可以使用常量或者字符串两种方式： 自动装配 package chapter3.qualifier; import chapter3.interfaces.Dessert; import org.springframework.context.annotation.Scope; import org.springframework.context.annotation.ScopedProxyMode; import org.springframework.stereotype.Component; import org.springframework.web.context.WebApplicationContext; @Component @Scope(&quot;prototype&quot;) @Scope(configurableBeanFactory.SCOPE_PROTOTYPE) public class Cake implements Dessert &#123; &#125; javaConfig类 package chapter3.qualifier; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Scope; import org.springframework.context.annotation.ScopedProxyMode; import org.springframework.web.context.WebApplicationContext; @Configuration public class QualifierConfig &#123; @Bean @Scope(&quot;prototype&quot;) @Scope(configurableBeanFactory.SCOPE_PROTOTYPE) public Cake getCake()&#123; return new Cake(); &#125; &#125; 在xml配置的方式中，可以使用&lt;bean&gt;元素的scope属性进行设置： &lt;bean id=&quot;cake&quot; class=&quot;chapter3.qualifier.Cake&quot; scope=&quot;session&quot; /&gt; 会话和请求两个特殊的作用域如果要将一个会话或者请求作用域的bean注入到一个单例模式的bean中，就会出现问题，比如说，ShoppingCart为商城中的购物车，为会话作用域，而StorageService为保存购物车的内容，为单例模式，我们需要将一个ShoppingCart的bean注入到StorageService中去，如下所示： @Component public class StoreService&#123; ShoppingCart cart; @AutoWired public viod setShoppingCart(ShoppingCart cart)&#123; this.cart=cart; &#125; &#125; 上面的代码中，由于ShoppingCart是会话或者请求作用域，在某些时刻，由于没有请求到来，也就没有对应的ShoppingCart来注入到StoreService中去，并且每一个请求所对应的ShoppingCart都是不同的，所以Spring会在StoreService中注入一个代理，如果想要调用 ShoppingCart的方法，就会通过代理来进行访问。 代理分为两种，如果ShoppingCart是一个类，Spring就需要生成一个基于类的代理，如果ShoppingCart是一个接口，Spring就需要生成一个基于接口的代理。其两种设置方式如下： package chapter3.qualifier; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Scope; import org.springframework.context.annotation.ScopedProxyMode; import org.springframework.web.context.WebApplicationContext; @Configuration public class QualifierConfig &#123; @Bean //基于类的代理 @Scope( value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS ) public Cake getCake()&#123; return new Cake(); &#125; &#125; package chapter3.qualifier; import chapter3.interfaces.Dessert; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Scope; import org.springframework.context.annotation.ScopedProxyMode; import org.springframework.stereotype.Component; import org.springframework.web.context.WebApplicationContext; @Component //基于接口的代理 @Scope( value = &quot;session&quot;, proxyMode = ScopedProxyMode.INTERFACES ) public class Cookies implements Dessert &#123; &#125; 同样在xml配置方式中，使用aop命名空间可以完成相同的功能： 基于类的代理（默认）： &lt;!--xml中定义scope以及proxyMode--&gt; &lt;bean id=&quot;cake&quot; class=&quot;chapter4.qualifier.Cake&quot; scope=&quot;session&quot;&gt; &lt;aop:scoped-proxy/&gt; &lt;/bean&gt; 基于接口的代理： &lt;!--xml中定义scope以及proxyMode--&gt; &lt;bean id=&quot;cake&quot; class=&quot;chapter4.qualifier.Cake&quot; scope=&quot;session&quot;&gt; &lt;aop:scoped-proxy proxy-target-class=&quot;false&quot;/&gt; &lt;/bean&gt; 为了使用aop命名空间，需要在xml头部声明aop命名空间： &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;beans/&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Java Web","slug":"Java-Web","permalink":"https://super-aviator.github.io/tags/Java-Web/"},{"name":"Spring","slug":"Spring","permalink":"https://super-aviator.github.io/tags/Spring/"}],"author":"熊乾坤"},{"title":"设计模式-装饰器(Decorator)模式","slug":"设计模式-装饰器模式","date":"2018-09-02T06:15:00.000Z","updated":"2021-02-23T13:00:04.000Z","comments":true,"path":"2018/09/02/设计模式-装饰器模式/","link":"","permalink":"https://super-aviator.github.io/2018/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考地址1参考地址2 在《Thinking in java》的讲解IO的章节中，反复提到了装饰器这个设计模式，因为那时还没有学习设计模式，所以对整个IO类的结构不了解，更不明白几个IO类相互嵌套就能够形成功能强大的IO能力的魔法到底来自哪里，当今天学习了装饰器模式之后，才对这些知识有了更深入的认识。接下来就来领会一下装饰器模式的强大的魔法。 装饰器模式的结构装饰器模式的MUL图 抽象组件（Component）：需要装饰的抽象对象。具体组件（ConcreteComponent）：是我们需要装饰的对象抽象装饰类（Decorator）：内含指向抽象组件的引用及装饰者共有的方法。具体装饰类（ConcreteDecorator）：装饰具体组件的对象 最简单的装饰器示例//基础接口 public interface Component &#123; public void biu(); &#125; //具体实现类 public class ConcretComponent implements Component &#123; public void biu() &#123; System.out.println(&quot;biubiubiu&quot;); &#125; &#125; //装饰类 public class Decorator implements Component &#123; public Component component; public Decorator(Component component) &#123; this.component = component; &#125; public void biu() &#123; this.component.biu(); &#125; &#125; //具体装饰类 public class ConcreteDecorator extends Decorator &#123; public ConcreteDecorator(Component component) &#123; super(component); &#125; public void biu() &#123; System.out.println(&quot;ready?go!&quot;); this.component.biu(); &#125; &#125; 测试输出如下： //使用装饰器 Component component = new ConcreteDecorator(new ConcretComponent()); component.biu(); //测试输出 ready?go! biubiubiu 使用装饰器模式的例子在《Head First设计模式》这本书中，使用星巴兹咖啡店订单系统作为例子来介绍装饰器模式。 抽象组件类Beverage： public abstract class Beverage &#123; public abstract double cast(); public abstract String getDescription(); &#125; 已知所有的咖啡以及佐料都应该继承自Beverage类，Beverage类包含了描述咖啡种类getDescription()以及计算价格cast()两个方法。所有的咖啡以及配菜（T_T）应该继承自Beverage类。 然后编写两个具体组件类ChocolateCoffee类和MacchaCoffee类: public class ChocolateCoffee extends Beverage&#123; @Override public double cast() &#123; //巧克力咖啡味10.2元 return 10.2; &#125; @Override public String getDescription() &#123; return &quot;巧克力咖啡&quot;; &#125; &#125; public class MacchaCoffee extends Beverage &#123; @Override public double cast() &#123; //抹茶咖啡价格为11.5 return 11.5; &#125; @Override public String getDescription() &#123; return &quot;抹茶咖啡&quot;; &#125; &#125; 这两种咖啡就是需要被包装的对象 ,会被包装在Decorator类中。 接下来编写一个抽象装饰类CondimentDecorator: package decorator; public abstract class CondimentDecorator extends Beverage&#123; protected Beverage beverage; //使用一个变量保存需要装饰的对象 public CondimentDecorator(Beverage beverage)&#123;this.beverage=beverage;&#125; &#125; 这个抽象装饰类是所有具体装饰类的抽象基类，其中有一个protected属性的Beverage实例变量并通过构造器将Beverage变量保存在实例变量中。 最后编写两个具体装饰类GarlicDecorator和CorianderDecorator： public class GarlicDecorator extends CondimentDecorator&#123; public GarlicDecorator(Beverage beverage)&#123; super(beverage); &#125; @Override public double cast() &#123; //大蒜的价格为0.4 return beverage.cast()+0.4; &#125; @Override public String getDescription() &#123; return beverage.getDescription()+&quot;加大蒜&quot;; &#125; &#125; public class CorianderDecorator extends CondimentDecorator &#123; public CorianderDecorator(Beverage beverage)&#123; super(beverage); &#125; @Override public double cast() &#123; //香菜的费用为0.5 return 0.5+beverage.cast(); &#125; @Override public String getDescription() &#123; return beverage.getDescription()+&quot;加香菜&quot;; &#125; &#125; 这两个类就是我们的装饰器类，用来装饰ChocolateCoffee类和MacchaCoffee类。并且在调用case和getDescription方法时会自动调用所包装的Beverage类的相关联的方法。 如上，我们就构成一个咖啡店的订单系统，如下的测试代码显示了系统正确运行的结果： public class Test &#123; public static void main(String[] args) &#123; //点一份巧克力咖啡加大蒜套餐 Beverage beverage= new GarlicDecorator(new ChocolateCoffee()); System.out.println(beverage.getDescription()+&quot;$&quot;+beverage.cast()); //点一份抹茶咖啡加香菜套餐 beverage=new CorianderDecorator(new MacchaCoffee()); System.out.println(beverage.getDescription()+&quot;$&quot;+beverage.cast()); &#125; &#125; //输出 巧克力咖啡加大蒜$10.6 抹茶咖啡加香菜$12.0 JavaI/O中的装饰器模式装饰器模式在Java I/O库中的应用,每个类对应装饰器模式中的不同的组件：IO流实现细节： Component抽象构件角色：io流中的InputStream,OutputStream,Reader,Writer ConcreteComponent具体构件角色：io流中的FileInputStream,FileOutputStream Decorate装饰角色：持有抽象构件的引用，FilterInputStream,FilterOutputStream ConcreteDecorate具体装饰角色：负责给构件对象添加新的责任，BufferedInputStream,BufferedOutputStream等 装饰器模式优缺点优点 扩展对象功能，比继承灵活，不会导致类个数急剧增加。可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更加强大的对象。具体构件类和具体装饰类可以独立变化，用户可以根据需要自己增加新的 具体构件子类和具体装饰子类。 缺点产生很多小对象。大量小的对象占据内存，一定程度上影响性能。装饰模式易出错，调试排查比较麻烦。","categories":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://super-aviator.github.io/categories/DesignPattern/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://super-aviator.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"熊乾坤"},{"title":"设计模式-观察者(Observer)模式","slug":"设计模式-观察者模式","date":"2018-09-01T11:33:00.000Z","updated":"2021-02-23T12:59:58.000Z","comments":true,"path":"2018/09/01/设计模式-观察者模式/","link":"","permalink":"https://super-aviator.github.io/2018/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"概述观察者模式又被称作发布/订阅模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 就好比报社与客户的关系，客户订阅了报社的报纸，当报纸更新后，报社会将报纸发送给客户，当客户取消订阅后，报社将不会再发送报纸给客户。 具体实现在《Head First 设计模式》中使用了气象站的例子进行讲解，具体的内容如下：在气象站中，所有的数据存放以及发布给布告板（CurrentConditionsDisplay）的对象为WeatherData，所以WeatherData是一个被观察者，而布告板负责从WeatherData对象中获得数据并进行显示，所以布告板就是一个观察者，首先我们需要定义一个被观察者接口，用来对观察者进行注册以及进行通知，其具体的实现如下： public interface Subject &#123; void registerObserver(Observer observer); void removeObserver(Observer observer); void notifyObserver(); &#125; 同时我们需要定义一个观察者接口，用来使观察者更新自己的数据，其具体实现如下： public interface Observer &#123; void update(float temperature,float humidity,float pressure); &#125; 然后，我们使WeatherData对象继承Subject接口，并定义一个集合用以保存已经注册的观察者。并提供注册以及删除Observer对象的方法： import java.util.ArrayList; public class WeatherData implements Subject &#123; private ArrayList&lt;Observer&gt; observers; private float temperature; private float humidity; private float pressure; public WeatherData() &#123; observers = new ArrayList&lt;&gt;(); &#125; @Override public void registerObserver(Observer observer) &#123; observers.add(observer); &#125; @Override public void removeObserver(Observer observer) &#123; int i = observers.indexOf(observer); if (i &gt;= 0) observers.remove(i); &#125; @Override public void notifyObserver() &#123; for (Observer s : observers) s.update(temperature, humidity, pressure); &#125; public void measurementsChanged() &#123; notifyObserver(); &#125; public void setMeasurements(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); &#125; &#125; 在上面的被观察者中，通过setMeasurements进行数据的更改，然后调用measurementsChanged方法通知已经注册的观察者进行数据更新，需要注意的是这是使用的是推送的方式进行数据更新，即无论被观察者状态如何，都将消息发送给观察者，而不是使观察者自己去拉取数据。 在观察者中，我们需要其实现Observe接口并且实现update方法，用来更新被观察者对象发送过来的数据。 public class CurrentConditionsDisplay implements Observer, DisplayElement &#123; private Subject weatherData; private float temperature; private float humidity; public CurrentConditionsDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this);//对于Observer进行注册 &#125; @Override public void display() &#123; //进行数据显示 System.out.println(&quot;temperature:&quot; + temperature + &quot;\\nhumidity:&quot; + humidity); &#125; @Override public void update(float temperature, float humidity, float pressure) &#123; //更新数据 this.temperature = temperature; this.humidity = humidity; display(); &#125; &#125; 如上就实现了一个最简单的观察者模式，当WeatherData对象的方法setMeasurements()被调用并将数据更新时，会自动调用notifyObservers()方法对所注册的Observer对象进行数据更新，Observer对象将调用display()来显示更新的结果。 如下的测试输出了想要的结果： 测试代码: public static void main(String[] args) &#123; WeatherData w=new WeatherData(); new CurrentConditionsDisplay(w); w.setMeasurements(12.4f,123.23f,14.134f); &#125; 测试输出： temperature:12.4 humidity:123.23 Java自带的观察者类和接口的实现由于观察者模式在java中应用广泛，所以Java在类库中自带了观察者模式的实现，它们分别为：java.util.Observable类以及java.util.Observer接口，并且自带了推送和拉取的两种实现。因为notifyObservers()方法有一个重载方法notifyObservers(Oject arg),当使用推送的方式时，调用方法notifyObservers(Oject arg)，会将arg中的数据传递给观察者，而使用拉取的方式时，调用方法notifyObservers()，间接调用notifyObservers(null)方法，此时观察者会使用getter方法自己从被观察者进行数据索取。 setChanged()&#123; changed=false; &#125; notifyObservers(Object arg)&#123; if(change)&#123; for(Observer o:list) o.update(this,arg); changed=false; &#125; &#125; notifyObservers()&#123; notifyObservers(null); &#125; 还需要注意的是进行通知前，会先判断消息是否改变，如果changed返回false，则表明没有数据可更新，将不会调用update方法。这样是为了避免太过于频繁的更新。 Observer接口比较简单，update方法会传入被观察者对象以及保存数据的Object。 package java.util; public interface Observer &#123; void update(Observable o, Object arg); &#125; 使用自带的API实现气象站对象下面使用java自带的接口对我们的气象站进行重写： WeatherData类： import java.util.Observable; public class NewWeatherData extends Observable &#123; private float temperature; private float humidity; private float pressure; public float getTemperature() &#123; return temperature; &#125; public float getHumidity() &#123; return humidity; &#125; public float getPressure() &#123; return pressure; &#125; public void measurementChanged()&#123; setChanged();//设置为信息已改变 notifyObservers();//使用拉取的方式 &#125; public void setMeasurements(float temperature,float humidity,float pressure)&#123; this.temperature=temperature; this.humidity=humidity; this.pressure=pressure; measurementChanged(); &#125; &#125; 需要注意的是，由于继承了Observable类，不需要创建集合去保存已注册的观察者，同时定义了getter方法为观察者提供访问数据的接口。 CurrentConditionsDisplay类： import java.util.Observable; import java.util.Observer; public class NewCurrentConditionsDisplay implements Observer &#123; private float temperature; private float humidity; private Observable observable; public NewCurrentConditionsDisplay(Observable observable) &#123; this.observable = observable; observable.addObserver(this); &#125; @Override public void update(Observable o, Object arg) &#123; if (o instanceof NewWeatherData) &#123; NewWeatherData weather = (NewWeatherData) o; this.temperature = weather.getTemperature(); this.humidity = weather.getHumidity(); display(); &#125; &#125; public void display() &#123; System.out.println(&quot;temperature:&quot; + temperature + &quot;\\nhumidity:&quot; + humidity); &#125; &#125; 在update方法中，对Observable对象进行安全的转型，并使用WeatherData进行数据的拉取。 自带API的缺点首先，Observable是一个类，我们必须继承它，由于java单继承的原因会带来不便，这同时限制了Observable复用的能力。并且也无法提供自己的实现。 然后，Observable将关键的方法setChange()以及clearChange()方法设置为protected修饰，也就导致了无法使用组合的方式来实现观察者模式，这违反了设计原则：多用组合，少用继承;","categories":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://super-aviator.github.io/categories/DesignPattern/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://super-aviator.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"熊乾坤"},{"title":"设计模式-策略(Strategy)模式（转）","slug":"设计模式-策略设计模式","date":"2018-09-01T01:20:00.000Z","updated":"2021-02-23T13:00:02.000Z","comments":true,"path":"2018/09/01/设计模式-策略设计模式/","link":"","permalink":"https://super-aviator.github.io/2018/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"博客原地址今天学习了《Head First 设计模式》中的策略设计模式，同时在网上发现了一篇写的非常好的博客,搬运了过来，里面的注解部分暂时看不懂，等以后学习了注解再来看一看。 正如《Head First 设计模式》书中所说，策略模式的设计原则就是将应用中需要变化的部分独立出来，同时还要注意多使用组合(composition)少使用继承(succeed)。 写代码时总会出很多的if…else，或者case。如果在一个条件语句中又包含了多个条件语句就会使得代码变得臃肿，维护的成本也会加大，而策略模式就能较好的解决这个问题，本篇博客就带你详细了解策略模式。 策略模式的定义和使用场景定义：策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。分析下定义，策略模式定义和封装了一系列的算法，它们是可以相互替换的，也就是说它们具有共性，而它们的共性就体现在策略接口的行为上，另外为了达到最后一句话的目的，也就是说让算法独立于使用它的客户而独立变化，我们需要让客户端依赖于策略接口。 策略模式的使用场景：1.针对同一类型问题的多种处理方式，仅仅是具体行为有差别时；2.需要安全地封装多种同一类型的操作时；3.出现同一抽象类有多个子类，而又需要使用 if-else 或者 switch-case 来选择具体子类时。 UML类图 这个模式涉及到三个角色： 环境(Context)角色：持有一个Strategy的引用。 抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。 策略模式的典型代码如下： 抽象策略类(策略接口)public interface Strategy &#123; /** * 策略方法 */ public void strategyInterface(); &#125; 具体策略类public class ConcreteStrategyA implements Strategy &#123; @Override public void strategyInterface() &#123; //相关的业务 &#125; &#125; public class ConcreteStrategyB implements Strategy &#123; @Override public void strategyInterface() &#123; //相关的业务 &#125; &#125; 环境角色类public class Context &#123; //持有一个具体策略的对象 private Strategy strategy; /** * 构造函数，传入一个具体策略对象 * @param strategy 具体策略对象 */ public Context(Strategy strategy)&#123; this.strategy = strategy; &#125; /** * 策略方法 */ public void contextInterface()&#123; strategy.strategyInterface(); &#125; &#125; 策略模式例子假设鹅厂推出了3种会员，分别为会员，超级会员以及金牌会员，还有就是普通玩家，针对不同类别的玩家，购买《王者农药》皮肤有不同的打折方式，并且一个顾客每消费10000就增加一个级别，那么我们就可以使用策略模式，因为策略模式描述的就是算法的不同，这里我们举例就采用最简单的，以上四种玩家分别采用原价（普通玩家），九折，八折和七价的收钱方式。 那么我们首先要有一个计算价格的策略接口: public interface CalPrice &#123; //根据原价返回一个最终的价格 Double calPrice(Double orgnicPrice); &#125; 下面是4种玩家的计算方式的实现: public class Orgnic implements CalPrice &#123; @Override public Double calPrice(Double orgnicPrice) &#123; return orgnicPrice; &#125; &#125; public class Vip implements CalPrice &#123; @Override public Double calPrice(Double orgnicPrice) &#123; return orgnicPrice * 0.9; &#125; &#125; public class SuperVip implements CalPrice &#123; @Override public Double calPrice(Double orgnicPrice) &#123; return orgnicPrice * 0.8; &#125; &#125; public class GoldVip implements CalPrice &#123; @Override public Double calPrice(Double orgnicPrice) &#123; return orgnicPrice * 0.7; &#125; &#125; 我们看客户类，我们需要客户类帮我们完成玩家升级的功能。 public class Player &#123; private Double totalAmount = 0D;//客户在鹅厂消费的总额 private Double amount = 0D;//客户单次消费金额 private CalPrice calPrice = new Orgnic(); //每个客户都有一个计算价格的策略，初始都是普通计算，即原价 //客户购买皮肤，就会增加它的总额 public void buy(Double amount) &#123; this.amount = amount; totalAmount += amount; if (totalAmount &gt; 30000) &#123;//30000则改为金牌会员计算方式 calPrice = new GoldVip(); &#125; else if (totalAmount &gt; 20000) &#123;//类似 calPrice = new SuperVip(); &#125; else if (totalAmount &gt; 10000) &#123;//类似 calPrice = new Vip(); &#125; &#125; //计算客户最终要付的钱 public Double calLastAmount() &#123; return calPrice.calPrice(amount); &#125; &#125; 接下来是客户端调用，系统会帮我们自动调整收费策略。 public class Client &#123; public static void main(String[] args) &#123; Player player = new Player(); player.buy(5000D); System.out.println(&quot;玩家需要付钱：&quot; + player.calLastAmount()); player.buy(12000D); System.out.println(&quot;玩家需要付钱：&quot; + player.calLastAmount()); player.buy(12000D); System.out.println(&quot;玩家需要付钱：&quot; + player.calLastAmount()); player.buy(12000D); System.out.println(&quot;玩家需要付钱：&quot; + player.calLastAmount()); &#125; &#125; 运行以后会发现，第一次是原价，第二次是九折，第三次是八折，最后一次则是七价。这样设计的好处是，客户不再依赖于具体的收费策略，依赖于抽象永远是正确的。 在上面的基础上，我们可以使用简单工厂来稍微进行优化 //定义工厂类 public class CalPriceFactory &#123; private CalPriceFactory()&#123;&#125; //根据客户的总金额产生相应的策略 public static CalPrice createCalPrice(Player customer)&#123; if (customer.getTotalAmount() &gt; 30000) &#123;//3000则改为金牌会员计算方式 return new GoldVip(); &#125;else if (customer.getTotalAmount() &gt; 20000) &#123;//类似 return new SuperVip(); &#125;else if (customer.getTotalAmount() &gt; 10000) &#123;//类似 return new Vip(); &#125;else &#123; return new Orgnic(); &#125; &#125; &#125; 这样就将制定策略的功能从客户类分离了出来，我们的客户类可以变成这样。 public class Player &#123; private Double totalAmount = 0D;//客户在鹅厂消费的总额 private Double amount = 0D;//客户单次消费金额 private CalPrice calPrice = new Orgnic(); //每个客户都有一个计算价格的策略，初始都是普通计算，即原价 //客户购买皮肤，就会增加它的总额 public void buy(Double amount) &#123; this.amount = amount; totalAmount += amount; /* 变化点，我们将策略的制定转移给了策略工厂，将这部分责任分离出去 */ calPrice = CalPriceFactory.createCalPrice(this); &#125; //计算客户最终要付的钱 public Double calLastAmount() &#123; return calPrice.calPrice(amount); &#125; public Double getTotalAmount() &#123; return totalAmount; &#125; &#125; 使用注解简化策略设计模式虽然结合简单工厂模式，我们的策略模式灵活了一些，但不免发现在工厂中多了if-else判断，也就是如果增加一个会员类别，我又得增加一个else-if语句，这是简单工厂的缺点，对修改开放。 那有什么方法，可以较好的解决这个问题呢？那就是使用注解， 所以我们需要给注解加入属性上限和下限，用来表示策略生效的区间，用来解决总金额判断的问题。 1.首先我们做一个注解，这个注解是用来给策略添加的，当中可以设置它的上下限 //这是有效价格区间注解，可以给策略添加有效区间的设置 @Target(ElementType.TYPE)//表示只能给类添加该注解 @Retention(RetentionPolicy.RUNTIME)//这个必须要将注解保留在运行时 public @interface PriceRegion &#123; int max() default Integer.MAX_VALUE; int min() default Integer.MIN_VALUE; &#125; 可以看到，我们只是使用这个注解来声明每一个策略的生效区间，于是对策略进行修改 @PriceRegion(max = 10000) public class Orgnic implements CalPrice &#123; @Override public Double calPrice(Double orgnicPrice) &#123; return orgnicPrice; &#125; &#125; @PriceRegion(max=20000) public class Vip implements CalPrice &#123; @Override public Double calPrice(Double orgnicPrice) &#123; return orgnicPrice * 0.9; &#125; &#125; @PriceRegion(min=20000,max=30000) public class SuperVip implements CalPrice &#123; @Override public Double calPrice(Double orgnicPrice) &#123; return orgnicPrice * 0.8; &#125; &#125; @PriceRegion(min=3000) public class GoldVip implements CalPrice &#123; @Override public Double calPrice(Double orgnicPrice) &#123; return orgnicPrice * 0.7; &#125; &#125; 接下来就是在策略工厂中去处理注解 public class CalPriceFactory &#123; private static final String CAL_PRICE_PACKAGE = &quot;com.example.stragedemo&quot;;//这里是一个常量，表示我们扫描策略的包 private ClassLoader classLoader = getClass().getClassLoader(); private List&lt;Class&lt;? extends CalPrice&gt;&gt; calPriceList;//策略列表 //根据玩家的总金额产生相应的策略 public CalPrice createCalPrice(Player player) &#123; //在策略列表查找策略 for (Class&lt;? extends CalPrice&gt; clazz : calPriceList) &#123; PriceRegion validRegion = handleAnnotation(clazz);//获取该策略的注解 //判断金额是否在注解的区间 if (player.getTotalAmount() &gt; validRegion.min() &amp;&amp; player.getTotalAmount() &lt; validRegion.max()) &#123; try &#123; //是的话我们返回一个当前策略的实例 return clazz.newInstance(); &#125; catch (Exception e) &#123; throw new RuntimeException(&quot;策略获得失败&quot;); &#125; &#125; &#125; throw new RuntimeException(&quot;策略获得失败&quot;); &#125; //处理注解，我们传入一个策略类，返回它的注解 private PriceRegion handleAnnotation(Class&lt;? extends CalPrice&gt; clazz) &#123; Annotation[] annotations = clazz.getDeclaredAnnotations(); if (annotations == null || annotations.length == 0) &#123; return null; &#125; for (int i = 0; i &lt; annotations.length; i++) &#123; if (annotations[i] instanceof PriceRegion) &#123; return (PriceRegion) annotations[i]; &#125; &#125; return null; &#125; //单例 private CalPriceFactory() &#123; init(); &#125; //在工厂初始化时要初始化策略列表 private void init() &#123; calPriceList = new ArrayList&lt;Class&lt;? extends CalPrice&gt;&gt;(); File[] resources = getResources();//获取到包下所有的class文件 Class&lt;CalPrice&gt; calPriceClazz = null; try &#123; calPriceClazz = (Class&lt;CalPrice&gt;) classLoader.loadClass(CalPrice.class.getName());//使用相同的加载器加载策略接口 &#125; catch (ClassNotFoundException e1) &#123; throw new RuntimeException(&quot;未找到策略接口&quot;); &#125; for (int i = 0; i &lt; resources.length; i++) &#123; try &#123; //载入包下的类 Class&lt;?&gt; clazz = classLoader.loadClass(CAL_PRICE_PACKAGE + &quot;.&quot; + resources[i].getName().replace(&quot;.class&quot;, &quot;&quot;)); //判断是否是CalPrice的实现类并且不是CalPrice它本身，满足的话加入到策略列表 if (CalPrice.class.isAssignableFrom(clazz) &amp;&amp; clazz != calPriceClazz) &#123; calPriceList.add((Class&lt;? extends CalPrice&gt;) clazz); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //获取扫描的包下面所有的class文件 private File[] getResources() &#123; try &#123; File file = new File(classLoader.getResource(CAL_PRICE_PACKAGE.replace(&quot;.&quot;, &quot;/&quot;)).toURI()); return file.listFiles(new FileFilter() &#123; public boolean accept(File pathname) &#123; if (pathname.getName().endsWith(&quot;.class&quot;)) &#123;//我们只扫描class文件 return true; &#125; return false; &#125; &#125;); &#125; catch (URISyntaxException e) &#123; throw new RuntimeException(&quot;未找到策略资源&quot;); &#125; &#125; public static CalPriceFactory getInstance() &#123; return CalPriceFactoryInstance.instance; &#125; private static class CalPriceFactoryInstance &#123; private static CalPriceFactory instance = new CalPriceFactory(); &#125; &#125; 虽然工厂里的逻辑增加了，但是解耦的效果达到了，现在我们随便加入一个策略，并设置好它的生效区间，策略工厂就可以帮我们自动找到适应的策略。","categories":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://super-aviator.github.io/categories/DesignPattern/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://super-aviator.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"熊乾坤"},{"title":"Spring-装配bean","slug":"JAVA-WEB基础-初学Spring框架","date":"2018-08-31T06:23:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2018/08/31/JAVA-WEB基础-初学Spring框架/","link":"","permalink":"https://super-aviator.github.io/2018/08/31/JAVA-WEB%E5%9F%BA%E7%A1%80-%E5%88%9D%E5%AD%A6Spring%E6%A1%86%E6%9E%B6/","excerpt":"","text":"在前几天，通过学习《Spring in action》这本书的前7章，我学习了Spring框架的基础以及SpringMVC部分的知识，对Spring框架有了比较浅显的认识，接下来的几天，我准备将所学习到的知识记录一下，方便以后查询，因为Spring配置算是比较繁琐的过程，记录下来方便以后查询。Spring其他部分暂时不做研究，等以后用的时候在去折腾。 Spring核心概念的理解Spring有两个核心，第一个就是IOC(Inverse Of Control)控制反转，也叫作做DI(dependency Injection),《Spring in action》书中作者叫DI比较多,第二个就是AOP(Aspect Oriented Programming)面向切面编程。我从网上copy了他们的通俗的解释。 IOC(DI) 所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们可配置的文件或者注解。即通过DI来管理对象之间的依赖。 AOP 它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 Spring容器Spring容器是Spring基础，是所有bean存放的地方,也负责创建、配置和组装bean，Spring中有多种容器的实现，可以归为两种不同的类型，第一种是bean工厂（org.springframework.beans.factory.BeanFactory） ,第二种是应用上下文ApplicationContext(org.springframework.context.ApplicationContext)，前者拥有非常基础的bean支持，提供基本的DI支持，后者基于BeanFactory构建，并提供应用框架级别的服务，我们常用的是后者。对容器的深入的研究等以后再进行。 Spring三种配置方式在接下来我将记录Spring中最基本也最重要的环节—装配bean，通过对三种装配方式的学习，来熟悉Spring装配bean的步骤。这也是Spring学习的基础知识。 自动装配自动装配顾名思义，就是让Spring自动去查找需要的bean，《Spring in action》作者建议优先使用此方式，它分为两个步骤： 组件扫描—Spring会自动发现应用上下文中所创建的bean。 自动装配—Spring自动会满足bean之间的依赖关系。 我们来看一下配置自动扫描的一般步骤：1.在类上使用@Component或者@Name注解，告诉Spring要为这个类创建bean。例如： @Component(&quot;favorite&quot;) //@Named(&quot;favorite&quot;) public class Mayday implements CompactDisc &#123; String artist=&quot;Mayday&quot;; String title=&quot;Tender - Love is Elsewhere&quot;; @Override public void play() &#123; System.out.println(&quot;Playing &quot;+title+&quot; by &quot;+artist); &#125; &#125; 在创建bean时，Spring会为bean自动设置ID为类名的首字母小写，在上面的Mayday的类中，bean的ID为mayday,可以传入自定义的ID名称。同时@Name和@Component注解功能相同，推荐使用后者，因为更符合语义。 2.在配置类或者xml文件中开启自动扫描,并设置组件扫描的基础包或者类：首先需要使用@Configuration注解将一个类申明为配置类，Spring将自动扫描到该配置类，然后在配置类中开启自动扫描。 在配置类中申明的方式如下：@Configuration //申明此类为配置类 @ComponentScan(&quot;chapter2&quot;)//指明想要扫描的包 //@ComponentScan(basePackages = &#123;&quot;chapter2&quot;&#125;)//指明想要扫描的包 //@ComponentScan(basePackageClasses=&#123;CompactDisc.class&#125;)//指明想要扫描的类或接口 @Import(&#123;JavaConfig.class，otherConfig.class&#125;)//引入其他的配置类 public class CDPlayConfig &#123;&#125; 在上面的配置类中，使用@ComponentScan注解开启扫描，并可以指定要扫描的类或者包，默认为该配置类所在的包及其子包。注意，当指定需要扫描的类时，类所在的包会被当成基础包扫描。其中还可以使用import导入其他的配置类。 在xml文件中申明方式如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;context:component-scan base-package=”chapter2” /&gt; 3.使用@Autowiring自动装配bean. ```java @Component public class CDPlayer implements MediaPlayer &#123; private CompactDisc cd; //setter方法注入 @Autowired(required=false)//进行自动装配，当没有匹配的bean时，不抛出异常 @Autowired//进行自动装配，当没有匹配的bean时，抛出异常 public void setCompactDisc(CompactDisc cd) &#123; this.cd = cd; &#125; //构造器注入 @Autowired public CDPlayer(CompactDisc cd)&#123;this.cd=cd;&#125; public void play() &#123; cd.play(); &#125; &#125; 上面的方法中，CDPlayer需要一个CompactDisc接口的对象，我们只需要在setter方法或者构造器上使用@Autowired注解（其实在任何方法都可以使用@Autowired注解进行注入），Spring将在运行时为我们自动注入一个Compact对象，需要注意的是@Autowired注解中如果属性required值设置为false，那么在Spring找不到对应的bean时，将不会抛异常，因此会有NullPointerException异常。不传入时默认为找不到bean时抛出异常。 @Inject注解可以替代@Autowired注解，两者功能有一些细微的差别，但大多数场景下可以互相替换。 基于Java代码的配置自动装配bean的方式非常的简单，仅仅需要几个注解就可以装配大量的bean，但是在无法获得源代码的情况下，无法对源代码添加注解，自动装配bean这种方式也就不能够使用，这时候就可以使用java代码的方式配置bean,它只需要一个配置类，然后在配置类中使用方法来生成相应的bean，具体方式如下： @Component public class CDPlayConfig &#123; //使用JavaConfig的方式进行装配bean @Bean(name=&quot;Mayday&quot;) public Mayday getMayday()&#123; return new Mayday(); &#125; &#125; 如上所示，在配置类中，我们使用getMayday方法,来产生bean，在此方法上，需要使用@Bean注解，如果想要为此bean自定义一个ID，则可以在Bean的name属性中设置自己指定的ID。 如果一个bean的产生需要另外一个bean,那该怎么办呢，解决方法很简单，有两种方式实现： @Component public class CDPlayConfig &#123; //使用JavaConfig的方式进行装配bean @Bean(name=&quot;MayDay&quot;) public Mayday getMayday()&#123; return new Mayday(); &#125; //方式一 @Bean(name=&quot;CDPlayer&quot;) public CDPlayer getCDPlayer()&#123; return new CDPlayer(getMayday()); &#125; //方式二 @Bean(name=&quot;CDPlayer&quot;) public CDPlayer getCDPlayer(CompactDisc compactDisc)&#123; //构造器注入 return new CDPlayer(compactDisc); //setter方法注入 CDplayer player=new CDPlayer(); player.setCd(compactDisc); return player; &#125; &#125; 在上面的配置类中，CDPlayer类需要一个CompactDisc类作为参数，有两种方式解决其依赖：第一种方式直接调用产生CompactDisc实例的方法getMayday(),因为bean默认都是单例的，Spring会拦截getMayday()的调用并返回Spring所创建的bean。并且调用任意次getMayday()得到的都是同一个bean。第二种方式中getCDPlayer请求一个CompactDisc作为参数，当调用此方法时，Spring会自动装配一个CompactDisc类型的bean。而且产生此CompactDisc类型的bean的方式没有任何限制，可以以三种配置方式中的任意一种来产生CompactDisc，而第一种方式则限定需要使用java的方式来产生CompactDisc，所以推荐使用第二种方式。 基于XML的配置xml作为一种最古老的配置方式，也是每一个人必须掌握的，不过作者并不推荐我们开发时使用XML进行装配，而学习xml配置只是为了维护旧项目。 和其他两种方式一样，基于xml的配置也需要一个配置类，只不过它不是@Configuration注解的类，而是一个xml文件，并且以&lt;beans&gt;为根元素。最简单的Spring XML如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;/beans&gt; 想要声明一个bean，只需要在&lt;beans&gt;元素中使用&lt;bean&gt;元素即可： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;mayday&quot; class=&quot;chapter2.ditest.Mayday&quot; /&gt; &lt;/ beans&gt; 其中id为自定义bean的ID,class为class位置，需要使用包全限定名称。默认的ID为全限定名#序号,序号为相同bean的个数，第一个为0，第二个为1…如果想要使用构造器注入一个其他的bean或者值，则需要使用&lt;constructor-arg&gt;元素： &lt;bean id=&quot;mayday&quot; class=&quot;chapter2.ditest.Mayday&quot; &gt; &lt;!--注入其他的bean--&gt; &lt;constructor-arg ref=&quot;beanID&quot; /&gt; &lt;!--注入其他类型的值--&gt; &lt;constructor-arg value=&quot;this is a String&quot; /&gt; &lt;!--注入null值--&gt; &lt;constructor-arg&gt;&lt;null/&gt;&lt;/ constructor-arg&gt; &lt;!--装配值的List集合--&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;this si a String&lt;/ value&gt; &lt;value&gt;this si a String&lt;/ value&gt; &lt;value&gt;this si a String&lt;/ value&gt; &lt;/ list&gt; &lt;/ constructor-arg&gt; &lt;!--装配bean的List集合--&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;ref bean=&quot;beanID&quot;&gt; &lt;ref bean=&quot;beanID&quot;&gt; &lt;ref bean=&quot;beanID&quot;&gt; &lt;/ list&gt; &lt;/ constructor-arg&gt; &lt;!--装配Set集合--&gt; &lt;constructor-arg&gt; &lt;set&gt; &lt;value&gt;this si a String&lt;/ value&gt; &lt;value&gt;this si a String&lt;/ value&gt; &lt;value&gt;this si a String&lt;/ value&gt; &lt;/ set&gt; &lt;/ constructor-arg&gt; &lt;/ bean&gt; 如果不是使用构造器注入而是属性注入，则需要使用&lt;property元素&gt;： &lt;bean id=&quot;cdPlayer&quot; class=&quot;chapter2.ditest.CDPlayer&quot; &gt; &lt;!--注入其他的bean--&gt; &lt;property name=&quot;compactDisc&quot; ref=&quot;blankDisc&quot;/&gt; &lt;!--注入值--&gt; &lt;property name=&quot;compactDisc&quot; value=&quot; hello&quot; /&gt; &lt;/bean&gt; 构造器注入和属性注入都有对应的替代方案，分别为c-命名空间和p-命名空间。需要在xml文件顶部中声明其模式： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; &lt;!--声明p-命名空间--&gt; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; &lt;!--声明c-命名空间--&gt; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;/bean&gt; 然后其使用方式分为几种，具体的使用方式如下： &lt;!--注入其他的bean，paraName为参数名--&gt; &lt;bean id=&quot;cdPlayer&quot; class=&quot;chapter2.ditest.CDPlayer&quot; c:paraName-ref=&quot;beanID&quot; p:paraName-ref=&quot;beanID&quot; /&gt; &lt;!--通过参数名来注入,paraName为参数名,前者加下划线，后者不加--&gt; &lt;bean id=&quot;cdPlayer&quot; class=&quot;chapter2.ditest.CDPlayer&quot; c:_paraName=&quot;this is a String&quot; p:paraName=&quot;this is a String&quot; /&gt; &lt;!--通过参数顺序来,0,1为参数的顺序,p-命名空间貌似不支持--&gt; &lt;bean id=&quot;cdPlayer&quot; class=&quot;chapter2.ditest.CDPlayer&quot; c:_0=&quot;this is a String&quot; c:_0-ref=&quot;beanID&quot; /&gt; &lt;!--参数只有一个时--&gt; &lt;bean id=&quot;cdPlayer&quot; class=&quot;chapter2.ditest.CDPlayer&quot; c:_=&quot;this is a String&quot; c:_-ref=&quot;beanID&quot; /&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Java Web","slug":"Java-Web","permalink":"https://super-aviator.github.io/tags/Java-Web/"},{"name":"Spring","slug":"Spring","permalink":"https://super-aviator.github.io/tags/Spring/"}],"author":"熊乾坤"},{"title":"初学Servlet-Servlet、GenericServlet、HttpServlet","slug":"Spring基础-初学Servlet","date":"2018-08-18T11:42:00.000Z","updated":"2021-02-23T13:00:08.000Z","comments":true,"path":"2018/08/18/Spring基础-初学Servlet/","link":"","permalink":"https://super-aviator.github.io/2018/08/18/Spring%E5%9F%BA%E7%A1%80-%E5%88%9D%E5%AD%A6Servlet/","excerpt":"","text":"经过十几天的颓废之后，今天状态总算是有所好转，终于可以静下心来看看东西了，学习了一点点Servlet的东西，记录一下，以前做学生管理系统用过一点点的Servlet，不过没有系统的学习，写出来的东西也非常乱，至今没有搞懂ServletConfig,ServletContext啥的，希望通过这几天的学习能够深入了解一下。为接下来的Spring框架学习打好基础。 Servlet的两种配置方式从Servlet3.0开始，配置Servlet支持注解方式，但还是保留了配置web.xml方式，所有使用Servlet有两种方式： 通过注解的方式原地址 @WebServlet注解有如下属性，根据需要可以进行选择。 属性 | 类型 | 是否必须 | 说明—| — | — | ——- | —asyncSupported |boolean| 否| 指定Servlet是否支持异步操作模式displayName |String |否 | 指定Servlet显示名称initParams |WebInitParam[] |否 |配置初始化参数loadOnStartup| int| 否| 标记容器是否在应用启动时就加载这个Servletname| String| 否 |指定Servlet名称urlPatterns/value| String[] |否| 这两个属性作用相同，指定Servlet处理的url 注意： loadOnStartup属性：标记容器是否在启动应用时就加载Servlet，默认不配置或数值为负数时表示客户端第一次请求Servlet时再加载；0或正数表示启动应用就加载，正数情况下，数值越小，加载该Servlet的优先级越高； name属性：可以指定也可以不指定，通过getServletName()可以获取到，若不指定，则为Servlet的完整类名，如：cn.edu.njit.servlet.UserServlet urlPatterns/value属性： String[]类型，可以配置多个映射，如：urlPatterns={“/user/test”, “/user/example”} 在使用注解方式时，需要注意： 根元素中不能配置属性metadata-complete=”true”，否则无法加载Servlet。metadata-complete属性表示通知Web容器是否寻找注解，默认不写或者设置false，容器会扫描注解和Web分片，为Web应用程序构建有效的元数据；设置true，表示将由部署描述符为Web程序提供所有的配置信息web.xml中不能再配置该Servlet urlPatterns的常用规则：/*或者/：拦截所有 .do：拦截指定后缀/user/test：拦截路径/user/.do、/.do、test.do都是非法的，启动时候会报错 urlPatterns的配置规则：精确匹配、扩展名匹配、路径匹配以及会包含一些优先级，这些在以后会整理。 示例： @WebServlet(name = &quot;myUserServlet&quot;, urlPatterns = &quot;/user/test&quot;, loadOnStartup = 1, initParams = &#123; @WebInitParam(name=&quot;name&quot;, value=&quot;小明&quot;), @WebInitParam(name=&quot;pwd&quot;, value=&quot;123456&quot;) &#125; ) 通过xml文件的方式原地址 也可以通过xml的方式配置servlet，方法如下: &lt;!-- 配置一个servlet --&gt; &lt;!-- servlet的配置 --&gt; &lt;servlet&gt; &lt;!-- servlet的内部名称，自定义。尽量有意义 --&gt; &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt; &lt;!-- servlet的类全名： 包名+简单类名 --&gt; &lt;servlet-class&gt;lm.practice.ServletDemo&lt;/servlet-class&gt; &lt;!-- servlet的加载优先级 --&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- servlet的映射配置 --&gt; &lt;servlet-mapping&gt; &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt; &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt; &lt;!-- servlet的映射路径（访问servlet的名称） --&gt; &lt;url-pattern&gt;/servlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 注意： 可以看到，在配置Servlet时，有两个地方需要配置，一个是servlet,另一个是servlet-Mapping，这两个一个是配置Servlet，一个是配置其映射信息，其中&lt;servlet&gt;中的&lt;servlet-name&gt;可以随意指定，但要有一定的意义，一般取为类的名称，例如我的类名为ServletDemo，这里取名为ServletDemo,下面的是类的全路径，package+calssname，一定要是全路径！ &lt;servlet-Mapping&gt;是映射信息，它也有一个&lt;servlet-name&gt;，里面的名字是对应的Servlet名，也就是我们上面配置的Servlet名字，这里是ServletDemo，下面的是映射路径，也就是访问Servlet的名称，这里也是以方便和有意义为前提的，是我们在访问Servlet在浏览器地址栏后面输入的那个信息，例如我的映射路径命名为/servlet，在地址栏中输入 http://localhost/20170323/servlet 映射路径一定不是丢掉/，否则就会出错了，一定要写成/servlet，不能是servlet Servlet类命名惯例是以Servlet结尾 Servlet接口在javax.servlet包中，定义了非常重要的Servlet接口，它有五个重要的方法。 init方法在Servlet被加载或者load-on-startup设置为大于等于0在容器启动时，会被调用。 service：每当请求Servlet时候，Servlet容器调用这个方法。 destroy：当要销毁Servlet时，Servlet容器就调用这个方法，发生场景在卸载应用程序或关闭Servlet容器，在这个方法中编写清除代码。 getServletInfo：返回Servlet的描述。 getServletConfig：返回由Servlet容器传给init方法的ServletConfig。 实现Servlet接口在编写代码时，可以让我们的类直接实现Servlet来实现其中的方法，代码如下： import javax.servlet.*; import javax.servlet.annotation.WebServlet; import java.io.IOException; import java.io.PrintWriter; @WebServlet(name = &quot;MyServlet&quot;,urlPatterns = &quot;/start-servlet&quot;) public class MyServlet implements Servlet &#123; private ServletConfig sc; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(getServletInfo()+&quot; has been init!&quot;); sc=servletConfig; &#125; @Override public ServletConfig getServletConfig() &#123; return sc; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; String servletName=getServletConfig().getServletName(); PrintWriter out=servletResponse.getWriter(); out.print(&quot;&lt;html&gt;&quot; + &quot;&lt;body&gt;Hello From &quot;+servletName +&quot;&lt;/&#39;body&gt;&lt;html&gt;&quot; ); &#125; @Override public String getServletInfo() &#123; return &quot;MyServlet-Xqk&quot;; &#125; @Override public void destroy() &#123; System.out.println(getServletInfo()+&quot; has been destroy!&quot;); &#125; &#125; 这样做的缺点是非常麻烦，必须实现接口中的所有方法,所以后面有几种更加省力的方法。 继承GenericServlet抽象类GenericServlet实现了Servlet接口和ServletConfig接口，在Servlet接口的基础上更进一步，它给出了除了service以外的方法的默认实现，如果继承了GenericServlet类，则只需要实现service方法，而不需要所有方法都覆盖，并且由于实现了ServletConfig接口，它还增加了一些直接对ServletConfig进行操作的便捷方法。GenericServlet方法如下： package servletstart; import javax.servlet.GenericServlet; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebInitParam; import javax.servlet.annotation.WebServlet; import java.io.IOException; import java.io.PrintWriter; @WebServlet(name = &quot;GenericServletDemoServlet&quot;, urlPatterns = &quot;/generic-servlet-demo-servlet&quot;, initParams = &#123; @WebInitParam(name=&quot;action&quot;,value=&quot;GetMessage&quot;), @WebInitParam(name=&quot;email&quot;,value=&quot;2372389705@qq.com&quot;) &#125;) public class GenericServletDemoServlet extends GenericServlet &#123; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; String action=getServletConfig().getInitParameter(&quot;action&quot;); String email=getServletConfig().getInitParameter(&quot;email&quot;); PrintWriter pw=servletResponse.getWriter(); pw.print(&quot;&lt;html&gt;&quot; + &quot;&lt;body&gt;action=&quot;+action+&quot;&lt;/br&gt;email=&quot;+email +&quot;&lt;/&#39;body&gt;&lt;html&gt;&quot; ); &#125; &#125; 相比于直接实现Servlet接口，直接继承GenericServlet代码量少很多。 继承HttpServlet类第三种方式是直接继承HttpServlet类，因为大多数Servlet都在Http环境中进行处理，HttpServlet类则更近一步，HttpServlet将Servlet和Http结合到一起，提供了Http几种方法的实现，其所有方法如下： 比较重要的是service方法，在继承了GenericServlet类的service方法后，HttpService重新定义了一个service方法，接受两个不同的参数，HttpServlet类中的继承的service()方法如下: public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; HttpServletRequest request; HttpServletResponse response; try &#123; request = (HttpServletRequest)req; response = (HttpServletResponse)res; &#125; catch (ClassCastException var6) &#123; throw new ServletException(&quot;non-HTTP request or response&quot;); &#125; this.service(request, response); &#125; 在继承的方法中，将ServletRequest和ServletResponse直接强转为HttpServletRequest,HttpServletResponse,后者是与Http有关的请求与响应对象，在新建的方法中，判断HttpServletRequest对象中的方法名，然后调用相应的doXXX方法。 protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getMethod(); long lastModified; if (method.equals(&quot;GET&quot;)) &#123; lastModified = this.getLastModified(req); if (lastModified == -1L) &#123; this.doGet(req, resp); &#125; else &#123; long ifModifiedSince; try &#123; ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;); &#125; catch (IllegalArgumentException var9) &#123; ifModifiedSince = -1L; &#125; if (ifModifiedSince &lt; lastModified / 1000L * 1000L) &#123; this.maybeSetLastModified(resp, lastModified); this.doGet(req, resp); &#125; else &#123; resp.setStatus(304); &#125; &#125; &#125; else if (method.equals(&quot;HEAD&quot;)) &#123; lastModified = this.getLastModified(req); this.maybeSetLastModified(resp, lastModified); this.doHead(req, resp); &#125; else if (method.equals(&quot;POST&quot;)) &#123; this.doPost(req, resp); &#125; else if (method.equals(&quot;PUT&quot;)) &#123; this.doPut(req, resp); &#125; else if (method.equals(&quot;DELETE&quot;)) &#123; this.doDelete(req, resp); &#125; else if (method.equals(&quot;OPTIONS&quot;)) &#123; this.doOptions(req, resp); &#125; else if (method.equals(&quot;TRACE&quot;)) &#123; this.doTrace(req, resp); &#125; else &#123; String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;); Object[] errArgs = new Object[]&#123;method&#125;; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(501, errMsg); &#125; &#125; ServletConfig和ServletContext对象ServletConfig对象是Servlet类特有的，即每一个Servlet类都有一个ServletConfig对象，一个Servlet不能访问另一个Servlet的ServletConfig对象，在init方法中，使用Servlet中的类变量来将其保存： public class MyServlet implements Servlet &#123; private ServletConfig sc; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; sc=servletConfig; &#125; &#125; ServletConfig对象有一个方法能够获取在配置Servlet时指定的初始参数（initParams）,例子如下： import javax.servlet.GenericServlet; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebInitParam; import javax.servlet.annotation.WebServlet; import java.io.IOException; import java.io.PrintWriter; @WebServlet(name = &quot;GenericServletDemoServlet&quot;, urlPatterns = &quot;/generic-servlet-demo-servlet&quot;, initParams = &#123; @WebInitParam(name = &quot;action&quot;, value = &quot;GetMessage&quot;), @WebInitParam(name = &quot;email&quot;, value = &quot;2372389705@qq.com&quot;) &#125;) //定义两个初始参数 public class GenericServletDemoServlet extends GenericServlet &#123; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; String action = getServletConfig().getInitParameter(&quot;action&quot;); String email = getServletConfig().getInitParameter(&quot;email&quot;); //获取定义的初始参数 PrintWriter pw = servletResponse.getWriter(); pw.print(&quot;&lt;html&gt;&quot; + &quot;&lt;body&gt;action=&quot; + action + &quot;&lt;/br&gt;email=&quot; + email + &quot;&lt;/&#39;body&gt;&lt;html&gt;&quot; ); &#125; &#125; ServletContext对象对于每个Servlet是共享的，即一个WEB应用拥有一个ServletContext对象，WEB应用中的Servlet程序共享一个ServeltContext对象，ServletContext对象有三种获得方式： 通过ServletConfig对象的this.getServletContext()方法获取。 采用request.getSession().getServletContext()方法获取。 通过继承GenericServlet类或HttpServlet类，调用GenericServlet类或HttpServlet类的getServletContext()方法获取。 由于ServletContext是所有Servlet共享的，所以可以在一个Servlet中存放属性，并在另外一个Servlet中取出所存放的属性，例子如下： import javax.servlet.*; import javax.servlet.annotation.WebServlet; import java.io.IOException; @WebServlet(urlPatterns = &quot;/context-a-servlet&quot;, loadOnStartup = 0) public class ContextAServlet implements Servlet &#123; private ServletConfig sc; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; sc = servletConfig; ServletContext context = sc.getServletContext(); context.setAttribute(&quot;name&quot;, &quot;xqk&quot;); &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125; &#125; 在ContextAServlet中，init方法中向ServletContext对象存放了一组属性：name=”name”,value=”xqk”。值得注意的是，需要对ContextAServlet设置loadOnStartup大于等于0，因为tomcat启动时，如果不先加载这个Servlet,那么就不会执行init方法，在另外的Servlet也就无法取出属性了，接下来我们在另外一个类中取出： package servletstart; import javax.servlet.*; import javax.servlet.annotation.WebServlet; import java.io.IOException; import java.io.PrintWriter; //@WebServlet(urlPatterns = &quot;/context-b-servlet&quot;) public class ContextBServlet implements Servlet &#123; private ServletConfig sc; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; sc=servletConfig; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; Object attribute = sc.getServletContext().getAttribute(&quot;name&quot;); /** * 在使用ServletContext对象获取属性时，需要明确的知道，存放属性的Servlet * 已经被加载并且调用了存放属性的方法，否则获取时将得到null,... */ PrintWriter out = servletResponse.getWriter(); out.print(&quot;&lt;html&gt;&quot; + &quot;&lt;body&gt;I get a attribute &quot; + attribute + &quot;&lt;/&#39;body&gt;&lt;html&gt;&quot; ); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125; &#125; 输出结果： HttpServletRequest和HttpServletResponse","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Java Web","slug":"Java-Web","permalink":"https://super-aviator.github.io/tags/Java-Web/"},{"name":"Servlet","slug":"Servlet","permalink":"https://super-aviator.github.io/tags/Servlet/"}],"author":"熊乾坤"},{"title":"TCP连接建立与关闭","slug":"TCP连接建立与关闭","date":"2018-08-07T02:09:00.000Z","updated":"2021-02-23T13:00:02.000Z","comments":true,"path":"2018/08/07/TCP连接建立与关闭/","link":"","permalink":"https://super-aviator.github.io/2018/08/07/TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E5%85%B3%E9%97%AD/","excerpt":"","text":"大三上学期，学习了计算机网络这门课程，老师主要从TCP\\IP的五层协议中的前四层进行了讲解，但是对于比较重要的运输层，讲解的比较少，但是也是因为TCP协议本身太复杂，而且涉及到的东西非常多，不深入讲解也是可以理解滴，今天着重复习了TCP协议的连接建立和关闭的过程，记录一下，为即将到来的找工作做好准备。 TCP头部中的字段 我们知道，TCP报文在不加选项时的长度为20字节，加上选项后的长度为60字节，在TCP报文的头部中，一共定义了8比特的字段： CWR 拥塞窗口减 ECE ECN回显 URG 紧急字段（需要紧急指针有效） ACK 确认字段(需要确认号有效) PSH 推送 RST 重置连接 SYN 同步字段，用于初始化一个连接的同步序列号 FIN 终止字段，表示该报文段的发送方已经结束向对方发送数据 其中与连接管理有关的有三个字段，SYN,ACK,FIN。 TCP连接建立TCP的连接建立又称为三次握手，是指建立的过程中，需要进行三次的报文交换来达到连接建立的过程，其建立的图解过程如下： 具体的步骤分为以下三步： 主动开启者（通常称为客户端）发送一个SYN报文段（即一个TCP头部的SYN为字段置位的TCP报文），并指明自己想要连接的端口号和自己的序列号seq为初始序列号ISN(nitial Sequence Number)：x。 服务器收到了客户端的同步报文之后，紧接着发送自己的SYN报文段作为响应，其中包含了自己的序列号seq为初始序列号(Initial Sequence Number)：y，此外，为了表示已经接收到客户端的同步报文，还需要发送对客户端的同步报文的确认，ACK字段置为1，ack字段值为x+1。 客户端接收到服务端的同步报文后，紧接着发送对服务端同步报文的确认报文，其ACK段为1，ack段值为y+1,序列号seq为x+1。 TCP连接关闭关闭过程TCP的关闭又称为四次挥手，表示需要四次报文交换来将双方的链接关闭，其具体的图解过程如下：TCP的链接是双向的，所以链接关闭也需要两次单方向的关闭，具体分为以下四个步骤： 客户端（可以是客户端或者是服务端，这里假设是客户端）发送一个终止报文（FIN字段置位的TCP报文），同时发送自己的序列号seq以及对最近接收到的报文的确认，将ACK置位，设置ack字段(图中没有画出)。 服务端收到客户端的FIN报文后，发送对客户端的FIN报文的确认，将ACK置位，表明已经成功接收到主动关闭者的FIN报文，并发送自己的序列号seq以及对最近接收到的报文的ack。此时可以说TCP的客户端到服务端方向的连接已经关闭，但是另一个方向的链接并未关闭，依然可以进行数据传输，这称为TCP半关闭，如果这时没有数据需要传输，则TCP连接的客户端与服务端角色互换，服务端开始关闭另一端的TCP连接。 服务端发送一个终止报文（FIN字段置位的TCP报文），同时发送自己的序列号seq以及对最近接收到的报文的确认，将ACK置位，设置ack字段。 客户端接收到服务器发送的FIN报文后，发送对此报文的确认，并进入TIME-WAIT阶段，等到2MSL时间之后，连接关闭，在此阶段如果再次收到服务器的FIN+ACK报文，表明自己发送的确认报文丢失，就重新发送ACK报文，并重新设置计时器。 为什么要等待2MSL时间MSL称为最长报文段寿命（Maximum Segment Lifetime）,RFC建议为两分钟，可以自行设定。关于为什么需要等待2MSL（四分钟），这里有两个理由： 对于图中来说，假设客户端最后一个ACK报文丢失，导致服务端没有接收到客户端的确认，此时服务端需要重发一个FIN+ACK的报文，此时如果客户端不等待2MSL时间而直接关闭连接，将导致接收不到服务端重发的FIN+ACK报文，也就导致服务端无法正常进入CLOSE阶段，相反，如果客户端等待2MSL时间，能够接收到服务端重发的FIN+ACK报文，继而重新设置计时器为2MSL,并发送ACK报文，使双方都进入到CLOSE阶段。 等待2MSL时间也会导致上一次的TCP报文在网络中消失，从而避免了上一次TCP传输的报文在下一次的相同结点的TCP连接中的干扰。 TCP的保活机制（转）试想一下，如果已经建立了连接，但是客户端突然出现故障了怎么办？ TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。","categories":[{"name":"NetWork","slug":"NetWork","permalink":"https://super-aviator.github.io/categories/NetWork/"}],"tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://super-aviator.github.io/tags/TCP-IP/"}],"author":"熊乾坤"},{"title":"一次篮球事故","slug":"一次篮球事故","date":"2018-07-30T15:42:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2018/07/30/一次篮球事故/","link":"","permalink":"https://super-aviator.github.io/2018/07/30/%E4%B8%80%E6%AC%A1%E7%AF%AE%E7%90%83%E4%BA%8B%E6%95%85/","excerpt":"","text":"今天晚上发生了一件大事，投篮时不小心把班长的眼球砸了，眼睛有血块，急急忙忙去中医院看了急诊，医生诊断为眼角膜擦伤。 以后打球还是注意下吧，不管是弄伤别人还是自己，都是即费神又费钱的。 sorry","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"https://super-aviator.github.io/tags/%E7%94%9F%E6%B4%BB/"}],"author":"熊乾坤"},{"title":"死锁与哲学家就餐问题","slug":"死锁与哲学家就餐问题","date":"2018-07-30T11:10:00.000Z","updated":"2021-03-14T06:16:00.000Z","comments":true,"path":"2018/07/30/死锁与哲学家就餐问题/","link":"","permalink":"https://super-aviator.github.io/2018/07/30/%E6%AD%BB%E9%94%81%E4%B8%8E%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98/","excerpt":"","text":"在大三下学期，学习了操作系统这门课，感觉原理性的东西非常多，而且学校配的教材《计算机操作系统 汤小丹 第四版》简直无力吐槽，用豆瓣读书中的评论就是重在知识的罗列，好的歹的不管三七二十一把知识点往书上一丢，给人一种‘学生看不看的懂我不管，反正劳资写了’ 的感觉，自己看了几节章后也是云里雾里。所以自己重新买了本《操作系统-精髓与设计原理 第八版》来看，总体感觉还算可以，重点看了并发、进程、内存和调度这几章，文件和IO没有看，有时间补上（这句可以忽略）。 有趣的是，期末考试的时候，声称参加过国家级项目的老师直接从网上copy了一份卷子来考试，原封未动，一字不漏。（手动再见） 死锁概述死锁是一种设计的错误而非操作系统的问题，其具体表现如下。 死锁的现象在操作系统中，资源有两种，可重用资源和可消耗资源，可重用资源指的是不随进程使用而消耗掉的资源，例如系统的IO通道、内存和外存、设备、文件、数据库、信号量等。而可消耗资源指的是信号量，缓冲区，中断等。 对于可重用资源的死锁，例子如下：有A、B进程，运行时需要同时拥有x和y设备，当A拥有x设备后继续申请y设备，B拥有y设备后继续申请x设备时，就会出现两个进程互相等待另一个进程释放所拥有的设备而使得每个进程都不能运行的死锁现象。 对于可消耗资源的死锁，例子如下：A进程等待B进程通过管道发送的消息并且阻塞，直到接受到消息，B进程也在等待A进程通过管道发送的消息并且阻塞，直到接受到消息，此时A进程和B进程也发生了死锁。 死锁发生的条件死锁发生有三个必要而非充分条件：（由A不可以推出B，由B可以推出A，则A是B的必要不充分条件(B⊆≠A)） 互斥访问 值资源只能被一个进程访问，其他进程不能访问已经分配的资源 占有且等待 在等待另一个资源释放时，此进程继续占有已拥有的资源 不可抢占 进程不能抢占其他进程拥有的资源 死锁发生还有第四个条件： 循环等待 存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源。（资源分配图中形成环状结构） 死锁的处理处理死锁有三种方法，一种是采取措施从而消除上面四种情况之一来预防死锁,一种是基于资源的分配来动态选择避免死锁,最后一种是检测死锁并解除死锁。重点放在死锁预防中。 死锁的预防死锁预防分为间接和直接的方式，间接的方式指的是消除三种必要而非充分条件中的一种来避免死锁，直接的方式是指直接防止循环等待的出现来避免死锁。 互斥互斥条件不可能禁止，即使是操作系统允许多个进程同时读一个文件，但是写进程也是互斥的访问，否则，多个进程同时写入会导致文件内容混乱。 占有且等待要禁止占有且等待条件，可以强制进程必须一次申请所需的所有资源，如果没有足够的资源，就阻塞直到资源可用。但是此方法一方面会导致进程阻塞很长时间，一方面在运行过程中不是所有资源都长时间使用，所以会导致资源浪费，而且进程可能不知道运行时所需的资源。 不可抢占禁止不可抢占条件，第一种方案是在进程申请资源被拒绝时，不许释放所占有的资源，在必要时再 进行申请，第二种方案是进程操作系统可以让高优先级的进程抢占低优先级进程所拥有的资源。此方案对于低优先级的进程来说不友好，并且与数据有关的操作需要提供回滚机制。 循环等待循环等待可以定义资源的线性顺序来预防，某进程申请到资源r后，只能申请排在r之后的资源。 为了证明这种方法的正确性，我们模拟一下，假设资源x排在y资源前面，而A先申请x，后申请y，符合规定，而B先申请y，但是不能申请x，从而避免了循环等待。 死锁避免死锁避免与死锁预防很相似，死锁避免是通过判断当前资源分配是否会引起死锁来避免死锁，同时，死锁避免需要知道未来进程资源请求的情况。 两种常见的死锁避免的方法： 如果一个进程启动时申请的资源会导致死锁，则不允许启动 如果一个运行中的进程申请一个资源会导致死锁，则不允许这一资源分配(银行家算法) 死锁的检测在操作系统中，系统会每隔一段时间使用死锁检测算法进行一次死锁检测。因而在资源分配时，不考虑资源申请是否会导致死锁。总是将资源分配给进程。 JAVA解决哲学家就餐问题在thinking in java中有关于哲学家就餐问题的简单解决方法，使用的是死锁预防中，禁止循环等待来预防死锁。 哲学家进餐问题有五个哲学家，他们的生活方式是交替地进行思考和进餐。他们共用一张圆桌，分别坐在五张椅子上。 在圆桌上有五个碗和五支筷子，平时一个哲学家进行思考，饥饿时便试图取用其左、右最靠近他的筷子，只有在他拿到两支筷子时才能进餐。进餐完毕，放下筷子又继续思考。 Java中解决哲学家就餐问题 定义筷子类筷子类中包含有筷子此时的状态信息，以及对筷子的拿起和放下操作。在拿起时，如果筷子的状态为以使用，则此线程进行阻塞，直到筷子可用。在放下时，使用notifyAll唤醒在此筷子上阻塞的另一个哲学家。这满足了死锁发生的三个必要而非充分条件。 class ChopStick &#123; private boolean taked = false; public synchronized void take() throws InterruptedException &#123; while (taked) wait(); taked = true; &#125; public synchronized void drop() &#123; taked = false; notifyAll(); &#125; &#125; 定义哲学家类在哲学家类中实现了Runnable接口，在run方法中，哲学家进行着思考与进食的循环。在构造器中，为哲学家配备了一左一右两支筷子，进餐时，需要首先等待左边的筷子可用，然后等待右边的筷子可用。如果传入的ponder较小，哲学家思考的时间越短，进餐时间越多，也就越容易发生死锁。 class Philosopher implements Runnable &#123; private ChopStick left, right; private int id; public int ponder; public Philosopher(ChopStick left, ChopStick right, int id, int ponder) &#123; this.left = left; this.right = right; this.ponder = ponder; this.id = id; &#125; public void pause() throws InterruptedException &#123; if (ponder == 0) return; else TimeUnit.MILLISECONDS.sleep(200 * ponder); &#125; @Override public void run() &#123; try &#123; while (!Thread.interrupted()) &#123; System.out.println(id + &quot; is thinking!&quot;); pause(); System.out.println(id + &quot; is taking left chopstick!&quot;); left.take(); System.out.println(id + &quot; is taking right chopstick!&quot;); right.take(); System.out.println(id + &quot; is eating food!&quot;); pause(); System.out.println(id + &quot; is drop chopstick!&quot;); left.drop(); right.drop(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 定义main函数首先定义一个包含有五双筷子的数组，和五个哲学家。在有死锁的代码中，每个哲学家都首先拿起左边的筷子，然后拿起右边的筷子，这形成了第四个条件，循环等待，因而会发生死锁。而无锁的代码中，最后一个哲学家与其他哲学家的行为相反，他首先拿起右边的筷子，然后拿起左边的筷子，这无疑避免了循环等待的发生，从而避免了死锁。 public class DeadlockingTest &#123; public static void main(String[] args) throws IOException &#123; int size = 5; ChopStick[] chops = new ChopStick[size]; for (int i = 0; i &lt; size; i++) chops[i] = new ChopStick(); ExecutorService es = Executors.newCachedThreadPool(); /** * 会发生死锁的代码 */ /*for (int i = 0; i &lt; size; i++) es.execute(new Philosopher(chops[i], chops[(i + 1) % size], i, 0));*/ /** * 通过破坏循环等待的死锁条件来避免死锁 */ for(int i=0;i&lt;size;i++)&#123; if(i&lt;size-1) es.execute(new Philosopher(chops[i], chops[(i + 1) % size], i, 0)); else es.execute(new Philosopher(chops[0],chops[i],i,0)); &#125; es.shutdown(); System.out.println(&quot;enter to exit!&quot;); System.in.read(); es.shutdownNow(); &#125; &#125;","categories":[{"name":"OperationSystem","slug":"OperationSystem","permalink":"https://super-aviator.github.io/categories/OperationSystem/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://super-aviator.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"锁","slug":"锁","permalink":"https://super-aviator.github.io/tags/%E9%94%81/"}],"author":"熊乾坤"},{"title":"JavaNIO学习-基于channel的非阻塞聊天程序","slug":"vaNIO之基于channel的非阻塞聊天程序","date":"2018-07-18T09:02:00.000Z","updated":"2021-02-23T13:00:00.000Z","comments":true,"path":"2018/07/18/vaNIO之基于channel的非阻塞聊天程序/","link":"","permalink":"https://super-aviator.github.io/2018/07/18/vaNIO%E4%B9%8B%E5%9F%BA%E4%BA%8Echannel%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"概述查看代码这几天学习了java中NIO的部分，对一些常用的IO模型有了一些了解，同时学习了NIO中的三个非常重要的模块，缓冲区（Buffer）、通道(Channel)和选择器(Selector)，其中选择器是实现IO多路复用的最关键的部件，同样在NIO中也是最重要的学习部分，不过，首先通过实现一个非常简单的聊天程序，来巩固一下通道和缓冲的知识吧。 运行截图由于没有图形界面，所有操作都通过命令行进行，这也使得服务端同时和多个客户端通话带来麻烦，但我们的目的是学习，而不是做出如何优美的界面。（我要是会的话我不早做了 T_T）所以凑活看看吧。 服务端： 客户端： 功能解析ByteBuffer直接缓冲区NIO中除了boolean,其他各种基本类型都有对应的缓冲区，其中最重要的缓冲区便是字节缓冲区（ByteBuffer），因为直接与通道打交道的缓冲区只能是字节缓冲区，而字节缓冲区也有两种类型，非直接缓冲区和直接缓冲区，非直接缓冲区在读写性能上要次于直接缓冲区，因为直接缓冲区值分配在JVM进程堆内存之外的空间中，不受JVM管理，读写时也会避免内存的拷贝，所以性能更好，但是直接缓冲区申请的效率比非直接缓冲区低，因为直接缓冲区需要使用到系统调用。 同时，在字节缓冲区中可以创建其他类型缓冲区的视图，也可以通过putXXX直接以其他基本类型的字节长度来存放其他基本类型的数据。非常方便。 需要注意的是缓冲区操作需要时刻注意position、limit的位置，以及flip,clear,rewind几种方法的合理使用。 非阻塞模式的通道常规的Socket,ServerSocket是阻塞的，所以在读取操作或accpet操作会一直阻塞。而ScoketChannel,ServerScoketChannel可以通过SelectableChannel接口中的configureBlocking(false)方法将其设置为非阻塞模式。 与阻塞模式不同的是，非阻塞模式会立即返回一个结果，而不是让线程睡眠直到结果出现。非阻塞模式的缺点是需要使用轮训的方式来查看结果。其常用的方式如下所示： while((true)&#123; SocketChannle socketChannel = serverSocketChannel.accpet(); if(scoketChannel==null) continue; //dosomething &#125; 因为accept方法会立即返回，如果此时没有链接，那么将返回null,如果有连接时将返回一个SocketChannel。 如果使用选择器（Selector）,可以只使用一个线程去轮训所有的通道，并在有结果返回时做出相应读取操作。 读写线程在服务端和客户端，每一条TCP链接都需要使用两个线程去读Socket中的数据或向Socket中写入数据。 需要注意的是非阻塞模式下的读操作同样是立即返回的，所以读入的字节数可能为0，需要特殊处理。 而写操作需要将System.in包装成BufferedReader,而其readLine方法是阻塞的，所以在你按下回车之前，写线程会阻塞在readLine方法上，等待你的输入，这也是截图中，客户端正在等待用户输入的一行会出现服务器发来的消息的原因。 代码实现服务端import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.InetAddress; import java.nio.ByteBuffer; import java.io.IOException; import java.net.InetSocketAddress; import java.nio.channels.ServerSocketChannel; import java.nio.channels.SocketChannel; import java.util.Scanner; public class Server &#123; public static void main(String[] args) throws IOException &#123; //获取服务端的IP地址 System.out.println(&quot;你的IP地址为 &quot; + InetAddress.getLocalHost().getHostAddress()); //自定义端口号，默认为1234 int port = 1234; Scanner reader = new Scanner(System.in); System.out.print(&quot;端口(默认1234)：&quot;); String tempPortString = reader.nextLine(); int tempPort = 0; if (tempPortString.length() != 0) &#123; tempPort = Integer.valueOf(tempPortString); &#125; if (tempPort &lt;= 65535 &amp;&amp; tempPort &gt;= 1024) port = tempPort; //创建ServerSocketChannel并绑定端口。 ServerSocketChannel server = ServerSocketChannel.open(); server.socket().bind(new InetSocketAddress(port)); server.configureBlocking(false);//设置为非阻塞模式 while (true) &#123; try &#123; SocketChannel socket = server.accept(); //ServerSocketChannel非阻塞模式下accept会立即返回，如果此时没有链接将返回null if(socket==null) continue; socket.configureBlocking(false);//设置为非阻塞模式 if (socket.finishConnect()) System.err.println(socket.getRemoteAddress() + &quot; 已经连接！(输入exit结束聊天)&quot;); //获取IP地址 String temp = socket.getRemoteAddress().toString(); String IP = temp.substring(temp.indexOf(&#39;/&#39;) + 1, temp.indexOf(&#39;:&#39;)); //开启读线程和写线程 new ServerReadHandlerThread(socket, IP); new ServerWriteHandlerThread(socket, IP); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; class ServerReadHandlerThread extends Thread &#123; private SocketChannel server; private String header; private ByteBuffer buffer = ByteBuffer.allocateDirect(100); public ServerReadHandlerThread(SocketChannel server, String IP) &#123; this.server = server; header = IP; start(); &#125; public void run() &#123; try &#123; while (true) &#123; buffer.clear(); //非阻塞模式下可能读取字节数为0,需要使用轮训的方式 while (server.read(buffer) &lt;= 0) ; buffer.flip(); printMeg(buffer); &#125; &#125; catch (IOException e) &#123; System.out.println(header + &quot; 连接断开！&quot;); &#125; finally &#123; if (server.isConnected()) &#123; try &#123; server.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; private void printMeg(ByteBuffer buffer) &#123; System.out.print(&quot;\\n--------------------\\n&quot; + header + &quot;:&quot;); while (buffer.hasRemaining()) System.out.print(buffer.getChar()); System.out.println(&quot;\\n--------------------&quot;); &#125; &#125; class ServerWriteHandlerThread extends Thread &#123; private SocketChannel server; private String header; private ByteBuffer buffer = ByteBuffer.allocateDirect(100); private BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); public ServerWriteHandlerThread(SocketChannel server, String IP) &#123; this.server = server; header = IP; start(); &#125; public void run() &#123; try &#123; while (true) &#123; System.out.print(&quot;请输入：&quot;); String meg = in.readLine(); if (!server.isConnected()) break; if (meg.equals(&quot;exit&quot;)) break; buffer.clear(); for (int i = 0; i &lt; meg.length(); i++) buffer.putChar(meg.charAt(i)); buffer.flip(); while (buffer.hasRemaining()) server.write(buffer); &#125; &#125; catch (IOException e) &#123; System.out.println(header + &quot; 连接断开！&quot;); &#125; finally &#123; try &#123; if (server.isConnected()) server.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 客户端import java.util.*; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.net.InetSocketAddress; import java.nio.channels.SocketChannel; import java.nio.ByteBuffer; public class Client &#123; public static void main(String[] args) throws IOException, InterruptedException &#123; //默认主机和端口号 String host = &quot;localhost&quot;; int port = 1234; //自定义主机和端口号 Scanner reader = new Scanner(System.in); System.out.print(&quot;ip地址(默认localhost)：&quot;); String tempHost = reader.nextLine(); if (tempHost.length() != 0) host = tempHost; System.out.print(&quot;端口(默认1234)：&quot;); String tempPortString = reader.nextLine(); int tempPort = 0; if (tempPortString.length() != 0) &#123; tempPort = Integer.valueOf(tempPortString); &#125; if (tempPort &lt;= 65535 &amp;&amp; tempPort &gt;= 1024) port = tempPort; //建立链接 SocketChannel client = SocketChannel.open(new InetSocketAddress(host, port)); client.configureBlocking(false); while (!client.finishConnect()) &#123; System.out.println(&quot;连接中。。。&quot;); Thread.sleep(100); System.out.println(&quot;\\r&quot;); &#125; System.out.println(&quot;连接成功！(输入exit结束聊天)&quot;); String temp = client.getRemoteAddress().toString(); String IP = temp.substring(temp.indexOf(&#39;/&#39;) + 1, temp.indexOf(&#39;:&#39;)); new ClientReadHandlerThread(client, IP); new ClientWriteHandlerThread(client, IP); &#125; &#125; class ClientReadHandlerThread extends Thread &#123; private SocketChannel server; private ByteBuffer buffer = ByteBuffer.allocateDirect(100); private String header; public ClientReadHandlerThread(SocketChannel server, String IP) &#123; this.server = server; header = IP; start(); &#125; public void run() &#123; try &#123; while (true) &#123; buffer.clear(); while (server.read(buffer) &lt;= 0) ; buffer.flip(); printMeg(buffer); &#125; &#125; catch (IOException e) &#123; System.out.println(header + &quot; 连接断开！&quot;); &#125; finally &#123; if (server.isConnected()) &#123; try &#123; server.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; private void printMeg(ByteBuffer buffer) &#123; System.out.print(&quot;\\n--------------------\\n&quot; + header + &quot;:&quot;); while (buffer.hasRemaining()) System.out.print(buffer.getChar()); System.out.println(&quot;\\n--------------------&quot;); &#125; &#125; class ClientWriteHandlerThread extends Thread &#123; private SocketChannel server; private String header; private ByteBuffer buffer = ByteBuffer.allocateDirect(100); private BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); public ClientWriteHandlerThread(SocketChannel server, String IP) &#123; this.server = server; header = IP; start(); &#125; public void run() &#123; try &#123; while (true) &#123; System.out.print(&quot;请输入：&quot;); String meg = in.readLine(); if (!server.isConnected()) break; if (meg.equals(&quot;exit&quot;)) break; buffer.clear(); for (int i = 0; i &lt; meg.length(); i++) buffer.putChar(meg.charAt(i)); buffer.flip(); while (buffer.hasRemaining()) server.write(buffer); &#125; &#125; catch (IOException e) &#123; System.out.println(header + &quot; 连接断开！&quot;); &#125; finally &#123; try &#123; if (server.isConnected()) server.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Java NIO","slug":"Java-NIO","permalink":"https://super-aviator.github.io/tags/Java-NIO/"}],"author":"熊乾坤"},{"title":"祝我生日快乐","slug":"祝我生日快乐","date":"2018-07-08T15:11:00.000Z","updated":"2021-02-23T13:00:02.000Z","comments":true,"path":"2018/07/08/祝我生日快乐/","link":"","permalink":"https://super-aviator.github.io/2018/07/08/%E7%A5%9D%E6%88%91%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/","excerpt":"","text":"感谢在我生日这天送上祝福的朋友们，我爱你们","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"https://super-aviator.github.io/tags/%E7%94%9F%E6%B4%BB/"}],"author":"熊乾坤"},{"title":"我，想学打篮球","slug":"我，熊老二，想学打篮球","date":"2018-07-04T14:15:00.000Z","updated":"2021-02-23T13:00:08.000Z","comments":true,"path":"2018/07/04/我，熊老二，想学打篮球/","link":"","permalink":"https://super-aviator.github.io/2018/07/04/%E6%88%91%EF%BC%8C%E7%86%8A%E8%80%81%E4%BA%8C%EF%BC%8C%E6%83%B3%E5%AD%A6%E6%89%93%E7%AF%AE%E7%90%83/","excerpt":"","text":"&emsp;&emsp;前天跟着班长去学习了一下打篮球，其实一直想学一学篮球，感觉男生不会篮球还是很丑滴一件事，但是没学的原因有两个：一是没有人教，二是沉迷学习，日渐羞涩（就是怕丑），所以一直没有学成，前天班长打球顺便跟着去学了一下基本的运球，投球，上篮。&emsp;&emsp;高中踢过两年足球，两年一直是后卫T_T,踢球连对方半场去都没去过的那种。。。主要就是基本功太差了，拿到球带不了球，一带就丢，还好脚劲还行，球来了一jio踢到对面半场就算完成任务了，确实是以前没有接触过足球，平时也没有地方去练习。&emsp;&emsp;在我二十几年的学生生涯中，差不多就打过两次篮球，小学六年级一次（貌似因为不会还被嫌弃了），初中一次，我清楚的记得小学趁着着过年坐老爸的摩托车去镇上办年货，到买文具的商店里，叫我爸给我买一个篮球，我爸极不情愿的问了老板最便宜的多少钱一个，老板说四十一个。结果老爸头也不回的就走了，走了，了。。。难过(ಥ﹏ಥ)（等我有了孩子我要砸锅卖铁也要给他买买买）。一个篮球巨星就此陨落。（好像还没升起哦） &emsp;&emsp;从前天到今天这两次练习中（昨天下雨没去），收获还是很大滴，从技术上来说，第一次打球状况惨不忍睹，莫名感觉有点像帕金森。投篮也感觉使不上力，经常是三不沾。今天明显好一点了，不像昨天那样满地找球，投篮也基本挨到篮筐了。开心。T_T；心态上也有很大的收获，从昨天的：“不要笑我，不要笑我，我只是一只菜鸟QAQ”到今天的：“劳资胖虎就是菜，等我练会了就锤死在坐的各位”，心态变化是很大滴。&emsp;&emsp;最后希望自己再接再厉，多练练基本功，相信进步会很大。嗯。&emsp;&emsp;真心感谢班长魏椰丰。![猫][image][image]:data:image/jpeg;base64,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","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"https://super-aviator.github.io/tags/%E7%94%9F%E6%B4%BB/"}],"author":"熊乾坤"},{"title":"Java中IO的几种常用组合","slug":"Java中IO的几种常用组合","date":"2018-07-03T13:27:00.000Z","updated":"2021-02-23T13:00:04.000Z","comments":true,"path":"2018/07/03/Java中IO的几种常用组合/","link":"","permalink":"https://super-aviator.github.io/2018/07/03/Java%E4%B8%ADIO%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%BB%84%E5%90%88/","excerpt":"","text":"今天主要复习了thinking in java 中java中的io部分,以前看过一段时间，不过现在都忘得差不多了。T_T,学过之后不常用总是会忘得很快，不过一遍遍的学过和忘记,在每次重新学习的时候捡起来会比较快。java中的io大致分为两类，字符流（Reader/Writer）和字节流(InputStream/OutPutStream)，涉及到的类也相当多，要真正精通应该是很困难滴，所以我准备记住几种常用的组合就ok啦（什么?你说我学习不认真？小心我顺着网线过去打你，哈哈哈），然后自己写一个非常大（我自己差点信了）的程序巩固一下。明天开始啃nio部分。 几种常见的组合通过BufferedReader类编写echo回显程序 由于System.in是一个未经包装的InputStream，所以我们需要将他通过InputStreamReader包装成一个BufferedReader,然后通过BufferedReader中的readLine来读取用户的输入字符： package io; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Echo &#123; public static void main(String[] args) throws IOException &#123; BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); String item; while ((item = reader.readLine()) != null &amp;&amp; item.length() != 0) System.out.println(item); &#125; &#125; 当不输入任何字符直接回车时，会退出程序，达到终止程序的目的。 读取文件内容到控制台package io; import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; public class BufferedInputFile &#123; public static String read(String path) throws IOException&#123; BufferedReader reader=new BufferedReader(new FileReader(path)); StringBuilder sb=new StringBuilder(); String temp; while((temp=reader.readLine())!=null) sb.append(temp+&quot;\\n&quot;); reader.close(); return sb.toString(); &#125; public static void main(String[] args) throws IOException&#123; BufferedReader sb=new BufferedReader(new InputStreamReader(System.in)); String path=sb.readLine(); System.out.println(read(path)); &#125; &#125; 需要注意的是BufferedReader中的readLine()方法会自动删除读取的一行的换行符，则在显示时需要手动加上\\n进行换行 控制台字符输出到文件package io; import java.io.*; public class CopyFile &#123; public static void main(String[] args) throws IOException&#123; BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); File out=new File(&quot;C:\\\\Users\\\\Aviator\\\\Desktop\\\\test.txt&quot;); if(!out.exists()) out.mkdir(); PrintWriter writer =new PrintWriter(new OutputStreamWriter( new FileOutputStream(out,true),&quot;utf-8&quot;));//指定utf8编码和进行追加 String item; while ((item = reader.readLine()) != null &amp;&amp; item.length() != 0) writer.println(item); writer.close(); &#125; &#125; 如上，在InputStream/OutputStream中第二个参数可以指定编码类型，将字节流通过指定字符集，编码为字符流，FileOutputStream/FileInputStream中的第二个参数指定是否为追加，为true则追加到文件末尾，为false或者不指定则为不追加。最后，如果不存在你说指定的文件夹中没有指定的文件，则会自动创建目标文件。test.txt,而文件夹则需要自己使用exsits 方法检查是否存在并mkdir方法进行创建。 合并两个文件package io; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.SequenceInputStream; public class MergeTwoFiles &#123; public static void main(String[] args) throws IOException&#123; FileInputStream f1=new FileInputStream (&quot;path1&quot;); FileInputStream f2=new FileInputStream(&quot;path2&quot;); SequenceInputStream in=new SequenceInputStream(f1,f2); FileOutputStream out=new FileOutputStream (&quot;C:\\\\Users\\\\Aviator\\\\Desktop\\\\copy.txt&quot;,true); byte[] temp=new byte[1024]; int length; while((length=in.read(temp))!=-1) out.write(temp,0,length); out.close(); &#125; &#125; 如上，SequenceInputStream类可以将两个或两个以上的流合并为一个流，在调用read方法时，会依次读取每一个流的内容，直到最后一个流的末尾时返回-1。读取结束。 文件的缓存使用DataInput/OutputStream类可以实现类似于缓存的读写方式。示例如下： package io; import java.io.*; public class StoringAndRecoveringData &#123; public static void main(String[] args) throws IOException&#123; DataOutputStream out=new DataOutputStream (new BufferedOutputStream(new FileOutputStream (&quot;C:\\\\Users\\\\Aviator\\\\Desktop\\\\copy.txt&quot;))); out.writeUTF(&quot;this is a buffer for data&quot;); out.writeInt(222); out.writeUTF(&quot;ok next write a double&quot;); out.writeDouble(12.23); out.close(); DataInputStream in =new DataInputStream(new BufferedInputStream (new FileInputStream(&quot;C:\\\\Users\\\\Aviator\\\\Desktop\\\\copy.txt&quot;))); System.out.println(in.readUTF()); System.out.println(in.readInt()); System.out.println(in.readUTF()); System.out.println(in.readDouble()); &#125; &#125; DataInputStream/DataOutputStream类拥有格式化输入输出的方法，能够对基本数据类型进行读写,每一个writeXXX都有对应的readXXX，而且是跨平台的方式进行，非常强大。值得注意的是，如果要写入字符串，则应该使用writeUTF方法进行写入，同时使用对应的readUTF方法进行读取，这两个方法实际是使用的修改过的UTF编码进行读写，必须配套使用才能正确得到想要的信息。 文件夹拷贝（所谓的大程序）package io; import java.io.*; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class CopyDirectory &#123; public static void copyDirectory(String inPath, String outPath) throws IOException &#123; File fileIn = new File(inPath); if (!fileIn.exists()) fileIn.mkdir(); if (!fileIn.isDirectory()) &#123; System.out.println(inPath + &quot; is not a directory &quot;); return; &#125; File fileOut = new File(outPath); if (!fileOut.exists()) fileOut.mkdir(); if (!fileOut.isDirectory()) &#123; System.out.println(inPath + &quot; is not a directory &quot;); return; &#125; File[] files = fileIn.listFiles(); if (files.length == 0) return; List&lt;File&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, files); FileOutputStream out = null; FileInputStream in; byte[] item = new byte[1024]; int length; try &#123; for (int i = 0; i &lt; list.size(); i++) &#123; File temp = list.get(i); if (temp.isDirectory()) &#123; copyDirectory(temp.getAbsolutePath(), outPath + &quot;\\\\&quot; + temp.getName());//当遇到文件夹时，递归进行拷贝。 continue; &#125; out = new FileOutputStream(outPath + &quot;\\\\&quot; + temp.getName()); in = new FileInputStream(temp); while ((length = in.read(item)) != -1) out.write(item, 0, length); &#125; out.close(); &#125; catch (FileNotFoundException e) &#123; System.out.println(&quot;文件夹不存在&quot;); &#125; &#125; public static void main(String[] args) throws IOException &#123; BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); System.out.print(&quot;请输入你想要拷贝的文件夹的路径：&quot;); String inPath = in.readLine(); System.out.print(&quot;\\n请输入你想要存放的路径：&quot;); String outPath = in.readLine(); copyDirectory(inPath, outPath); System.out.println(&quot;拷贝完成！&quot;); &#125; &#125; 特别重要的是，如果想要拷贝的文件夹中含有子文件夹，则需要对子文件夹进行拷贝。扩展程序的功能。 几种判断是否读取到文件末尾的方法 对于读取字节流，如果读入整数的结果为-1，则表示到达文件末尾: while((i=in.read())!=-1) 对于读取字符流，如果读入的结果是null, 则表示到达文件末尾:while((str=in.read)!=null) 对于使用按字节读取的方法readByte，可以使用whiel(in.available)方法判断是否到达文件末尾，不过在多线程中此方法不稳定 对于每次读取byte数组的方法，可以通过安排判断读取到的byte数组的长度来判断是否到达了文件末尾while((length=in.read(bytes))!=0) 对于会产生EOFException异常的操作，也可以使用捕获try块中的异常来判断是否读取到文件末尾 字符串的编码(encode)与解码(decode)package io; import java.io.UnsupportedEncodingException; public class InCodeAndDeCode &#123; public static void main(String[] args) throws UnsupportedEncodingException &#123; String str=&quot;熊乾坤&quot;; byte[] bytes=str.getBytes(&quot;GBK&quot;);//编码 String str1=new String(bytes,&quot;GBK&quot;);//解码 System.out.println(str1); &#125; &#125; 如上，通过String对象的getBytes(“编码类型”)将字符串进行编码，使用String类的构造方法将字符串进行解码。非常方便的。嗯。","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Java疑惑解答","slug":"Java疑惑解答","permalink":"https://super-aviator.github.io/tags/Java%E7%96%91%E6%83%91%E8%A7%A3%E7%AD%94/"}],"author":"熊乾坤"},{"title":"字符串全排列的递归实现","slug":"全排列的递归实现","date":"2018-07-02T02:58:00.000Z","updated":"2021-02-23T13:00:10.000Z","comments":true,"path":"2018/07/02/全排列的递归实现/","link":"","permalink":"https://super-aviator.github.io/2018/07/02/%E5%85%A8%E6%8E%92%E5%88%97%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"数据结构与算法分析第三版中，有一道习题很有趣，想了半天也没想出来，网上搜了答案后恍然大悟，题目描述如下： 练习1.6 编写带有下列声明的例程： public void permute(String str); public void permute(char[] str, int low, int high); 第一个例程是个驱动程序，它调用第二个例程并显示String str中的字符的所有排列。 如果str是&quot;abc&quot;，那么输出的串则是abc,acb,bac,bca,cab和cba。第二个例程使用递归。 简单来说就是使用递归实现全排列。标准答案如下： public class T6 &#123; public static void permute(String str) &#123; permute(str.toCharArray(), 0, str.length() - 1); &#125; public static void permute(char[] str, int lo, int hi) &#123; if (hi == lo) &#123; System.out.println(String.valueOf(str)); &#125; else &#123; for (int i = lo; i &lt;= hi; i++) &#123; swap(str, lo, i); permute(str, lo + 1, hi); swap(str, lo, i); &#125; &#125; &#125; public static void swap(char[] str, int lo, int hi) &#123; char temp = str[lo]; str[lo] = str[hi]; str[hi] = temp; &#125; public static void main(String[] args) &#123; permute(&quot;ab&quot;); &#125; &#125; 代码实现非常巧妙，执行流程如图，在permute函数中，for循环中首先将i和lo交换，相当于控制str中的每一个首字母都有一次出现在字符串第一个字母的机会，当i和lo交换完毕后，递归的对i后面的字母进行全排列，回溯时将交换过的字母复原。当lo和hi相等时，打印出str数组。学习了。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://super-aviator.github.io/categories/Algorithm/"}],"tags":[{"name":"算法疑惑解答","slug":"算法疑惑解答","permalink":"https://super-aviator.github.io/tags/%E7%AE%97%E6%B3%95%E7%96%91%E6%83%91%E8%A7%A3%E7%AD%94/"}],"author":"熊乾坤"},{"title":"Java泛型与数组","slug":"Java泛型通配符","date":"2018-07-01T04:30:00.000Z","updated":"2021-02-23T13:00:04.000Z","comments":true,"path":"2018/07/01/Java泛型通配符/","link":"","permalink":"https://super-aviator.github.io/2018/07/01/Java%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6/","excerpt":"","text":"在学习Thinking in java这本书时，发现泛型是其介绍的比较多的一个章节，而且这一张的后半部分确实有点晦涩难懂，让我读起来头皮发麻T_T,主要就是三种通配符的使用不是很理解，反复读了Thinking in java中解释，也看了知乎上别人的文章，总算是有点头绪了，这里按照常理记录一下，方便以后回来瞅一瞅。 在讨论泛型之前，我们首先假设有如下的继承关系 class Fruit&#123;&#125; class Apple extends Fruit&#123;&#125; class Orange extends Fruit&#123;&#125; class HongFuShi extends Apple&#123;&#125; 泛型通配符之子类型通配符&lt;? extends MyClass&gt;首先通过下面的代码来揭示子类型通配符的特性： public class SubtypeWildcard &#123; public static void main(String[] args) &#123; List&lt;? extends Fruit&gt; list1=new ArrayList&lt;&gt;(); list1.add(new Apple());//compile error list1.add(new Fruit());//compile error list1.add(new Orange());//compile error list1.add(new Object());//compile error list1.add(null);//ok &#125; &#125; 如上，list1中的类型参数为&lt;? extends Fruit&gt;,我们称指定了泛型的上界为Fruit,表示某种继承自Fruit的类型，按照常理，list1应该可以放一些Apple或者Orange类，但是事实并非如此，list1不能放任何对象，除了null。 对于这一现象的解释是：&lt;? extends Fruit&gt;表示某种继承自Fruit的类型，但是通配符引用的是明确的类型，它意味着某种list1没有明确表明的类型，可能是Apple,可能是Orange,可能是继承自Fruit的任何类型，当我们想在list1中放入一个对象时，编译器无法保证这个list1是否可以持有这种类型。例如我们向其中添加一个Apple对象，但是如果List是一个List&lt;Orange&gt;，这时就会造成混乱。 但是从list1中读一个对象总是安全的，因为子类型通配符保证了从list1中取出的一定是某一种Fruit,我们也可以对取出的对象进行转型，但是可能会得到一个ClassCastException异常。如下所示。 public class SubtypeWildcard &#123; public static void main(String[] args) &#123; List&lt;Fruit&gt; list1=new ArrayList&lt;&gt;(); list1.add(new Apple()); list1.add(new Fruit()); list1.add(new Orange()); List&lt;? extends Fruit&gt; list2=list1; Fruit f=list1.get(0);//ok f=list1.get(1);//ok //f=(Apple)list1.get(2);//ClassCastException f=(Orange)list1.get(2); &#125; &#125; 泛型通配符之超类型通配符&lt;? super MyClass&gt;超类通配符又称为逆变，它的特性由如下代码引出： public class SupertypeWildcard &#123; public static void main(String[] args) &#123; List&lt;? super Apple&gt; list1=new ArrayList&lt;&gt;(); list1.add(new Apple()); list1.add(new HongFuShi()); list1.add(new Orange());//compile error list1.add(new Fruit());//compile error &#125; &#125; 超类型通配符&lt;? super Apple&gt;表示list1持有的是Apple基类型的对象，我们说指定了泛型的下界，即lsit1是Apple的某种基类型的List,这样你就可以向其中添加Apple或者Apple的子类了。这是安全的。因为一个子类可以协变到其父类。但是如上代码说看到的，向其中添加Fruit或者Orange是不安全的，同样是因为不能够确定Apple父类是哪一种具体的类型。 如上所述，向拥有超类型通配符的容器添加对象是安全的，但是从容器中取出一个对象却是不安全的。因为编译器依旧不能知道原始的类型是什么，因为 Fruit和Object都是Apple的父类，所以这时候调用 get 方法时就只能拿出一个 Object 对象，因为它是根类型，再没有父类了，这时候就需要动态判断元素的类型来做后续处理了。进行强制类型转换同样可能得到ClassCastException异常。 public class SupertypeWildcard &#123; public static void main(String[] args) &#123; List&lt;? super Apple&gt; list1=new ArrayList&lt;&gt;(); list1.add(new Apple()); list1.add(new HongFuShi()); Fruit f1=list1.get(0);//compile error Apple f2=list1.get(0);//compile error Object f3=(Apple)list1.get(0);//ok Object f3=(HongFuShi)list1.get(0);//ClassCastException &#125; &#125; 泛型通配符之无界通配符以及List&lt;?&gt;和List、List&lt; Ojbect&gt;的区别《Effective Java 第二版》中对于List（原生态类型）、List&lt;Object&gt;（参数化类型）和List&lt;?&gt;（无界通配符）有非常详细的讲解。List表示可以持有任何类型的对象，它逃避了泛型的类型检查，是不安全的，允许使用原生态类型只是为了兼容旧代码，在Java5之后的代码中不应该再使用原生态类型。List&lt;Object&gt;在功能上和原生态类型相同，可以添加任意类型的对象，但是它拥有泛型所具备的类型安全性。List&lt;?&gt;使用了无界通配符,表示持有某种未知类型的对象，但是由于是泛型的，所以和List&lt;Object&gt;一样拥有类型安全性，由于向原生态类型（List）中加入不同类型的元素会导致程序运行时异常，无界通配符类型(List&lt;?&gt;)为了防止你破坏集合的类型约束，不允许向集合中添加任何对象以防止安全性被破坏（除了null之外），而且也无法确定你会得到什么类型。 import java.util.*; public class UnboundedWildcard &#123; public static void main(String[] args) &#123; List&lt;?&gt; list1=new ArrayList&lt;&gt;(); list1.add(new Apple());//compile error List list2=new ArrayList(); list2.add(new Object()); list2.add(new Apple()); &#125; &#125; 如上代码所示，list1由于有了无界通配符，编译器无法知道list1应该持有何种具体的类型，因而拒绝向list中添加任何类型。 总的来说，在Java5 之后的代码不应该使用原生态类型，值得注意的是，这条规则有两个例外： 在使用类字面常量.class时必须使用原生态类型：List.class、String[].class、int.class是合法的，而List&lt;String&gt;.class、List&lt;?&gt;是非法的，因为类字面常量中使用了泛型。 在使用关键字instanceof时应该使用原生态类型，因为泛型的类型信息在运行时会被擦除，所以在使用参数化类型上使用instanceof是非法的，而在无界通配符上使用instanceof是合法的，但是其意义和作用和原生态类型一样，所以应该是使用原生态类型，在使用instanceof进行比较之后，应该立即将参数转换为无界通配符类型，而不是转换为原始类型，这是一个受检查转换，不会导致异常，代码实例如下： if(o instanceof Set)&#123;//shuld use raw type Set&lt;?&gt; temp=(Set&lt;?&gt;)o; temp... &#125; 数据与列表的区别之协变性和不可变性以及可具体化和不可具体化数组的协变性是指如果Sub是Super的子类型，则Sub[]也是Super[]的子类型。而List&lt;Sub&gt;则不是List&lt;Super&gt;的子类型，这种特性称之为不可变性。数组的协变性会导致数组因持有错误的类型但是编译通过而运行时抛出java.lang.ArrayStoreException异常： Ojbect[] str=new String[]&#123;&quot;123&quot;,&quot;456&quot;&#125;; str[0]=1;//compile success but runtime throw Exception 而不可变性则不会出现这种错误： ArrayList&lt;Object&gt; str=new ArrayList&lt;String&gt;();//compile error 这是因为List&lt;String&gt;不是List&lt;Object&gt;的子类型，并且在编译时就可以知晓错误。 可具体化的是指在编译时不知道所持有的对象类型，在运行时才知道所持有的对象类型，数组属于可具体化的，而不可具体化的指在运行时知道的所持有的对象类型信息少于编译时知道所持有的对象类型信息。泛型则是不可具体化的。由于上述数组和泛型相对立的属性，导致数组和泛型不能很好的配合使用，例如不能够创建泛型数组（new List&lt;E&gt;[]、new List&lt;String&gt;[]），类型参数数组(new E[])。值得注意的是唯一的例外是创建无界通配符的数组是合法的，例如new List&lt;?&gt;[]、new Map&lt;?,?&gt;[]是合法的。 创建类型参数数组（E[]）的两种方法由于泛型是不可变且不可具体化的，而数组是协变的且可具体化的，所以数组在编译时没有类型安全性而提供了运行时的类型安全性，泛型则提供了编译时的类型安全性而没有运行时的类型安全性。由于这种对立的特性，不能够创建类型参数数组：E[] e=new E[8];,同时在泛型代码中应该优先使用列表而不是数组。但是有一些情况不可或缺的要使用到数组，例如ArrayList的底层数据和HashMap的散列桶集合，其实有两种方法来创建类型参数数组： 第一种方法是直接创建Object[]，然后将其转型为E[]:E[] e=(E[]) new Object[10],但是这种方法在整体而言是不安全的,你必须自己确保程序的类型安全性，即必须要确保e在类的私有域中并且不会被返回到客户端中，同时只能存储类型为E的对象，实例如下： public class Test&lt;E&gt; &#123; private E[] elements;//类型参数数组引用应该保存在私有域中 public static void main(String[] args)&#123; Test&lt;String&gt; test=new Test&lt;&gt;(); test.setArr(&quot;absdf&quot;); String[] str=test.getEle();//compile error:java.lang.ClassCastException //elements引用不能传递到客户端， 尽管类型正确，但是还是会报类型转换异常 &#125; @SuppressWarnings(&quot;unchecked&quot;) public void setArr(E e)&#123;//只能通过setArr方法来存储类型为E的对象 elements= (E[]) new Object[10]; elements[0]=e; &#125; public E[] getEle()&#123; return elements; &#125; &#125; 第二中方法是在类的内部使用Ojbect[]数组,在需要得到类型E对象的地方进行强制转换：E e=(E)elements[0]，这种方法在每个需要得到类型E的对象的地方都需要显式的进行转换，相比第一种方法更加繁琐。 两种创建参数类型的数组的方法效果一样，使用哪一种看个人喜好QAQ。","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Java疑惑解答","slug":"Java疑惑解答","permalink":"https://super-aviator.github.io/tags/Java%E7%96%91%E6%83%91%E8%A7%A3%E7%AD%94/"}],"author":"熊乾坤"},{"title":"信息的表示与处理之信息存储","slug":"信息的表示与处理之信息存储","date":"2018-06-24T11:15:00.000Z","updated":"2021-02-23T13:00:00.000Z","comments":true,"path":"2018/06/24/信息的表示与处理之信息存储/","link":"","permalink":"https://super-aviator.github.io/2018/06/24/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86%E4%B9%8B%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8/","excerpt":"","text":"序言&emsp;&emsp;6月22号左右所有的考试终于完成了，我也终于有时间静下心来弄自己的事了，花了两天时间看了《深入理解计算机系统》CSAPP这本书的第二章，受益匪浅，以前不太理解的位级运算现在有了清晰的定义，对于补码和浮点数的表示和运算也了解了一些。按照惯例，总结一下。方便以后回来瞅一瞅。 整数表示与运算&emsp;&emsp;在c语言中整数有两种形式，即有符号和无符号整数，而在java中只有有符号表示方法，有符号表示方法统一使用补码表示，而无符号则使用原码的方式。我们首先来看一看进制相关的转换。 十六进制（hexadecimal）&emsp;&emsp;十六进制中，四位二进制表示一位十六进制的数字，所以如果二进制写法太冗余，不便于观察，就可以将其转换为十六进制，方便书写。他们之间的转换规则如下： 进制\\位数 高位 低位 十六进制数 1 7 3 a 4 c 二进制数 0001 0111 0011 1010 0100 1100 注意，二进制转换为十六进制时，应该从低位到高位四位一组，不够补0。 在将十进制转换为十六进制时，如果数是2的x次幂，那么可以写为：1后面跟x个0. 字节顺序之大小端之争（big endian/little endian）&emsp;&emsp;对于跨越多字节程序对象，我们需要知道如何排列这些字节，在计算机中有两种存放的方式，某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，这称之为小端法，某些机器从最高有效字节到最低有效字节的顺序存放，称之为大端法。&emsp;&emsp;总的来说，小端法使用低地址存放数据的高有效字节，大端法使用低地址存放低有效字节。例如对于十六进制数0x01234567，存储方式如下(十六进制中01是高有效字节，67为低有效字节)： 存储方式\\地址顺序 0x100 0x 101 0x 102 0x103 小端法 01 23 45 67 大端法 67 45 23 01 由于小端法的特性，当从内存中得到字节序列时，如果想到的到正确的序列，需要对其进行翻转。 有意思的是，大小端起源于《格列夫游记》中的应该从鸡蛋的大端还是小端敲开鸡蛋而来，哈哈哈的，蛋疼Y_Y。 布尔代数简介使用逻辑异或，能够实现两个整型的数的交换操作，代码如下： public class Test&#123; public static void swap(int a,int b)&#123; b=a^b; a=a^b; b=a^b; System.out.println(a+&quot;:&quot;+b); &#125; public static void main(String[] args) &#123; swap(2,3); &#125; &#125; //output: 3,2 其原理是基于这个式子：a^(a^b)=b,可以带入上式中进行化简，验证结果。 &emsp;&emsp;我们知道，乘法对加法有分配率，即：a*(b+c)=a*b+a*c，而布尔代数中&amp;对|也有分配率，即：a&amp;(b|c)=a&amp;b|a&amp;c,而与加法和乘法不同的是，|对&amp;也有分配率。 移位运算简介&emsp;&emsp;移位操作一共有三种形式，&lt;&lt;逻辑左移（补0），&gt;&gt;算术右移（补符号位）,&gt;&gt;&gt;逻辑右移（补0），对于无符号数，应该使用逻辑左移或者逻辑右移，而对于有符号数，应该使用算术右移而不是逻辑右移.左移k位相当于乘以2的k次幂，右移相当于除以2的k次幂。&emsp;&emsp;需要注意的是，如果x&lt;&lt;k中，k的值大于x的位数n，则实际上进行的是x&lt;&lt;(n%k),即，如果x为int型，则x&lt;&lt;33相当于x&lt;&lt;1。 无符号数与有符号数的编码 无符号数使用普通的方式编码，例如：$110=1*2^2+1*2^1 +0*2^0$ 有符号数使用的则是使用补码的方式编码，表示形式为：$110=-1*2^2 +1*2^1 +0*2^0$,即最高有效位符号为-，其余位为正。 值得注意的是，有符号和无符号编码在其所能表示的范围中的每一个数都是唯一编码的。不存在重复性。 无符号数与补码之间的转换&emsp;&emsp;无符号数与补码之间的转换不涉及底层的运算，只是改变了某些位的解释方式。例如：无符号数53191，其二进制表示为：1100 1111 1100 0111，将其转化为有符号时产生溢出，代表的数是：-12345。其具体的运算规则如下： 需要注意的是，我们假设无符号数表示范围为0&lt;=x&lt;=UMax,有符号表示范围为TMin&lt;=x&lt;=TMax,字长为w；U2T()和T2U()为相应的转换函数。 无符号数转换为补码对于0&lt;=x&lt;=UMax的无符号x的值：$$U2T(x)=\\begin{cases}u,&amp;x&lt;=TMax\\u-2^w,&amp;x&gt;TMax\\end{cases}$$ 补码转换为无符号数对于TMin&lt;=x&lt;=TMax的有符号x的值：$$T2U(x)=\\begin{cases}u,&amp;x&gt;=0\\u+2^w,&amp;x&lt;0\\end{cases}$$ 截取与扩充&emsp;&emsp;在程序中常常出现类型转换大致上包括两种类型转换，截取与扩充，当然还有目标数与原数位数不变的情况，截取我们直接将高位的二进制位丢弃，扩充则填充一定规则的二进制位，他们具体的执行方式如下： 无符号数与补码数的扩充&emsp;&emsp;无符号的扩充采用的是零扩充的方式，即简单的在开头填充0,例如将无符号数8，w=4二进制表示为：1000，将其扩充为w=8表示时，结果如下：00001000，结果的大小不变。&emsp;&emsp;补码的扩充采用的是符号位扩充的方式，即在高位填充符号位，例如有符号数-8,w=4时表示为1000,将其扩充为w=8表示时，结果如下：11111000.结果的大小不变。 推论:对于有符号数二进制表示为1111110000与-10000相同。即可以省略符号位前面的任意多个连续的1，这便是符号扩充推到而来的技巧。 无符号数与补码的截断&emsp;&emsp;截断一个无符号数时，如果将其截断为k位，则截取的结果为：$$y=x \\ mod\\ 2^k$$ &emsp;&emsp;截断一个有符号数时，如果将其截断为k位，则截取的结果与截断无符号数相同，不过需要将最高位转换为符号位。$$y=x \\ mod\\ 2^k$$例如如下代码，可以看到在java中截断是如何进行的： public static void main(String[] args) &#123; int i=1234567; System.out.println(&quot;截取前的数为：&quot;+i+&quot;其二进制表示为：&quot;+Integer.toBinaryString(i)); short s=(short)i; System.out.println(&quot;截取后的数为：&quot;+s+&quot;其二进制表示为：&quot;+Integer.toBinaryString(s)); int r=i%65536; System.out.println(&quot;i%2^16=&quot;+r+&quot;其二进制表示为：&quot;+Integer.toBinaryString(r)); &#125; //output 截取前的数为：1234567其二进制表示为：100101101011010000111 截取后的数为：-10617其二进制表示为：11111111111111111101011010000111 i%2^16=54919其二进制表示为：1101011010000111 可以看到截取后的二进制表示与直接mod 2的16次方相同。 无符号数加法与补码加法&emsp;&emsp;无符号加法存在正溢出的情况，因为两个非负数相加只会存在正溢出，其加法后的结果如下：对于无符号数x和y,$0 &lt;= x,y&lt; 2^w$ $$x+y=\\begin{cases} x+y,&amp;x+y&lt;2^w &amp;normal\\ x+y-2^w,&amp;2^w&lt;=x+y&lt;=2^{w+1} &amp;\\ \\ overflow \\end{cases}$$ &emsp;&emsp;有符号加法有正溢出和负溢出之分，其加法之后的结果如下：对于有符号数x和y,$-2^{w-1}&lt;=x,y&lt;=2^{w-1}-1$ $$x+y=\\begin{cases} x+y-2^w, &amp;2^{w-1}&lt;=x+y\\ x+y, &amp;-2^{w-1}&lt;=x+y&lt;=2^{w-1}\\ x+y+2^w, &amp;x+y&lt;-2^{w-1} \\end{cases}$$ 总的来说，有符号加法与无符号加法在指令执行上相同，只是对相加后的结果的每一位的解释不同。 无符号数乘法与补码乘法无符号数与补码的溢出判断无符号数与补码的乘2的幂无符号数与补码的除2的幂 浮点数表示与运算浮点数表示方法：浮点数遵循IEEE754规则，表示的形式为: $V=(-1)^S *M*2^E$ 而其二进制表示中，总共分为三部分，有如下定义： 符号位，用于确定浮点数的大小，双精度和单精度中都是一位. 阶码，用于确定E（单精度中为8位，双进度中为11位）. 尾数，用于确定M（单精度中为23位，双进度中为52位）.表示方法如下： 符号位 S 阶码E 尾数M 1位 8或11位 23或52位 根据阶码以及尾数的不同，可以将浮点数分为四种类型，这非常重要。 规格化：阶码E不能为0和255.尾数为任意值。 非规格化：阶码为0，尾数为任意数。 无穷大：阶码为255，尾数为0. 无穷小：阶码为255，尾数不为0. 四种类型的不同的计算数值的方法： 当为规格化表示法时，计算方法如下： $E=e-Bias$ $M=1+f$ 其中，e为阶码的无符号表示的值（范围为0~255/2047），Bias为偏置值（单精度为127，双进度为2013）。其值求法为：2^&#123;(k-1)&#125;-1M包含隐藏的1，这叫做隐含的以1开头的。 当为非规格化表示法时，计算方法如下: $E=1-Bias$ $M=f$ 与规格化不同的是，将e改为1，同时M中不再加上1。非规格的浮点表示方法中，包含有正0和负0，正0表示为全0的二进制组合，而负0表示为符号位为1，其余位为0的二进制组合。 无穷大代表正无穷或者负无穷，根据符号位确定正负。 NaN代表不是一个数（Not A Number）。通过对负数开根号或者无穷数相减等操作会得到一个NaN。","categories":[{"name":"OperationSystem","slug":"OperationSystem","permalink":"https://super-aviator.github.io/categories/OperationSystem/"}],"tags":[{"name":"深入理解计算机系统","slug":"深入理解计算机系统","permalink":"https://super-aviator.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}],"author":"熊乾坤"},{"title":"Linux中的文本查看与文件搜索","slug":"Linux中的文本查看与搜索","date":"2018-06-10T07:50:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2018/06/10/Linux中的文本查看与搜索/","link":"","permalink":"https://super-aviator.github.io/2018/06/10/Linux%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC%E6%9F%A5%E7%9C%8B%E4%B8%8E%E6%90%9C%E7%B4%A2/","excerpt":"","text":"Linxu中常用的文件查看与搜索命令 文本的查看 echo &quot;文本&quot;echo将后面的文本显示在终端中。 cat 文件路径cat命令用于查看文件内容 head 文件路径选项： -n 行数：查看文件开头的几行 tail 文件路径选项： -n 行数：查看文件最后的几行 -f 动态显示文件的更新 more 文件路径查看文件内容，只能够向下翻页 less 文件路径查看文件内容，可以上下翻页 vi 文件路径编辑文件，如果文件不存在就创建之 搜索命令 lcoatelocate从系统数据库中搜寻想要搜索的文件的路径，如果文件是新添加的，那么由于数据库还没有添加此文件，所以会查找失败，所以需要在root下使用updatedb命令更新数据库 find 搜索范围 搜索类型 想要搜索的类型搜索类型： -user 用户名： 搜索与该用户相关的文件 -perm 权限数组组合：搜索权限 -name 名字：根据名字搜索 -type 类型：根据类型搜索 -group 组名：根据所属组来查找 -size 大下：根据文件大小来查找 -ctime 时间：根据修改时间查找 grep 字符 本文路径grep命令不能够搜索文件夹，而只能用来所搜文本，其中字符可以加单引号或者不加都可以。选项： -i 搜索时忽略大小写 -n 显示搜索到的结果在文件中的行数 -v 输出结果以外的行 -Ax 输出关键字所在行以及其前x行 -Bx 输出关键字所在行以及其后x行","categories":[{"name":"OperationSystem","slug":"OperationSystem","permalink":"https://super-aviator.github.io/categories/OperationSystem/"}],"tags":[{"name":"Linux常用命令","slug":"Linux常用命令","permalink":"https://super-aviator.github.io/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}],"author":"熊乾坤"},{"title":"Linux中的管道和重定向","slug":"Linux中的管道和重定向","date":"2018-06-10T03:43:00.000Z","updated":"2021-02-23T13:00:12.000Z","comments":true,"path":"2018/06/10/Linux中的管道和重定向/","link":"","permalink":"https://super-aviator.github.io/2018/06/10/Linux%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91/","excerpt":"","text":"简单介绍Linux中管道和重定向 定义重定向&emsp;&emsp;linux系统中一共有三种标准的输入输出，分别为STDIN,STDOUT,STDERR，可以使用重定向将命令行输入或者输出的文本重定向到文件。&emsp;&emsp;三种标准输入输出流： 名称 标号 说明 默认 STUIN 0 标准输入 键盘 STDOUT 1 标准输出 终端 STDERR 2 标准错误 终端 通过STDIN来接受数据或参数，通过STDOUT或STDERR来输出结果或者错误。 管道&emsp;&emsp;由于linux系统中命令行的输入或者输出都是纯文本的，这就使多命令协作成为可能 ，所以linux中可以使用管道将前一个命令的输出作为后一个命令的输入，从而完成单条命令所不能完成的功能。 用法 分类 关键字 定义 例子 &gt; 将STDOUT重定向到文件（覆盖） ls -l &gt; xqk.txt; echo “hello world” &gt; xqk.txt &gt;&gt; 将STDOUT重定向到文件（追加） ls -l &gt;&gt; xqk.txt; echo “hello world” &gt; xqk.txt 2&gt; 将STDERR重定向到文件 (覆盖) ls -l xqk.err 2 &gt; xqk.txt 重定向 2&gt;&gt; 将STDERR重定向到文件 (追加) ls -l xqk.err 2 &gt;&gt; xqk.txt 2&gt;&amp;1 将STDOUT和STDERR重定向到文件 ls -l 2&gt;&amp;1 xqk.txt &lt; 将&lt;后的文件重定向到STDIN命令的输入 ls &lt;/etc/passwd 管道 l 前一个命令的输出作为后一个命令的输入 ls -l l grep aviator 值得注意的是，使用输出重定向&gt;或者&gt;&gt;时，不能够重定向错误信息，而需要使用2&gt;、2&gt;&gt;、2&gt;&amp;1来重定向。 如果将命令重定向到/dev/null，那么输出将被丢弃掉。相当于垃圾箱的功能。","categories":[{"name":"OperationSystem","slug":"OperationSystem","permalink":"https://super-aviator.github.io/categories/OperationSystem/"}],"tags":[{"name":"Linux常用命令","slug":"Linux常用命令","permalink":"https://super-aviator.github.io/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}],"author":"熊乾坤"},{"title":"ArrayList中删除的疑惑","slug":"ArrayList中删除的疑惑","date":"2018-06-07T15:04:00.000Z","updated":"2021-02-23T13:00:08.000Z","comments":true,"path":"2018/06/07/ArrayList中删除的疑惑/","link":"","permalink":"https://super-aviator.github.io/2018/06/07/ArrayList%E4%B8%AD%E5%88%A0%E9%99%A4%E7%9A%84%E7%96%91%E6%83%91/","excerpt":"","text":"ArrayList的删除问题 问题描述在做课设时,我在删除Arraylist链表保存的cube时,使用正向的for循环删除元素时,总是删除时抛异常,如下面的java代码所示: public static void main(String[] args) &#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); for(int i=0;i&lt;10;i++) list.add(i); for(int i=0;i&lt;10;i++) list.remove(i); System.out.println(list); &#125; 运行结果是抛出数组下标越界异常: 接下来我了查看ArrayList源码中的remove方法,代码如下: public E remove(int index) &#123; rangeCheck(index);//检查想要删除的元素的下标是否越界 modCount++; E oldValue = elementData(index);//获得要删除的元素的值 int numMoved = size - index - 1;//计算需要移动的元素的值 if (numMoved &gt; 0)//判断是否是数组的最后一个值 System.arraycopy(elementData, index+1, elementData, index, numMoved); //如果要删除的值不是数组中的最后一个,就将要删除的元素的后面的值前移一位. elementData[--size] = null; // clear to let GC do its work //避免对象游离,将数组最后一位其置为null便于虚拟机回收内存. return oldValue;//返回想要删除的值 &#125; 简单来说,在删除链表(数组实现)下标位i的下标的数时,系统会直接将下标为i+1及以后的值向前移动一位.并将数组中最后一位的值置为null.所以在上面的代码中,如果使用正向遍历时,如果删除0,1,2,3,4,5,6,7,8,9中的数时,会漏删除为奇数的数,而引起下标越界. 解决办法 使用倒索引的方法来删除,在上面的源码中会做出判断,如果要删除的数是数组的最后一位,那么将直接将其值置为null,故不会出现问题: for(int i=list.size()-1;i&gt;=0;i--) list.remove(i); 也可以使用如下的方法删除每次删除最后一个元素,不过由于每次要多一次函数size()调用,故效率比上面的方法略低: for(int i=0;i&lt;10;i++) list.remove(list.size()-1);","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Java疑惑解答","slug":"Java疑惑解答","permalink":"https://super-aviator.github.io/tags/Java%E7%96%91%E6%83%91%E8%A7%A3%E7%AD%94/"}],"author":"熊乾坤"},{"title":"Linux系统普通权限和高级权限","slug":"Linux系统权限管理","date":"2018-06-03T11:44:00.000Z","updated":"2021-02-23T13:00:10.000Z","comments":true,"path":"2018/06/03/Linux系统权限管理/","link":"","permalink":"https://super-aviator.github.io/2018/06/03/Linux%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","excerpt":"","text":"linux系统中权限的简单总结 Linux普通权限权限定义&emsp;&emsp;重所周知，linux拥有一套完整的权限机制，那么linux系统的权限机制到底是怎么一回事？在linux系统中如何对文件或者文件夹进行操作呢?&emsp;&emsp;在linux系统中，文件或者文件夹普通权限一共有三组，如下所示： 属性 所属用户 所属组 其他用户 所有用户 代表字符 u g o a 所占位数 3 3 3 - &emsp;&emsp;在使用ls-l命令查看文件属性各列属性如下： drwxrwxrwx 2 aviator aviator 512 apr 23 09:37 name 文件权限/第一位代表文件属性 文件的链接个数 所属用户 所属组 文件大小 修改日期 文件名 权限修改&emsp;&emsp;linux中使用命令chmod、chown、chgrp、来修改文件/文件夹的权限。 其中chmod修改文件有两种方式。 方式一：chmod命令将文件rwx权限使用二进制表示，例如：rw对应二进制位为110,故表示为4+2=6，同样，rwx二进制表为111，表示为4+2+1=7.chmod使用例子如下：1: chmod 567 filename将文件权限修改为r-xrw—x权限。2: chmod 123 filename将文件权限修改为–x-w–wx权限。 方式二：chmod命令可以直接使用u,g,o + 权限 的方式来修改文件属性，使用例子如下：1: chmod u+r filename将文件所属用户加上读权限。2: chmod a+r filename将文件所有属性都加上读权限。 chown命令修改文件所属用户，用法为chown username filename 将filename所属用户为username.chgrp命令修改文件所属组，用法为chgrp username filename将filename所属组修改为username. 对于文件夹，如果没有x权限，那么此文件夹将不能够进入 Linux高级权限高级权限定义&emsp;&emsp;linux中有三种特殊权限，suid、sgid、sticky。其作用如下： 作用 对于文件 对于文件夹 suid 以文件所属用户执行此文件而非执行用户来执行文件 无 sgid 以文件所属用户组执行此文件而非执行用户 在此文件夹下新建的所有文件默认所属组都是此文件所属组 sticky 无 此文件夹下的文件中，一个用户只能够删除该用户所拥有的文件，而非此用户拥有的文件则不能够删除。 修改高级权限linux高级权限同样使用chmod进行修改。如下所示：1: 给文件添加suid 属性：chmod u+s filename2: 给文件夹加上sgid属性：chmod g+s directoryname3: 给文件夹加上sticky属性：chmod o+t directoryname 同样chmod也可以使用数字的方式进行权限的控制。其中suid,sgid,sticky同样对应着4,2,1三位数字。例子如下： 1: 给文件添加suid 属性：chmod 4777 filename2: 给文件夹加上sgid属性：chmod 2777 directoryname3: 给文件夹加上sticky属性：chmod 1777 directoryname 默认权限的修改&emsp;&emsp;在linux系统中，没创建一个文件或者文件夹，都会赋予一个默认的权限。那么这个权限是如何得到的呢，其实linux系统是使用umask值实现的。使用umask命令可以查看系统umask值。&emsp;&emsp;一般系统默认umask值为0002，那么文件默认权限就是666-002=664，文件夹默认权限就是777-002=775。使用umask number 可以将umask修改为想要的值。","categories":[{"name":"OperationSystem","slug":"OperationSystem","permalink":"https://super-aviator.github.io/categories/OperationSystem/"}],"tags":[{"name":"Linux常用命令","slug":"Linux常用命令","permalink":"https://super-aviator.github.io/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}],"author":"熊乾坤"},{"title":"VIM常用命令","slug":"VIM常用命令","date":"2018-05-27T05:39:00.000Z","updated":"2021-02-23T13:00:02.000Z","comments":true,"path":"2018/05/27/VIM常用命令/","link":"","permalink":"https://super-aviator.github.io/2018/05/27/VIM%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"linux中超强的文本编辑器 vim的三种模式 命令模式&emsp;&emsp;vim启动以后，自动进入命令模式，任何模式都可以通过esc键切换到命令模式。此模式可以进行原则、复制、粘贴、撤销等操作。 插入模式&emsp;&emsp;进入此模式可以进行文本编辑，例如按下i键就可以在光标后进行编辑。 ex模式&emsp;&emsp;命令模式下按下shift+:键就可以进入ex模式，在ex模式可以进行保存修改，退出等操作。 vim常用的命令命令模式下的命令 i 在光标前插入文本 o 在当前行下面插入新的行 dd 删除当前一行 yy 复制当前行 n+yy 将光标下的n行复制 p 粘贴复制的行 u 撤销前一步操作 r 替换当前字符（先按下r再按下想要替换的字符） /关键字 ：查找/后面的关键字。使用n或者enter查找下一个。 x 删除当前光标下的字符 0 dw 删除光标之后的单词剩余部分。 d$ 删除光标之后的该行剩余部分。 dd 删除当前行。 c 功能和d相同，区别在于完成删除操作后进入INSERT MODE cc 也是删除当前行，然后进入INSERT MODE ex模式 w 保存当前文件不退出 q 退出（没有编辑过） wq 保存并退出 q! 强制退出不保存 x 保存并退出 set nu显示行号 set number显示行号 ! 系统命令：执行系统命令 sh 切换到shell,使用ctrl+d切换回来。 %d 删除文件所有内容","categories":[{"name":"OperationSystem","slug":"OperationSystem","permalink":"https://super-aviator.github.io/categories/OperationSystem/"}],"tags":[{"name":"Linux常用命令","slug":"Linux常用命令","permalink":"https://super-aviator.github.io/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}],"author":"熊乾坤"},{"title":"Git常用命令","slug":"GIt常用命令","date":"2018-05-24T12:24:00.000Z","updated":"2021-02-23T13:00:10.000Z","comments":true,"path":"2018/05/24/GIt常用命令/","link":"","permalink":"https://super-aviator.github.io/2018/05/24/GIt%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"git常用的命令 1.6 运行gti前初次的配置&emsp;&emsp;git中的配置有两种方式： 第一种是/etc/gitconfig文件，此文件为通用配置，使用git config–system时会显示此文件配置 第二种是~/.gitconfig 或者 ~/.config/git/config文件，使用git config –global读取此文件。 &emsp;&emsp;在配置参数时，如果使用–global选项，那么次选项则是不可更改的，所有项目都是用此配置，如果想要对某项目使用不同的配置，可以到该项目目录下使用不带选项–global的命令配置信息。 使用git config --global username &quot;用户名&quot;修改git的提交用户信息。 使用git config --global user.email&quot;地址&quot;添加用户email地址。 使用git config --global core.editor 软件名 设置默认的文本编辑软件。 使用git config --list查看所有配置信息。 使用git config user.name查看某一项的配置信息。 使用git ls-files查看所有跟踪的文件。 2.2 记录每次更新到仓库&emsp;&emsp;get中文件的生命周期： 使用git status查看git当前的状态，其中Untracked files:下为未跟踪的文件，Changes to be committed:下为未提交，已暂存文件，Changes not staged for commit:为已修改未暂存文件。 使用git add filename将未跟踪文件添加到暂存状态。此命令也可以将已修改文件添加到暂存区。 注意,当修改了已暂存文件时，此时文件处于已暂存和已修改两个状态，需要使用git add将此文件再次添加到已暂存状态，而git保存的是最后一次暂存的文件的内容。 使用git add *将所有已修改的文件添加到暂存区 使用git status -s命令以简洁的方式查看状态，格式如下：XX filename，其中X可以为M、A、??,如果是两个问号表示文件未跟踪，一个左边的A表示文件新添加到暂存区的文件，左边M表示文件已修改并放入了暂存区，右边的M表示已修改没有放入暂存区，两边都有M表示此文件存放在暂存区之之后但是被修改了。 使用cat .gitignore创建文件来保存git忽略的文件格式。 使用git diff来查看未暂存文件和已暂存文件相比跟新了哪些部分，使用git diff --staged/--cached来查看已暂存文件文件 使用git commit -m “说明文字”提交暂存区的文件。在使用此命令前可以使用git status 查看是否所有文件都放到暂存区了。此命令使用- m参数添加说明文字。如果不加-m参数会启动默认的文本编辑器来编辑说明文字。此时如果使用-v参数会在文本编辑器中显示做了哪些修改以便于你更清晰的添加说明文字。 使用git commit -a选项，git会提交所有已跟踪的文件暂存起来一起提交，从而跳过git add步骤。 使用git rm filename将文件删除，此时文件已经从磁盘删除，但是使用git status查看发现此操作还没有提交，使用git commit -m来提交操作就将文件从git中删除，此时该文件已被删除并且不被跟踪。 使用git rm --cached filename/glob来取消文件的跟踪但是不删除文件。 使用git mv filename1 filename2来将文件filename1重命名为filename2,git不会跟踪文件的移动操作，执行上述命令相当于执行下面三条语句： mv filename1 filename2 git rm filenamefilename1 git add filename2. 2.3 查看历史提交 使用git log命令 查看历史提交，此命令可以有很多选项详情请查看git教程 使用git log -p -2，- p选项表示显示历史提交的内容差异，-2 选项表示只显示最近的2此提交。 2.4撤销操作 使用git commit -m --amend撤销上一次的提交，并重新提交暂存区的文件。比如此提交暂存区的文件后，使用git status命令发现你不小心漏提交了一个文件，此文件已修改但某有暂存，此时不要慌，可以将此文件首先使用git add添加到暂存区，然后使用该命令重新提交，此时系统显示的是第二次的提交，第一次的提交被覆盖掉了。 使用git reset HEAD filename将暂存区的文件filename取消暂存，从而转变为已修改状态。 此操作不是危险的，它没有改变文件，只是修改了暂存区域，而使用–head选项时则是危险的。可能到时工作目录所有当前就读丢失。 使用git checkout -- filename撤销文件filename所做的修改。 此操作是危险的，他会删除你所做的任何修改，除非你清楚的知道你不想要这个文件了，否则不要使用这个命令。 2.5 远程仓库的使用 使用git clone URL克隆远程仓库。其中URL可以使https或者是git协议. 使用git remote add 添加远程仓库，并命名为shortname. 使用git remote -v查看远程仓库的简写对应的URL. 使用git fetch shortname拉取 shortname 的仓库中有但你没有的信息. 使用git pull shortname此命令会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 注意，以上两个命令的区别是pull从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。，而fetch则不会，需要自己合并。 使用git push shortname branchname将本地branchname分支推送到服务器（确保有推送权限）。 使用git remote show shortname查看远程仓库信息。 使用git remote rename shortname name重命名远程仓库名。 使用git remote rm shortname将远程仓库删除。 2.6 打标签&emsp;&emsp;Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。 一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。 然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。 使用git tag来查看所有的标签 使用git tag -l &quot;v1.2.*&quot;查看v1.2.x的所有标签。 使用git tag -a v1.1 -m&quot;说明信息&quot;来创建一个v1.1的附注标签。 使用git show v1.1查看标签内容。 2.7 别名 使用git config --global alias.别名 &#39;命令名&#39;来将git命令重命名为更加简单的命令名。 使用git config --global alias.visual &#39;!gitk&#39;来将git外部的命令重命名。与上面不同的是需要加上!。 3.1 分支&emsp;&emsp;git中的commit对象的结构：&emsp;&emsp;做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。 使用git branch branchname创建新的分支。 使用git log --oneline --decorate查看当前分支所指的对象。 使用git checkout branchname切换到指定的分支。 使用git log --oneline --decorate --graph --all查看历史提交，各个分支的指向以及项目的分支情况。 3.2 分支的创建与合并 使用git checkout -b branchname创建并切换到分支branchname。相当于使用下面两条命令： git branch branchname git checkout branchname 使用git merge branchname将branchname分支合并到当前分支。 如果这两个分支是在同一条线上，那么此操作仅仅是将当前分支移动到branchname上去。如下： 执行merge后： 如果两个分支不在一条线上，那么git将创建一个他们的新的提交指向他们，这被称作合并提交，它的特别之处在于他有不止一个父提交。 执行merge后： 使用git branch -d branchname删除分支branchname.如果当前分支还没有合并到当前分支，则不能使用该命令删除，需要使用-D强制删除。 使用git branch -D branchname强制删除分支branchname. 3.3 分支管理 使用git branch列出所有的分支列表。前面有*代表单签所处的分支。 使用git branch -v查看每一个分支的最后一次提交。 使用git branch --merged查看已经合并到当前分支的分支。 使用git branch --no-merged查看没有合并到当前分支的分支。如果某分支包含了还未合并的工作，尝试使用 git branch -d 命令删除它时会失败，需要使用 git branch -D强制删除。 3.4 分支开发工作流","categories":[{"name":"Git","slug":"Git","permalink":"https://super-aviator.github.io/categories/Git/"}],"tags":[{"name":"Git常用命令","slug":"Git常用命令","permalink":"https://super-aviator.github.io/tags/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}],"author":"熊乾坤"},{"title":"ListIterator分析","slug":"ListIterator分析","date":"2018-05-12T04:27:00.000Z","updated":"2021-02-23T13:00:02.000Z","comments":true,"path":"2018/05/12/ListIterator分析/","link":"","permalink":"https://super-aviator.github.io/2018/05/12/ListIterator%E5%88%86%E6%9E%90/","excerpt":"","text":"ListIterator是比Iterator更灵活的迭代器 概述（summary）&emsp;&emsp;ListIterator接口是Iterator的子接口，在所有List子类中都有实现。与Iterator不同的是，ListIterator支持在遍历集合的同时add和set操作。 分析接口中的方法&emsp;&emsp;首先查看Iterator接口和ListIterator接口中的三个方法 public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); default void remove() &#123;//r默认会抛出不支持操作的异常，可以覆盖此方法 throw new UnsupportedOperationException(&quot;remove&quot;); &#125; &#125; ------- public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); boolean hasPrevious();//新增 E previous();//新增 int nextIndex();//新增 int previousIndex();//新增 void remove(); void set(E e);//新增 · void add(E e);//新增 &#125; 方法解析重要方法&emsp;&emsp;在ArrayList中Itr实现了Iterator接口，其中有两个非常重要的变量，cursor和lastRet,cursor保存了当前的下标，默认为0，lastRet保存了上次操作的下标，默认为-1。 ListItr实现了ListIterator接口并继承了Itr类。所有新增的方法都在此类总实现。 private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such --------- private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; &emsp;&emsp;重点的方法是add和set方法，add方法是修改cursor下标所指向的对象， 而set方法是修改lastRet所指向的下标，那么问题来了，当一开始就调用set会发生什么？答案是抛出异常java.lang.IllegalStateException。因为此时lastRet的值为-1. 那么我们就需要时刻注意lastRet和cursot的值。 方法细节&emsp;&emsp;首先我们来看add方法，add方法源码如下，方法大致行为为将cursor指向的数以及后面的所有的数向后移动一位，然后将待插入的值插入到cursor下标中。同时将lastRet下标置为-1.所以在执行add方法之后不能执行set方法。 public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e);//添加元素e，如果长度不够会自动grow延长数组大小。 cursor = i + 1;//cursor加一 lastRet = -1;//lastRet置为一 expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &emsp;&emsp;set方法源码如下，它首先判断lastRet的值，如果&lt;0就抛出异常，否则就执行set。 public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &emsp;&emsp;然后我们来看Itr中的next方法，顾名思义，此方法会将cursor方法加一然后返回指向的值，lastRet指向的是cursor加一之前的值。具体实现如下： public E next() &#123; checkForComodification();//先检查是否可以修改 int i = cursor; if (i &gt;= size)//判断cursor是否合法 throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1;//将cursor加一 return (E) elementData[lastRet = i];//将cursor原来的值赋给lastRet，然后返回cursor的值。 &#125; &emsp;&emsp;在previous中先将cursor减去一保存在i中，然后判断是否在数组下标以内如果不在就抛出异常，所有在创建ListIterator时如果指定下标，下标最大长度是list的长度；如果下标在范围内，就将i赋给cursor，然后将现在的cursor值赋给lastRet，并返回cursor的值。与next不同的是，previous中lastRet和cursor的值是相同的。而next中lastRet的值比cursor值小一。 public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i];//将cursor的值赋给lastRet。 &#125; &emsp;&emsp;remove方法移除lastRet所指向的下标同时将lastRet的下标置为-1.所以同样在remove方法执行之后不能执行set方法。 public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &emsp;&emsp;nextiIndex()以及previousIndex()返回的是cursor以及cursor减一的值。 public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Java疑惑解答","slug":"Java疑惑解答","permalink":"https://super-aviator.github.io/tags/Java%E7%96%91%E6%83%91%E8%A7%A3%E7%AD%94/"}],"author":"熊乾坤"},{"title":"散列表（HashTable）","slug":"符号表（HashTable）","date":"2018-05-10T09:13:00.000Z","updated":"2021-02-23T13:00:04.000Z","comments":true,"path":"2018/05/10/符号表（HashTable）/","link":"","permalink":"https://super-aviator.github.io/2018/05/10/%E7%AC%A6%E5%8F%B7%E8%A1%A8%EF%BC%88HashTable%EF%BC%89/","excerpt":"","text":"散列表是符号表效率最高的一种实现，当散列表键的散列函数能够把键均匀的散列在数组中时，散列表的查找和插入操作时间复杂度几乎可以达到常数级别，但是当散列函数实现非常差时，散列表退化为链表，插入和查找操作时间复杂度会降低到线性级别。 定义散列表定义&emsp;&emsp;在一种符号表的实现，可以通过键所对应的数组索引快速查找所对应的值，这就是散列表。&emsp;&emsp;符号表的实现有两个步骤，第一步是编写散列函数，对于任意的键，需要计算出对应的索引，理想情况下键与索引是一一对应的，但是有时我们也需要处理一个键对应多个索引的情况，第二个步骤就是处理碰撞，有两种方法处理碰撞，即拉链法(SeparateChaining)和线性探测法(LinearProbing)。 散列函数&emsp;&emsp;对于符号表，一个好的散列函数非常重要。这关乎到散列表的性能。 整数&emsp;&emsp;对于整数最长中的方法是除留余数法，选择大小为素数M的数组，对于任意的k,k除以M的余数就是其索引，需要注意的是M必须是素数（特别的，不能是2的次幂），否则可能无法利用键中包含的所有信息。 浮点数&emsp;&emsp;如果是0-1之间的实数，我们可以将它乘以M并四舍五入到一个0~M-1之间的索引，但是这样有一个缺陷，因为这样方法中，浮点数中高位起的作用更大，修正的方法是将浮点数转换为二进制然后在对M使用除留余数法(java就是这么处理的)。 字符串&emsp;&emsp;除留余数法也适用于较长的键，例如字符串，我们只需要将他们当作大整数即可。例如下面的代码： int hash=0; for(int i=0;i&lt;s.length();i++) hash=(R*hash+s.charAt(i))%M; 此方法将字符串当作一个N位的R进制值，只要R足够小，不造成溢出，那么就可以散列在0~M-1之间。java中使用了类似的方法。 组合键&emsp;&emsp;当有组合键构成的键值时，可以使用字符串类似的方法,例如当有年月日的键时，可以使用下面的方法： int hash=(((day*R+month)%M)*R+year)%M; java的约定&emsp;&emsp;java对一些数据类型定义了默认的hashCode方法，我们可以使用下面的方法来利用java自带的方法编写自己的hashCode方法。 private int hash(Key x)&#123; return (x.hashCode()&amp;0x7fffffff)%M; &#125; 因为java默认的实现会返回一个int值，此int值可能会溢出为负值，与0x7fffffff可以将符号位屏蔽转换为正值。 处理碰撞基于拉链法的散列表实现&emsp;&emsp;此方法使用一个链表组成的数组实现，键对应的数组中的链表中存储的是有碰撞的键值对。 import unit3_1_code.SequentialSearchBT; import java.util.LinkedList; public class SeparateChainingHashST &lt;Key, Value&gt;&#123; private int M,N; private SequentialSearchBT&lt;Key,Value&gt;[] bt; public SeparateChainingHashST()&#123; this(997); &#125; public SeparateChainingHashST(int M)&#123; this.M=M; bt=(SequentialSearchBT&lt;Key, Value&gt;[]) new SequentialSearchBT[M]; for(int i=0;i&lt;M;i++) bt[i]=new SequentialSearchBT&lt;&gt;(); &#125; public int size()&#123; return N; &#125; public int hash(Key key)&#123; return (key.hashCode()&amp;0x7fffffff)%M; &#125; public void put(Key key,Value value)&#123; bt[hash(key)].put(key,value); N++; &#125; public Value delete(Key key)&#123; N--; return bt[hash(key)].delete(key); &#125; public Value get(Key key)&#123; return bt[hash(key)].get(key); &#125; public Iterable&lt;Key&gt; keys()&#123; LinkedList&lt;Key&gt; list=new LinkedList&lt;&gt;(); for(int i=0;i&lt;bt.length;i++)&#123; if(bt[i].isEmpty()) continue; for(Key key:bt[i].keys()) list.add(key); &#125; return list; &#125; public static void main(String[] args) &#123; SeparateChainingHashST&lt;String,Integer&gt; scst=new SeparateChainingHashST&lt;&gt;(); scst.put(&quot;1&quot;, 1); scst.put(&quot;2&quot;, 2); scst.put(&quot;3&quot;, 3); scst.put(&quot;4&quot;, 4); scst.put(&quot;5&quot;, 5); scst.put(&quot;6&quot;, 6); System.out.println(scst.get(&quot;2&quot;)); System.out.println(scst.get(&quot;5&quot;)); System.out.println(scst.get(&quot;4&quot;)); scst.put(&quot;100&quot;,99); System.out.println(scst.get(&quot;100&quot;)); System.out.println(scst.delete(&quot;100&quot;)); System.out.println(scst.size()); for(String s:scst.keys()) System.out.print(s+&quot; &quot;); &#125; &#125; 删除操作&emsp;&emsp;删除操作可以调用线性链表的删除操作。 性能分析&emsp;&emsp;此方法的性能依赖于散列函数，设想，散列函数不能将键均匀的散列在数组中，那么查找时就相当于在链表中查找值了。性质： 在一张含有M条链表和N个键的散列表中，未命中查找和插入操作所需的比较次数为~N/M(N为键值对的数量，M为数组大小)。 &emsp;&emsp;使用拉链法不能够高效的支持有序性的操作，因为采用的无序存储，有序性操作效率非常低。 基于线性探测法的散列表实现&emsp;&emsp;线性探测法是指如果数组中存在碰撞的键，就向后一次查找，直到找到空的点，并存入其中。 import java.util.Iterator; public class LinearProbingHashST&lt;Key,Value&gt; &#123;//线性探测哈希符号表 private Key[] keys; private Value[] values; private int M=16;//线性探测符号表的总大小 private int N;//键值对的大小 public LinearProbingHashST()&#123; keys=(Key[]) new Object[M]; values=(Value[])new Object[M]; &#125; private int hash(Key key)&#123;//计算键的哈希值 return (key.hashCode()&amp;0x7fffffff)%M; &#125; public int size()&#123; return N; &#125; public void put(Key key,Value value)&#123; int i=hash(key); while(keys[i]!=null)&#123; if(keys[i].equals(key)) &#123; values[i]=value;//命中则更新 return; &#125; i=(i+1)%M; &#125; keys[i]=key;//未命中则插入 values[i]=value; N++; &#125; public Value get(Key key)&#123; int i=hash(key); while(!keys[i].equals(key)) i=(i+1)%M; return values[i]; &#125; public Value delete(Key key)&#123; Value value; int i=hash(key); while(!keys[i].equals(key)) i=(i+1)%M; value=values[i]; for(int k=i;keys[k]!=null;k=(k+1)%M)&#123; keys[k]=keys[k+1]; values[k]=values[k+1]; &#125; N--; return value; &#125; public Iterable&lt;Key&gt; keys()&#123; return () -&gt; new Iterator&lt;Key&gt;() &#123; int i=0; @Override public boolean hasNext() &#123; return i!=keys.length; &#125; @Override public Key next() &#123; return keys[i++]; &#125; &#125;; &#125; public static void main(String[] args) &#123; LinearProbingHashST&lt;String,Integer&gt; scst=new LinearProbingHashST&lt;&gt;(); scst.put(&quot;1&quot;, 1); scst.put(&quot;2&quot;, 2); scst.put(&quot;3&quot;, 3); scst.put(&quot;4&quot;, 4); scst.put(&quot;5&quot;, 5); scst.put(&quot;6&quot;, 6); scst.put(&quot;12&quot;, 1); scst.put(&quot;23&quot;, 2); scst.put(&quot;34&quot;, 3); scst.put(&quot;45&quot;, 4); scst.put(&quot;56&quot;, 5); scst.put(&quot;67&quot;, 6); System.out.println(scst.get(&quot;2&quot;)); System.out.println(scst.get(&quot;5&quot;)); System.out.println(scst.get(&quot;4&quot;)); scst.put(&quot;100&quot;,99); System.out.println(scst.get(&quot;100&quot;)); //System.out.println(scst.delete(&quot;100&quot;)); System.out.println(scst.size()); for(String s:scst.keys()) System.out.print(s+&quot; &quot;); scst.delete(&quot;100&quot;); scst.delete(&quot;12&quot;); scst.delete(&quot;23&quot;); scst.delete(&quot;34&quot;); scst.delete(&quot;1&quot;); for(String s:scst.keys()) System.out.print(s+&quot; &quot;); &#125; &#125; 删除操作&emsp;&emsp;此实现的删除比较特殊，当删除一个键值对时，不能简单的将需要删除的位置为null，因为置为null会导致后面的元素无法被访问到，正确的做法是将后面的元素从数组中删除，并将其使用put方法重新将其插入到数组中去。 性能分析&emsp;&emsp;此实现方法的性能决定于键簇的长度，键簇指得是连续的相邻的键的个数，如果键的长度太长， 删除和查找操作都比较费时，短小的键才能够有较好的时间复杂度，所以必须控制键和值的长度保证较好的长度。 使用率a（元素个数/数组长度）指的是键值对所占用的总的数组的长度的比例，实验证明a小于1/2时，探测次数只在1.5~2.5之间。 调整数组的大小&emsp;&emsp;线性探测法中，数组调整是必须的，并且数组的调整非常重要,因为当数组的长度和存储的元素相等时，会导致查找和插入操作进入死循环： private viod resize(int cap)&#123; LinearProbingHashSt&lt;Key,Vlaue&gt; t; t=new LinearProbingHashSt&lt;Key,Vlaue&gt;(cap); for(int i=0;i&lt;M;i++)&#123; if(Keys[i]!=null) t.put(keys[i],vals[i]); &#125; keys=t.keys; vals=t.vals; M=t.M; &#125; &emsp;&emsp;检测是否需要改变容量可以使用以下的方法： if(N&gt;0&amp;&amp;N&lt;=M/8) resize(M/2); if(N&lt;M&amp;&amp;N&gt;=M/2) resize(M*2); 通过加载因子扩充数组在构造函数中，可以传入一个加载因子（LoadFactor）,当已经存在的元素个数大于数组长度*加载因子时，就会发生数组扩充。","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://super-aviator.github.io/categories/DataStructure/"}],"tags":[{"name":"符号表","slug":"符号表","permalink":"https://super-aviator.github.io/tags/%E7%AC%A6%E5%8F%B7%E8%A1%A8/"}],"author":"熊乾坤"},{"title":"java实现Iterable接口的几种方法","slug":"java实现Iterable接口的几种方法","date":"2018-05-04T11:02:00.000Z","updated":"2021-02-23T13:00:08.000Z","comments":true,"path":"2018/05/04/java实现Iterable接口的几种方法/","link":"","permalink":"https://super-aviator.github.io/2018/05/04/java%E5%AE%9E%E7%8E%B0Iterable%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"java中实现迭代器接口的几种方法 定义Iterable接口定义： public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); &#125; 如上所示，Iterable接口中含有一个iterator方法，该方法返回一个Iterator接口，我们来看一看Iterator接口的定义： public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); default void remove() &#123;//选择实现。 throw new UnsupportedOperationException(&quot;remove&quot;); &#125; &#125; 实现类实现Iterable接口&emsp;&emsp;在java中，如果你想要你的类可以使用foreach遍历，就需要实现Iterable接口。 import java.util.Iterator; public class IterableTest implements Iterable&lt;String&gt;&#123; private String[] str=&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;&#125;; public Iterator&lt;String&gt; iterator()&#123; return new Iterator&lt;String&gt;()&#123;//使用匿名内部类实现Iterator接口。 int current = 0; public boolean hasNext()&#123; return current&lt;str.length; &#125; public String next()&#123; return str[current++]; &#125; public void remove()&#123; throw new UnsupportedOperationException(); &#125; &#125;; &#125; public static void main(String[] args)&#123; IterableTest it=new IterableTest(); for(String str:it) System.out.print(str+&quot; &quot;); &#125; &#125; output// a b c d e 方法返回Iterable接口&emsp;&emsp;当想调用函数返回一个Iterable时，可以在方法中使用内部类实现Iterable接口。 import java.util.Iterator; public class IterableTest&#123; private String[] str=&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;&#125;; public Iterable&lt;String&gt; getIterator()&#123; return new Iterable&lt;String&gt;() &#123; public Iterator&lt;String&gt; iterator()&#123; return new Iterator&lt;String&gt;() &#123; int current =0; public boolean hasNext()&#123; return current&lt;str.length; &#125; public String next()&#123; return str[current++]; &#125; public void remove()&#123; throw new UnsupportedOperationException(); &#125; &#125;; &#125; &#125;; &#125;; public static void main(String[] args)&#123; IterableTest it=new IterableTest(); for(String str:it.getIterator()) System.out.print(str+&quot; &quot;); &#125; &#125; //output a b c d e 使用Lambda表达式&emsp;&emsp;使用java8中的Lambda可以简化我们的代码。 import java.util.Iterator; public class IterableTest&#123; private String[] str=&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;&#125;; public Iterable&lt;String&gt; iterator()&#123; return ()-&gt; new Iterator&lt;String&gt;() &#123;//Lambda int current =0; public boolean hasNext()&#123; return current&lt;str.length; &#125; public String next()&#123; return str[current++]; &#125; public void remove()&#123; throw new UnsupportedOperationException(); &#125; &#125;; &#125; public static void main(String[] args)&#123; IteratorTest it=new IteratorTest(); for(String str:it.iterator()) System.out.print(str+&quot; &quot;); &#125; &#125; //output a b c d e","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Java疑惑解答","slug":"Java疑惑解答","permalink":"https://super-aviator.github.io/tags/Java%E7%96%91%E6%83%91%E8%A7%A3%E7%AD%94/"}],"author":"熊乾坤"},{"title":"java表达式的值溢出分析","slug":"java表达式的值溢出分析","date":"2018-05-02T01:37:00.000Z","updated":"2021-02-23T13:00:10.000Z","comments":true,"path":"2018/05/02/java表达式的值溢出分析/","link":"","permalink":"https://super-aviator.github.io/2018/05/02/java%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/","excerpt":"","text":"防止表达式溢出以及表达式溢出的过程 原作者 今天在看框架的工具包时发现了一个细节,double d=1024d * 1024 * 1024 * 1024;第一个1024后面为什么要带个d呢? 于是我尝试了一下: double d = 1024d * 1024 * 1024 * 1024; double dw = 1024 * 1024 * 1024 * 1024 ; System.out.println(d); System.out.println(dw); 结果为:1.099511627776E12 0 0?为啥是0?? java的普通数字类型是int,1024是int,4个int的1024相乘(2^40)已经超出了int的表示范围了,2^32, 看了《Java虚拟机说明书》中“Java语言编程概念”中对“基本数据类型的变窄转换”的介绍才算明白了。 对于 int i = 1000000; System.out.println(i*i); ----------------------- -727379968 ----------------------- 的合理解释和过程应该是这样的：&emsp;&emsp;i设置为1000000，在乘方时Java发现结果（1000000000000）已经超出了int基本数据类型的最大范围（2147483647），于是作了默认的类型提升（type promotion），中间结果做为long类型存放，返回结果时目标数据类型int不能够容纳下结果，于是根据Java的基础类型的变窄转换（Narrowing primitive conversion）规则，把结果宽于int类型宽度的部分全部丢弃，也就是只取结果的==低32位==，于是就得到了上面的结果。&emsp;&emsp;下面用一个十六进制表示的例子阐释这个问题: int i3 = 1000000; System.out.println (Long.toHexString (i3*i3).toUpperCase()); System.out.println (Long.toHexString (i3*i3).toUpperCase()); System.out.println (Integer.toHexString (i3*i3).toUpperCase()); System.out.println ((int)i3*i3); --------------------------------------------------- FFFFFFFFD4A51000 1000000000000 D4A51000 -727379968 --------------------------------------------------- 截取是非常直观的 原来如此,于是加了d的1024相乘,结果就会以double储存,这样才能得到正确的结果…真意外 啊啊啊.","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Java疑惑解答","slug":"Java疑惑解答","permalink":"https://super-aviator.github.io/tags/Java%E7%96%91%E6%83%91%E8%A7%A3%E7%AD%94/"}],"author":"熊乾坤"},{"title":"URI与URL、URN","slug":"URI与URL、URN","date":"2018-04-29T09:12:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2018/04/29/URI与URL、URN/","link":"","permalink":"https://super-aviator.github.io/2018/04/29/URI%E4%B8%8EURL%E3%80%81URN/","excerpt":"","text":"详细介绍HTTP协议中的URI与URL URI与URL、URN定义&emsp;&emsp;WEB服务器资源都有一个名字，这样客户端就可以查找到相应的资源，服务器资源名被称为统一资源标识符(Uniform Resource Identifier),URI就像因特网上的邮政地址，在世界范围内唯一标示并定位信息资源。URI有两种形式，分别为URL和URN。&emsp;&emsp;URL是URI最长见的形式，URL描述了服务器上某资源的位置，他们可以说明如果从一个精确、固定的位置获取资源。&emsp;&emsp;URN是作为特定内容的唯一名称使用的，与目前资源的所在地无关，URN仍处于实验阶段。 URI和URL、URN的区别与联系&emsp;&emsp;URI包含了URL和URN,总的来说，URI是一种协议和规则，URL则是URI的一种具体实现，URN也是URI的具体实现，只不过实现的方式不同而已。 URLURL语法&emsp;&emsp;URL是使用的最多的一种URI形式，大多数URL方案的URL语法都建立在有9个组件构成的通用格式上： &lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt; 方案 用户名 密码 主机 端口 路径 参数 查询 片段 各个组件的解释如下： 方案：方案即URL使用的是什么协议方案必须是字母符号开始，由第一个冒号将其与后面隔开。注意：方案名是大小写无关的 主机与端口：可以使用IP地址或者域名来表示主机名，端口指定了服务器所监听的端口号。 用户名与密码：在此组件中，如果没有指定用户名和密码，浏览器通产会插入一个默认的用户名和密码。 路径：路径说明了资源位于服务器的什么地方通常是一个分级的文件路径。例如：http://www.myhost.com:80/seasonal/index.html中，路径名是/seasonal/index.html 参数：有时需要向服务器传输一些参数，参数在路径后面，使用；将其隔开，例如：ftp://prep.ai.mit.edu/pub/gnu;type=d中有一个参数名为type,其值为d,注意的是HTTP URL的路径组件可以分成若干路径，每段都有自己的参数：http://www.joes-hardware.com/hammers;sale=false/index.html;graphics=true中有两个路径，hammers和index.html,第一个路径有参数sale,第二个路径有参数graphics. 查询字段：很多资源都需要访问数据库，可以通过提问题或进行插叙来缩小请求资源类型范围的。例如：http://www.joes-hardware.com/inventory-check.cgi?item=12731中，有查询组件item=12731.注意查询组件使用&amp;分隔。 片段：如果想要浏览器直接从页面的某一段开始显示，就需要使用片段组件。例如：http://www.joes-hardware.com/tols.html#drills中，显示的是drill这部分的内容。 特殊的URL相对URL&emsp;&emsp;URL有两种形式，绝对和相对URL，例如：http://www.myhost.com/index.html是一个绝对URL，而./tools.html是一个相对URL. &emsp;&emsp;利用基础URL,从相对URl可一推导出绝对URL,将上面第一个URL作为基础ULR,从第二个相对URL对到出的绝对URL为http://www.myhost.com/tools.html &emsp;&emsp;查找基础URL有几个不同的方式，第一种是通过HTMl中的标记&lt;BASE&gt;显式的给出，第二种是如果没有显示给出基础URL，就将他所属的URL作为基础URL。如果没有基础URL,那么这个URL就可能是一个损坏的URL。 URL的转义安全字符集 &emsp;&emsp;URL中可以出现安全字符集以内的字符而不需要转义，安全字符集包括如下字符： 大写字母A-Z 小写字母a-z 数字0-9 标点符号- _ . ! ~ * &#39; , 注意，符号/ &amp; ? # ; $ + = % 这些字符也可以使用，但都有特定用途，如果出现在路径或者查询字段中，他们以及所有其他字符都需要转义。 非安全字符&emsp;&emsp;对于URL中的非安全字符集，需要对其进行转义，方式是%加上两位的十六进制数字。例如：’+’应该编码为%2B，注意：空格’ ‘可以编码为%20，也可以编码为’+’。","categories":[{"name":"NetWork","slug":"NetWork","permalink":"https://super-aviator.github.io/categories/NetWork/"}],"tags":[{"name":"HTTP权威指南","slug":"HTTP权威指南","permalink":"https://super-aviator.github.io/tags/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"}],"author":"熊乾坤"},{"title":"二叉查找树（BinarySearchTree）","slug":"二叉查找树（BinarySearchTree）","date":"2018-04-21T04:42:00.000Z","updated":"2021-02-23T13:00:00.000Z","comments":true,"path":"2018/04/21/二叉查找树（BinarySearchTree）/","link":"","permalink":"https://super-aviator.github.io/2018/04/21/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88BinarySearchTree%EF%BC%89/","excerpt":"","text":"二叉查找树的具体实现 二叉查找树的定义&emsp;&emsp;二叉查找树中的结点有五个字段值，left字段指向其左子树，right指向其右子树，key保存其键,为了保持键有序，规定所有的键都继承自Comparable接口，value保存其值，N保存的是该结点左子树和其右子树以及自身的键的个数。&emsp;&emsp;在二叉查找树中，其左子数结点中的键Key都小于根结点，右子树中的键都大于跟结点。 API列表public class BST&lt;Key extends Comparable&lt;Key&gt;,Value&gt; 返回值 方法名 说明 《无序和有序（部分）符号表API》 void put(Key key,Value) 将键值对存入树中 Value get(Kye key) 得到key对应的值 void delete(Key key) 删除key对应的键值对 boolean contains(Key key) 查找key是否存在于树中 boolean isEmpty() 检测是否为空 int size() 返回键值对的数目 《有序符号表API》 Key min() 返回最小的键 Key max() 返回最大的键 Key floor(Key key) 返回小于等于key的键 key ceiling(Key key) 返回大于等于key的键 int rank(Key key) 返回小于key的键 Key select(int k) 返回排名为k的键（从0开始计算） void deleteMin() 删除树中最小键值对 void deleteMax() 删除树中最大键值对 int size(Key lo,Key hi) 返回lo和hi之间的键值对的数量 Iterable&lt;Key&gt; keys(Key lo,Key hi) 返回lo和hi之间的键的迭代器，已排序 Iterable&lt;Key&gt; keys() 返回所有key的迭代器 几个重要的操作的实现二叉查找树还支持键的有序的操作，需要实现一些有序性操作的API。 删除操作(delete)在二叉查找树中删除一个结点的处理方式如下： 如果被删除结点不存在，则不进行任何操作 如果被删除结点存在，但是没有左右子结点，则可以将此节点直接删除 如果被删除结点只有左子结点或者只有右子结点，则直接返回此结点的子结点。 如果被删除结点既有左子结点，又有右子结点，则首先找到此结点右子树中最小的那个结点，然后将最小结点放到被删除结点的位置。代码实现如下： public void delete(Key key)&#123;//删除键值key所对应的键值对 if(root==null) return; root= delete(root,key); &#125; private Node delete(Node x,Key key)&#123; if(x==null) return null; int t=key.compareTo(x.key); if(t&lt;0) x.left=delete(x.left,key); else if(t&gt;0) x.right=delete(x.right,key); else&#123; if(x.left==null) return x.right;//当x为叶结点时特殊考虑!! if(x.right==null) return x.left;//!! Node k=x; x=min(k.right); x.right=deleteMin(k.right); x.left=k.left; &#125; x.N=size(x.left)+size(x.right)+1; return x; &#125; 向下取整(floor)和向上取整(ceiling)在有序符号表中，常常需要对键进行向下取整和向上取整，即小于等于和大于等于。其实现如下所示： public Key floor(Key key)&#123; //返回小于等于key的元素的键值 Node x=floor(root,key); return x==null?null:x.key; &#125; private Node floor(Node x,Key key)&#123; if(x==null) return null; int t=key.compareTo(x.key); if(t==0) return x; else if(t&lt;0) return floor(x.left,key); else &#123; Node k=floor(x.right,key); return k==null?x:k; &#125; &#125; 向上取整 public Key ceiling(Key key)&#123; //返回大于等于key的元素的键值 Node x=ceiling(root,key); return x==null?null:x.key; &#125; private Node ceiling(Node x,Key key)&#123; if(x==null) return null; int t=key.compareTo(x.key); if(t==0) return x; else if(t&gt;0) return ceiling(x.right,key); else&#123; Node k=ceiling(x.left,key); return k==null?x:k; &#125; &#125; 选择(select)和排名操作(rank) select(i)用于查找二叉查找树中位置大小为i的键，或者通过rank(K key)查找小于键key的键的数量。 在select中，如果当前结点的N的值大于i,则递归的在结点的左子树中选择位置大小为i的结点，如果N小于i，则递归的在右子树中查找位置大小为i-size(x.left)-1的键： select方法 public Key select(int i)&#123; Node x=select(root,i); return x==null?null:x.key; &#125; private Node select(Node x,int i)&#123; if(x==null) return null; int t=size(x.left); if(t&gt;i) return select(x.left,i); if(t==i) return x; return select(x.right,i-t-1); &#125; rank方法 public int rank(Key key)&#123;//返回小于key的键的数量 return rank(root,key); &#125; private int rank(Node x,Key key)&#123; if(x==null) return 0; int t=key.compareTo(x.key); if(t&gt;0) return size(x.left)+1+rank(x.right,key); if(t&lt;0) return rank(x.left,key); return size(x.left); &#125; 范围查找 范围查找能够查找位于键lo和hi之间的元素，其具体实现如下所示： public Iterable&lt;Key&gt; keys()&#123; Queue&lt;Key&gt; queue=new LinkedList&lt;&gt;(); keys(root,min(),max(),queue); return queue; &#125; public Iterable&lt;Key&gt; keys(Key lo,Key hi)&#123;//索引lo到hi之间的值 Queue&lt;Key&gt; queue=new LinkedList&lt;&gt;(); keys(root,lo,hi,queue); return queue; &#125; private void keys(Node x,Key lo,Key hi,Queue&lt;Key&gt; queue)&#123; if(x==null) return; int cmplo=lo.compareTo(x.key); int cmphi=hi.compareTo(x.key); if(cmplo&lt;0) keys(x.left,lo,hi,queue); if(cmplo&lt;=0&amp;&amp;cmphi&gt;=0) queue.add(x.key); if(cmphi&gt;0) keys(x.right,lo,hi,queue); &#125; 所有API的代码实现import java.util.LinkedList; import java.util.Queue; public class BSTT&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123; private Node root; class Node&#123; private Key key; private Value val; private Node left,right; private int N; public Node(Key key,Value val,int N)&#123; this.key=key; this.val=val; this.N=N; &#125; public Node()&#123;&#125; &#125; public int size()&#123; return size(root); &#125; private int size(Node x)&#123; if(x==null) return 0; return x.N; &#125; public int size(Key lo,Key hi)&#123; return size(root,lo,hi); &#125; private int size(Node x,Key lo,Key hi)&#123; if(x==null) return 0; int i=0; int cmplo=lo.compareTo(x.key); int cmphi=hi.compareTo(x.key); if(cmplo&lt;0) i+=size(x.left,lo,hi); if(cmplo&lt;=0&amp;&amp;cmphi&gt;=0) i++; if(cmphi&gt;0) i+=size(x.right,lo,hi); return i; &#125; public boolean isEmpty()&#123; return root==null; &#125; public Key min()&#123; Node x=min(root); return x==null?null:x.key; &#125; private Node min(Node x)&#123; if(x==null) return null; if(x.left==null) return x; return min(x.left); &#125; public Key max()&#123; Node x=max(root); return x==null?null:x.key; &#125; private Node max(Node x)&#123; if(x==null) return null; if(x.right==null) return x; return max(x.right); &#125; public boolean contains(Key key)&#123; return contains(root,key)==null?false:true; &#125; private Node contains(Node x,Key key)&#123; if(x==null) return null; int t=key.compareTo(x.key); if(t&lt;0) return contains(x.left,key); if(t&gt;0) return contains(x.right,key); return x; &#125; public void put(Key key,Value val)&#123; root=put(root,key,val); &#125; private Node put(Node x,Key key,Value val)&#123; if(x==null) return new Node(key,val,1); int t=key.compareTo(x.key); if(t&lt;0) x.left=put(x.left,key,val); else if(t&gt;0) x.right=put(x.right,key,val); else x.val=val; x.N=1+size(x.left)+size(x.right); return x; &#125; public Value get(Key key)&#123; Node x=get(root,key); return x==null?null:x.val; &#125; private Node get(Node x,Key key)&#123; if(x==null) return null; int t=key.compareTo(x.key); if(t&lt;0) return get(x.left,key); if(t&gt;0) return get(x.right,key); return x; &#125; public Key floor(Key key)&#123;//返回小于等于key的元素的键值 Node x=floor(root,key); return x==null?null:x.key; &#125; private Node floor(Node x,Key key)&#123; if(x==null) return null; int t=key.compareTo(x.key); if(t==0) return x; else if(t&lt;0) return floor(x.left,key); else &#123; Node k=floor(x.right,key); return k==null?x:k; &#125; &#125; public Key ceiling(Key key)&#123;//返回大于等于key的元素的键值 Node x=ceiling(root,key); return x==null?null:x.key; &#125; private Node ceiling(Node x,Key key)&#123; if(x==null) return null; int t=key.compareTo(x.key); if(t==0) return x; else if(t&gt;0) return ceiling(x.right,key); else&#123; Node k=ceiling(x.left,key); return k==null?x:k; &#125; &#125; public Key select(int i)&#123; Node x=select(root,i); return x==null?null:x.key; &#125; private Node select(Node x,int i)&#123; if(x==null) return null; int t=size(x.left); if(t&gt;i) return select(x.left,i); if(t==i) return x; return select(x.right,i-t-1); &#125; public int rank(Key key)&#123;//返回小于key的键的数量 return rank(root,key); &#125; private int rank(Node x,Key key)&#123; if(x==null) return 0; int t=key.compareTo(x.key); if(t&gt;0) return size(x.left)+1+rank(x.right,key); if(t&lt;0) return rank(x.left,key); return size(x.left); &#125; public Key deleteMin()&#123; if(root==null) return null; Node node=new Node(); root=deleteMin(root,node); return node.key; &#125; private Node deleteMin(Node x,Node node)&#123; if(x.left==null) &#123; node.key=x.key; return x.right; &#125; x.left = deleteMin(x.left,node); x.N=size(x.left)+size(x.right)+1; return x; &#125; private Node deleteMin(Node x)&#123; if(x==null) return null; if(x.left==null) &#123; return x.right; &#125; x.left = deleteMin(x.left); x.N=size(x.left)+size(x.right)+1; return x; &#125; public Key deleteMax()&#123; if(root==null) return null; Node node=new Node(); root = deleteMax(root,node); return node.key; &#125; private Node deleteMax(Node x,Node node)&#123; if(x.right==null) &#123; node.key=x.key; return x.left; &#125; x.right = deleteMax(x.right,node); x.N=size(x.left)+size(x.right)+1; return x; &#125; public String toString()&#123; Node current=root; StringBuilder sb=new StringBuilder(); sb.append(&quot;[ &quot;); print(current,sb); sb.replace(sb.length()-1,sb.length(),&quot; ]&quot;); return sb.toString(); &#125; private StringBuilder print(Node x,StringBuilder sb)&#123;//中序遍历 if(x==null) return sb; print(x.left,sb); sb.append(x.key+&quot;:&quot;+x.val+&quot;,&quot;); print(x.right,sb); return sb; &#125; public void delete(Key key)&#123;//删除键值key所对应的键值对 root= delete(root,key); &#125; private Node delete(Node x,Key key)&#123; if(x==null) return null; int t=key.compareTo(x.key); if(t&lt;0) x.left=delete(x.left,key); else if(t&gt;0) x.right=delete(x.right,key); else&#123; if(x.left==null) return x.right;//当x为叶结点时特殊考虑!! if(x.right==null) return x.left;//!! Node k=x; x=min(k.right); x.right=deleteMin(k.right); x.left=k.left; &#125; x.N=size(x.left)+size(x.right)+1; return x; &#125; public Iterable&lt;Key&gt; keys()&#123; Queue&lt;Key&gt; queue=new LinkedList&lt;&gt;(); keys(root,min(),max(),queue); return queue; &#125; public Iterable&lt;Key&gt; keys(Key lo,Key hi)&#123;//索引lo到hi之间的值 Queue&lt;Key&gt; queue=new LinkedList&lt;&gt;(); keys(root,lo,hi,queue); return queue; &#125; private void keys(Node x,Key lo,Key hi,Queue&lt;Key&gt; queue)&#123; if(x==null) return; int cmplo=lo.compareTo(x.key); int cmphi=hi.compareTo(x.key); if(cmplo&lt;0) keys(x.left,lo,hi,queue); if(cmplo&lt;=0&amp;&amp;cmphi&gt;=0) queue.add(x.key); if(cmphi&gt;0) keys(x.right,lo,hi,queue); &#125; public static void main(String[] args)&#123;//测试代码 BSTT&lt;Integer,String&gt; bst=new BSTT&lt;&gt;(); bst.put(1,&quot;one&quot;); bst.put(2,&quot;two&quot;); bst.put(3,&quot;three&quot;); bst.put(4,&quot;four&quot;); System.out.println(&quot;bst.size():&quot;+bst.size()); System.out.println(&quot;bst.get(2):&quot;+bst.get(2)); System.out.println(&quot;bst.contains(3):&quot;+bst.contains(3)); System.out.println(&quot;bst.isEmpty():&quot;+bst.isEmpty()); System.out.println(&quot;bst.max():&quot;+bst.max()); System.out.println(&quot;bst.min():&quot;+bst.min()); System.out.println(&quot;bst.floor(5):&quot;+bst.floor(5)); System.out.println(&quot;bst.ceiling(7):&quot;+bst.ceiling(7)); System.out.println(&quot;bst.select(1):&quot;+bst.select(1)); System.out.println(&quot;bst.rank(3):&quot;+bst.rank(5)); System.out.println(bst.deleteMax()+&quot;bst.deleteMax():&quot;+bst); System.out.print(bst.deleteMin()+&quot;bst.deleteMin():&quot;+bst); System.out.print(&quot;bst.delete(3):&quot;); bst.delete(3); System.out.println(bst); System.out.print(&quot;bst.keys():&quot;); for(Integer key:bst.keys()) System.out.print(key+&quot; &quot;); System.out.println(); System.out.print(&quot;bst.keys(1,3):&quot;); for(Integer key:bst.keys(1,3)) System.out.print(key+&quot; &quot;); System.out.println(); System.out.println(&quot;bst.size(-1,5):&quot;+bst.size(1,5)); &#125; &#125; 性能分析二叉查找树的实现不是非常困难，而正常情况下的查找和插入的时间复杂度能够达到对数级别$1.39lgN$,但是当插入键的顺序为有序时，则二叉查找树会退化为链表，从而查找和插入操作的时间复杂度变为N，在大规模数据中这是不可接受的。二叉查找树的替代方案是使用平衡二叉树。平衡二叉树能够将相邻结点的到达根节点的差保持在一定的范围内。从而避免二叉树由于不平衡而带来的性能损失。","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://super-aviator.github.io/categories/DataStructure/"}],"tags":[{"name":"符号表","slug":"符号表","permalink":"https://super-aviator.github.io/tags/%E7%AC%A6%E5%8F%B7%E8%A1%A8/"}],"author":"熊乾坤"},{"title":"排序算法总结与扩展","slug":"排序算法总结与扩展","date":"2018-04-14T11:39:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2018/04/14/排序算法总结与扩展/","link":"","permalink":"https://super-aviator.github.io/2018/04/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8E%E6%89%A9%E5%B1%95/","excerpt":"排序算法总结与扩展","text":"排序算法总结与扩展 排序算法总结各种排序算法的性能特点算法名称 | 是否稳定 | 是否为原地排序 | 时间复杂度 | 空间复杂度 | 备注— | — | — | — | — | — | —选择排序 | 否 | 是 | $N^2$ | 1 | 无插入排序 | 是 | 是 | $N$$N^2$ | 1 | 时间复杂度与顺序有关希尔排序 | 否 | 是 | $NlogN$,$N^{6/5}$ | 1 | 无快速排序 | 否 | 是 | $NlogN$$N^2$ | $lgN$ | 运行效率由概率提供保证，与枢纽元的选取有关三向快速切分 | 否 | 是 | $N$~$NlogN$ | $lgN$ | 当有序时时间复杂度为N,无序时为$NlogN$归并排序 | 是 | 否 | $NlogN$ | N | 空间复杂度与元素个数成正比堆排序 | 否 | 是 | $NlogN$ | 1 | 无 排序算法的选择 无论大规模还是小规模数据，快速排序是最快的通用排序算法，但是稳定性不如归并排序，性能依靠枢纽元的选取，对于有序数据，使用三向切分快速排序运行时间可以达到线性级别 如果空间不成问题而对稳定性要求高，则可以选择归并排序 堆排序对于使用于大量插入和删除操作混合的场景，也能保证对数级别的运行时间，也适用于空间紧张的情形 希尔排序的性能仅次于高级排序算法，而且代码量少，是高级排序算法的替代算法，性能依赖于希尔序列 插入排序适用于数组有序或者部分有序，对于小规模的数组运行时间较短。 排序算法扩充排序中的比较器(Comparator)用法&emsp;&emsp;比较器用于对相同的事物使用不同的比较规则的排序方法.例如在对String数组排序时,可以使用’忽略字母大小写’(String.CASE_INSENSITIVE_ORDER)的比较器进行排序. 比较器的创建方法.&emsp;&emsp;比较器一般使用静态内部类(嵌套类)实现.例如在对Transaction(交易)类中定义比较器: public class Transaction&#123; private final String who; private final Date when; private final double amount;//定义待比较的数据类型 public static class WhoOrder implements Comparator&lt;Tansaction&gt;&#123; public int CompareTo(Transaction v,Transaction w)&#123; return v.who.compareTo(w.who); &#125;//定义比较器1 public static class whenOrder implements Comparator&lt;Tansaction&gt;&#123; public int CompareTo(Transaction v,Transaction w)&#123; return v.when.compareTo(w.when); &#125;//定义比较器2 public static class HowMuchOrder implements Comparator&lt;Tansaction&gt;&#123; public int CompareTo(Transaction v,Transaction w)&#123; return v.amount.compareTo(w.amount); &#125;//定义比较器3 &#125; &#125; 比较器的使用方法使用比较器使,首先需要排序支持比较器,以插入排序为例,代码如下 public static void sort(Object[] a,Comparator c) &#123; //各种排序算法的实现 int N=a.length; for(int i=1;i&lt;N;i++) &#123; for(int j=i;j&gt;0&amp;&amp;less(a[j],a[j-1]);j--) //如果后一个数小于它的前一个数 exch(a,j,j-1);//就将他们交换. &#125; &#125;//核心代码 private static boolean less(Compartor c,Object a,Object b)&#123; return c.comparTo(a,b)&lt;0 &#125; private static void exch(Object[] a,int i,int j){ Object t=a[i],a[i]=a[j],a[j]=t;} 在比较时,只需要将比较器对象传入sort函数: `sort(a,new Transaction.Who());` --- #### 排序算法的稳定性 &amp;emsp;&amp;emsp;算法的稳定性是指相同的元素在排序前和排序后的相对位置不变. &amp;emsp;&amp;emsp;稳定性在某些应用中的排序非常重要.而我们已经学过的算法中,插入排序和归并排序是稳定的.而选择排序,希尔排序,快速排序是不稳定的. --- #### 通用最快算法以及原始数据排序 &amp;emsp;&amp;emsp;排序算法中,通用的速度最快的算法是快速排序,在考虑排序算法时要充分考虑. &amp;emsp;&amp;emsp;在对原始数据排序时,可以忽略Comparable接口,直接进行排序,甚至可以将less等函数用a[k]&lt;a[j]替换. --- #### java系统库中的Arrays.sort()方法的实现 &amp;emsp;&amp;emsp;java系统库的sort方法针对不同的数据使用了不同的方法 - 每种原始数据类型都有对应的方法 - 实现了Comparable接口的排序方法 - 拥有比较器(Comparator)的排序方法 &amp;emsp;&amp;emsp;如果是基本类型,使用的是三向切分的快速排序,如果是引用数组,则使用归并排序(用空间换取稳定性). ## 排序算法的应用 #### 查找数组重复元素的个数 &amp;emsp;&amp;emsp;常常遇到一些问题是，查找数组中重复元素的个数，一般使用平方级别的算法将所有元素相互比较一边就可以得到，但是对于大数组行不通，更高效的方法是将数组排序，然后使用线性级别算法就可以得到结果。 ```java import java.util.*; public class Demo &#123; public static void main(String[] args)&#123; int[] a=&#123;1,2,2,2,2,3,4,5,5,5,6,7,8,8,8,8,8,8,10&#125;; Map&lt;Integer,Integer&gt; map=new TreeMap&lt;&gt;(); for(int i=1;i&lt;a.length;i++)&#123; if(a[i]==a[i-1])&#123; if(map.containsKey(a[i])) map.put(a[i],map.get(a[i])+1); else map.put(a[i],2); &#125; &#125; for(Integer i:map.keySet()) System.out.println(&quot;数字:&quot;+i+&quot;重复的次数为：&quot;+map.get(i)); &#125; &#125; 排名（查找kendall tau距离，即数组中逆序对的个数） 基础解法&emsp;&emsp;类似于选择排序与插入排序，时间复杂度为平方级别。 public class KendallTau &#123; public static void main(String[] args)&#123; int[] a=&#123;0,1,2,3&#125;; int[] b=&#123;3,2,1,0&#125;; int[] sum1=new int[a.length],sum2=new int[b.length]; for(int i=0;i&lt;a.length;i++) sum1[a[i]]=i; for(int i=0;i&lt;b.length;i++) sum2[b[i]]=i; //将索引保存 int sum=0; for(int i=0;i&lt;a.length;i++)&#123; for(int j=0;j&lt;b.length;j++)&#123; if(i==j) continue; int disOld=sum1[a[i]]-sum1[a[j]]; int disNow=sum2[a[i]]-sum2[a[j]]; if((disOld&gt;0&amp;&amp;disNow&gt;0)||(disNow&lt;0&amp;&amp;disOld&lt;0)); else sum++; &#125; &#125; System.out.println(&quot;逆序对的数量为：&quot;+sum/2); &#125; &#125; 改进算法&emsp;&emsp;还没弄懂！！！Y_Y，观望一段时间先。 基于快速排序的查找数组中第k小的元素&emsp;&emsp;基于快速排序和二分查找,我们可以查找到数组中第k小的元素.代码如下: import java.util.*; public class FindK&#123; public static void exch(int[] a,int x,int y)&#123; int tmp=a[x]; a[x]=a[y]; a[y]=tmp; &#125; public static int partition(int[] a,int lo,int hi)&#123; int st=lo,en=hi+1; int t=a[lo]; while(true)&#123; if(a[++st]&lt;t) if(st&gt;=hi) break; if(a[--en]&gt;t) ; if(st&gt;=hi) break; exch(a,st,en); &#125; exch(a,lo,en); return en; &#125; public static void main(String[] args)&#123; int[] a=&#123;1,2,2,2,2,3,4,5,5,5,6,7,8,8,8,8,8,8,10&#125;; int lo=0,hi=a.length-1; int j=-1; int k=6; if(k&gt;hi) &#123;//特例 System.out.println(&quot;没有找到哦！！！&quot;); System.exit(0); &#125; while(lo&lt;=hi)&#123; j =partition(a,lo,hi); if(j==k) break; else if(j&lt;k) lo=j+1; else hi=j-1; &#125; System.out.println(&quot;第&quot;+k+&quot;小的数为：&quot;+a[j]); &#125; &#125; 对于N个输入,查找第k小的元素,该算法只需要线性级别的时间.划重点，面试会问的哦。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://super-aviator.github.io/categories/Algorithm/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://super-aviator.github.io/tags/%E6%8E%92%E5%BA%8F/"}],"author":"熊乾坤"},{"title":"优先队列(Priority Queue)与堆排序","slug":"优先队列","date":"2018-04-12T10:27:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2018/04/12/优先队列/","link":"","permalink":"https://super-aviator.github.io/2018/04/12/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","excerpt":"优先队列以及基于优先队列的堆排序","text":"优先队列以及基于优先队列的堆排序 优先队列优先队列最重要的个操作是删除最大元素和插入元素，优先队列的实现方式有许多种.&emsp;&emsp;如果使用链表或者数组实现，那么可以把元素分为两种存放方式，可以将元素在插入时保持有序，那么插入的时间复杂度就是N，删除时就直接删除第一个元素，删除的时间复杂度为1；&emsp;&emsp;如果在插入时元素无序，那么插入时的时间复杂度为1，删除时就需要遍历所有元素，那么删除的时间复杂度就是N；&emsp;&emsp;如果使用二叉堆实现，由于堆的层数是$ logN $，所以插入和删除的时间复杂度都是logN。 二叉堆的实现 二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储，不使用数组中第一个位置 &emsp;&emsp;基于数组下标从1开始的二叉堆,某个下标为k的节点的父节点下标为k/2,其左子节点的下标为2k,右子节点的下标为(2k+1)。通过归纳可得，一棵结点数量为N的二叉堆，他的层次是$ logN $。 结点上浮(swim)&emsp;&emsp;当向一个有序堆末尾插入一个元素，此时如果该元素比他的父结点大，此时堆就是一个不稳定堆，此时需要调整至堆有序的状态，那么就需要将插入的结点上浮到适合的位置，代码如下： private void swim(int k)&#123; while(k&gt;1&amp;&amp;less(k/2,k))&#123; exch(k/2,k); k/=2; &#125; &#125; 结点下沉(sink)&emsp;&emsp;当由于顶结点被删除并将最后一个元素插入时，如果此元素比他的子结点更小时，那么此时我们就需要调整堆的状态，将此结点下沉到合适的位置以保证堆有序，代码如下；其中第4行代码实现非常巧妙，j&lt;N用于确定结点k的右子结点是否存在，而less(j,j+1)用于确定右子结点是否大于左子结点。如果两个条件都满足，表明右子结点大于左子结点，此时j指向右子结点，反之则指向左子结点。 private void sink(int k)&#123; while(k*2&lt;=N)&#123; int j=k*2; if(j&lt;N&amp;&amp;less(j,j+1)) j++; if(!less(k,j)) break; exch(k,j); k=j; &#125; &#125; 插入元素&emsp;&emsp;我们将新元素加到数组末尾，增加堆的大小，并让这个新元素上浮到合适的位置。 删除元素&emsp;&emsp;我们将数组顶端元素删除并保存，减小堆的大小，然后将数组中最后的元素放置到数组顶端，然后实现下沉函数将此元素下沉到合适的位置。 自动扩充数组容量&emsp;&emsp;在插入或者删除二叉堆中的元素之后，需要对数组中含有的元素进行判断，达到动态扩充和缩减的效果。 二叉堆实现实现 public class PriorityQueue&lt;Item extends Comparable&lt;Item&gt;&gt; &#123; private Item[] items; private int N; public PriorityQueue(int maxN) &#123; items = (Item[]) new Comparable[maxN + 1]; &#125; public PriorityQueue() &#123; items = (Item[]) new Comparable[16];//默认堆大小为16 &#125; public boolean isEmpty() &#123; return N == 0; &#125; public int size() &#123; return N; &#125; public void insert(Item item) &#123; if(N&gt;items.length*2/3) resize(items.length,true); items[++N] = item; swim(N); &#125; public Item delMax() &#123; if(N&lt;items.length/3) resize(items.length,false); Item result = items[1]; exch(1, N--); items[N + 1] = null; sink(1); return result; &#125; public int capacity() &#123; return items.length; &#125; private void swim(int k) &#123; while (k &gt; 1 &amp;&amp; less(k / 2, k)) &#123; exch(k / 2, k); k /= 2; &#125; &#125; private void sink(int k) &#123; while (2 * k &lt;= N) &#123; int j = 2 * k; if (j &lt; N &amp;&amp; less(j, j + 1)) j++; if (!less(k, j)) break; exch(k, j); k = j; &#125; &#125; private void resize(int old, boolean isDilatation) &#123; //判断是扩容(dilatation)还是缩减(curtail) int current; if (isDilatation)//dilatation current = old * 2; else //curtail current = old / 2; Item[] newItems = (Item[]) new Comparable[current]; System.arraycopy(items,0,newItems,0,N); items = newItems; &#125; private boolean less(int x, int y) &#123; return items[x].compareTo(items[y]) &lt; 0; &#125; private void exch(int x, int y) &#123; Item t = items[x]; items[x] = items[y]; items[y] = t; &#125; public static void main(String[] args) &#123; Integer[] ints = new Integer[]&#123;23, 547, 234, 92, 56, 23, 2, 52, 5, 234, 5&#125;; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(3); for (Integer c : ints) pq.insert(c); System.out.println(pq.size()); System.out.println(pq.isEmpty()); while (!pq.isEmpty()) System.out.print(pq.delMax() + &quot; 此时堆的容量为：&quot;+pq.capacity()+&quot;\\n&quot;); &#125; &#125; //output11false547 此时堆的容量为：16234 此时堆的容量为：16234 此时堆的容量为：1692 此时堆的容量为：1656 此时堆的容量为：1652 此时堆的容量为：1623 此时堆的容量为：1623 此时堆的容量为：85 此时堆的容量为：85 此时堆的容量为：82 此时堆的容量为：44 - 时间复杂度分析 &amp;emsp;&amp;emsp;插入元素操作只需不超过(lgN+1)次比较(二叉堆的层数为lgN+1,需要k和k/2比较一次),删除操作需要不超过2lgN次比较(二叉堆层数为lgN,需要比较j和j+1,两者较大者再与k比较,共两次). &amp;emsp;&amp;emsp;对于需要大量插入和删除操作的应用来说,堆实现有很大的好处,使用无序或者有序数组(链表)的有线队列实现总是需要线性(N)时间来完成,而使用二叉堆实现则只需要对数级(logN)时间完成. --- - 索引二叉堆优先队列 //!没看懂... --- ## 一种全新的排：堆排序 &amp;emsp;&amp;emsp;利用优先队列,我们可以很简单的对数组进行排序：堆排序，堆排序有两个步骤。 - 步骤一 是构造有序堆，对于大小为N的数组，可以从右到左将每个元素进行sink操作，而更加快速的方法是只对拥有子结点的结点进行sink操作，而跳过叶结点。这是因为当一个结点的左右子结点已经是堆有序时，对该结点进行sink操作一定可以构造一个有序堆。如图所示，只需要从右到左对红色的结点进行sink操作。 ![堆排序][create] - 步骤二 是排序阶段，每次将堆顶元素与堆中最后的元素交换，然后再对堆顶元素进行sink操作使得堆有序。 - 代码实现: ```java package unit2_4_code; public class HeapSort &#123; public static void sort(Comparable[] a)&#123; int N=a.length-1; for(int k=N/2;k&gt;=0;k--)//堆构造 sink(a,k,N); //show(a); while(N&gt;0)&#123; exch(a,0,N--);//保存此时堆中的最大值到N中 sink(a,0,N); &#125; &#125; public static boolean less(Comparable[] a,int x,int y)&#123; return a[x].compareTo(a[y])&lt;0; &#125; private static void exch(Comparable[] a,int x,int y)&#123; Comparable t=a[x]; a[x]=a[y]; a[y]=t; &#125; private static void sink(Comparable[] a,int k,int N)&#123; while(2*k+1&lt;=N)&#123;//保证k有子结点 int j=2*k+1; if(j&lt;N&amp;&amp;less(a,j,j+1)) j++; if(!less(a,k,j)) break; exch(a,k,j); k=j; &#125; &#125; private static void show(Comparable[] a)&#123; for(Comparable b:a) System.out.print(b+&quot; &quot;); System.out.println(); &#125; public static void main(String[] args)&#123; Integer[] i=&#123;22,31,123,3241,34,1,34,233,22,11,5,74&#125;; sort(i); show(i); &#125; &#125; //output 1 5 11 22 22 31 34 34 74 123 233 3241 结论 下标0开始的堆，某结点k的左子结点为2k+1,右子结点为2k+2。大小为N的二叉树中，非叶结点的个数为N/2。 时间复杂度分析:&emsp;&emsp; 堆排序需要2NlgN+2N次比较以及一半次数的交换.&emsp;&emsp; 此方法在插入和删除操作较多的排序时也能保持对数级别的运行时间.因为它需要~2NlgN次比较和恒定的空间,所以在内存比较紧张的情况下使用比较常见.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://super-aviator.github.io/categories/Algorithm/"}],"tags":[{"name":"Java数据结构","slug":"Java数据结构","permalink":"https://super-aviator.github.io/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"排序","slug":"排序","permalink":"https://super-aviator.github.io/tags/%E6%8E%92%E5%BA%8F/"}],"author":"熊乾坤"},{"title":"Java中LinkedList的学习","slug":"Java中LinkedList的学习","date":"2018-04-11T13:44:00.000Z","updated":"2021-02-23T12:59:58.000Z","comments":true,"path":"2018/04/11/Java中LinkedList的学习/","link":"","permalink":"https://super-aviator.github.io/2018/04/11/Java%E4%B8%ADLinkedList%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"LinkedList是java中使用链表的数据结构，通过它可以时间许多常用的数据结构","text":"LinkedList是java中使用链表的数据结构，通过它可以时间许多常用的数据结构 概述LinkedList支持许多方法，能够使用它来作为队列，栈或者双端链表等数据结构。它的数据的方向为： 队首(First)------------元素-------------(Last)队尾 继承图Collection:Map: 方法和实现的接口 Queue接口中的方法： //入队列 boolean add(E e) 将指定的元素插入此队列队尾（如果立即可行且不会违反容量限制），在成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException。 boolean offer(E e) 将指定的元素插入此队列队尾（如果立即可行且不会违反容量限制），当使用有容量限制的队列时，此方法通常要优于 //访问第一个元素 E element() 获取，但是不移除此队列队首。为空时抛出NoSuchElementException异常 E peek() 获取但不移除此队列队首；如果此队列为空，则返回 null。 //出队列 E poll() 获取并移除此队列队首，如果此队列为空，则返回 null。 E remove() 获取并移除此队列队首。如果为空抛出NoSuchElementException; Deque接口： LinkedList实现Stackimport java.util.*; public class Stack&lt;T&gt; &#123; private LinkedList&lt;T&gt; stack=new LinkedList&lt;T&gt;(); public void push(T t) &#123;stack.addFirst(t);&#125; public T pop() &#123;return stack.removeFirst();&#125; public T peek() &#123;return stack.getFirst();&#125; public boolean isEmpty() &#123;return stack.isEmpty();&#125; public String toString() &#123;return stack.toString();&#125; public static void main(String[] args) &#123; Stack&lt;String&gt; s=new Stack&lt;String&gt;(); for(String str:&quot;Hello My Name Is X Q K&quot;.split(&quot; &quot;)) s.push(str); while(!s.isEmpty()) &#123; System.out.print(s.pop()+&quot; &quot;); &#125; &#125; &#125; LinkedList实现Queue由于LinkedList实现了Queue接口，所以可以直接使用LinkedList实现Queue,并向上转型,就可以安全的使用队列了。 import java.util.*; public class MyQueue &#123; public static void main(String[] args) &#123; Queue&lt;Integer&gt; q=new LinkedList&lt;Integer&gt;(); for(int i=0;i&lt;10;i++) q.offer(i);//入队列 while(!q.isEmpty()) &#123; System.out.print(q.peek()+&quot; &quot;);//访问第一个元素 System.out.println(q.poll());//删除第一个元素 &#125; &#125; &#125; LikedList实现PriorityQueue 构造函数：&emsp;&emsp;PriorityQueue默认容量为11，也可以自定义容量，只需在构造函数中指定大小即可，在指定容量的同时，可以传入比较器Comparator来自定义排序规则。PriorityQueue理所当然的支持任何Collection对象为参数构造优先队列。 PriorityQueue() 使用默认的初始容量（11）创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。 PriorityQueue(Collection&lt;? extends E&gt; c) 创建包含指定 collection 中元素的 PriorityQueue。 PriorityQueue(int initialCapacity) 使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。 PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) 使用指定的初始容量创建一个 PriorityQueue，并根据指定的比较器对元素进行排序。 PriorityQueue(PriorityQueue&lt;? extends E&gt; c) 创建包含指定优先级队列元素的 PriorityQueue。 PriorityQueue(SortedSet&lt;? extends E&gt; c) 创建包含指定有序 set 元素的 PriorityQueue。 成员方法 PriorityQueue继承自Queue，它拥有Queue接口的所有方法，在此基础上添加了如下几个方法 Comparator&lt;? super E&gt; comparator() 返回用来对此队列中的元素进行排序的比较器；如果此队列根据其元素的自然顺序进行排序，则返回 null。 Object[] toArray() 返回一个包含此队列所有元素的数组。 &lt;T&gt; T[] toArray(T[] a) 返回一个包含此队列所有元素的数组；返回数组的运行时类型是指定数组的类型。注意！此时如果给定的T数组大小不够，则根据T的类型返回大小合适的T类型的数组。 示例&emsp;&emsp;空格的优先级最高，标点符号其次，字母优先级最小(ASCII码表实现) import java.util.Collections; import java.util.PriorityQueue; public class MyPriorityQueue &#123; public static void main(String[] args) &#123; PriorityQueue&lt;String&gt; pq=new PriorityQueue&lt;String&gt;(); for(String str:&quot;ASFGO,. DJASFSIO&quot;.split(&quot;&quot;)) pq.add(str); while(pq.peek()!=null) &#123; System.out.print(pq.poll()); &#125; System.out.println(); pq=new PriorityQueue&lt;String&gt;(20,Collections.reverseOrder()); for(String str:&quot;ASFGO,. DJASFSIO&quot;.split(&quot;&quot;)) pq.add(str); while(pq.peek()!=null) &#123; System.out.print(pq.poll()); &#125; &#125; &#125; //output! ,.AADFFGIJOOSSS SSSOOJIGFFDAA.,","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://super-aviator.github.io/categories/Algorithm/"}],"tags":[{"name":"Java数据结构","slug":"Java数据结构","permalink":"https://super-aviator.github.io/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"熊乾坤"},{"title":"吸血鬼数字的两种解法","slug":"吸血鬼数字的两种解法","date":"2018-04-09T09:45:00.000Z","updated":"2021-02-23T13:00:02.000Z","comments":true,"path":"2018/04/09/吸血鬼数字的两种解法/","link":"","permalink":"https://super-aviator.github.io/2018/04/09/%E5%90%B8%E8%A1%80%E9%AC%BC%E6%95%B0%E5%AD%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A7%A3%E6%B3%95/","excerpt":"吸血鬼数字的解法","text":"吸血鬼数字的解法 基础解法&emsp;&emsp;根据吸血鬼数字的特点，将a*b=c中的a+b的每一位数字和c中每一位数字排序之后进行比较，如果排序之后的字符串相等，则认为c是一个吸血鬼数字。 代码实现：import java.util.Arrays; public class Vampire { public static void main(String[] args){ StopWatch stopWatch=new StopWatch(); int counter=0,time=0; for(int i=10;i&lt;100;i++){ for(int j=i+1;j&lt;100;j++){ int sum=i*j; if(sum&lt;=1000||sum&gt;9999) continue; time++; char[] num1=String.valueOf(i+””+j).toCharArray(); char[] num2=String.valueOf(sum).toCharArray(); Arrays.sort(num1); Arrays.sort(num2); if(Arrays.equals(num1,num2)) &#123; counter++; System.out.println(i+&quot;:&quot;+j+&quot;=&quot;+sum+&quot;是吸血鬼数字！&quot;); &#125; &#125; &#125; System.out.println(&quot;总共找到&quot;+counter+&quot;组vampireNumber；\\n&quot;+&quot;此程序总共进行了&quot;+time+&quot;次比较，&quot;+&quot;运行时间为：&quot;+stopWatch.elapsedTime()+&quot;s&quot;); &#125; }//output15:93=1395是吸血鬼数字！21:60=1260是吸血鬼数字！21:87=1827是吸血鬼数字！27:81=2187是吸血鬼数字！30:51=1530是吸血鬼数字！35:41=1435是吸血鬼数字！80:86=6880是吸血鬼数字！总共找到7组vampireNumber；此程序总共进行了3269次比较，运行时间为：0.02s ### 改进算法 在前面的算法中，比较的次数大约为4000次。但是根据下面的方法，可以将比较次数缩减到大约300次： &amp;emsp;&amp;emsp;令sum=1000\\*a+100\\*b+10\\*c+d,我们假设他的两个因子(大小肯定为两位数)为：num1=10\\*a+b;num2=10\\*c+d;那么通过sum-num1-num2我们可以得到sum-num1-num2=990\\*a+9\\*b=9\\*(110a+b).所以sum-num1-num2肯定可以被9整除。 &amp;emsp;&amp;emsp;在i确定时，我们可以确定j开始循环的范围。所以可以使用start和end来确定j的范围。 &amp;emsp;&amp;emsp;这告诉我们学好数学的重要性。o_o... - 代码实现 ```java import java.util.Arrays; public class VampireNumber &#123; public static void main(String[] args)&#123; StopWatch stopWatch=new StopWatch(); int counter=0,time=0; for(int i=10;i&lt;100;i++)&#123; int start=Math.max(1000/i,i+1); int end=Math.min(10000/i,100); for(int j=start;j&lt;end;j++)&#123; int sum=i*j; if(sum%100==0||(sum-i-j)%9!=0) continue; time++; char[] num1=String.valueOf(i+&quot;&quot;+j).toCharArray(); char[] num2=String.valueOf(sum).toCharArray(); Arrays.sort(num1); Arrays.sort(num2); if(Arrays.equals(num1,num2)) &#123; counter++; System.out.println(i+&quot;:&quot;+j+&quot;=&quot;+sum+&quot;是吸血鬼数字！&quot;); &#125; &#125; &#125; System.out.println(&quot;总共找到&quot;+counter+&quot;组vampireNumber；\\n&quot;+&quot;此程序总共进行了&quot;+time+&quot;次比较，&quot;+&quot;运行时间为：&quot;+stopWatch.elapsedTime()+&quot;s&quot;); &#125; &#125; //output 15:93=1395是吸血鬼数字！ 21:60=1260是吸血鬼数字！ 21:87=1827是吸血鬼数字！ 27:81=2187是吸血鬼数字！ 30:51=1530是吸血鬼数字！ 35:41=1435是吸血鬼数字！ 80:86=6880是吸血鬼数字！ 总共找到7组vampireNumber； 此程序总共进行了232次比较，运行时间为：0.009s","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://super-aviator.github.io/categories/Algorithm/"}],"tags":[{"name":"算法疑惑解答","slug":"算法疑惑解答","permalink":"https://super-aviator.github.io/tags/%E7%AE%97%E6%B3%95%E7%96%91%E6%83%91%E8%A7%A3%E7%AD%94/"}],"author":"熊乾坤"},{"title":"快速排序（java实现）","slug":"快速排序（java实现）","date":"2018-04-09T08:16:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2018/04/09/快速排序（java实现）/","link":"","permalink":"https://super-aviator.github.io/2018/04/09/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88java%E5%AE%9E%E7%8E%B0%EF%BC%89/","excerpt":"快速排序是二十一世纪十大重大算法之一","text":"快速排序是二十一世纪十大重大算法之一 执行方法（先排后分）&emsp;&emsp;首先选定数组中lo为枢纽元,然后执行partition函数,使得lo左边的元素都小于lo,lo右边的元素都大于lo,然后对数组从lo分割,递归的将左边数组和右边数组进行排序.在归并排序中，是先分隔后排序，在快速排序中是先排序再分割。 代码实现public class Quick extends Sortable &#123; public static void sort(Comparable[] a) &#123; Arrays.shuffle(a); sort(a, 0, a.length - 1); &#125; private static void sort(Comparable[] a, int lo, int hi) &#123; if (lo &gt;= hi) return;//递归终止条件 int median = partition(a, lo, hi); sort(a, lo, median - 1); sort(a, median + 1, hi); &#125; private static int partition(Comparable[] a, int lo, int hi) &#123; Comparable temp = a[lo]; // 设置a[lo]为枢纽元. int i = lo, j = hi + 1; while (true) &#123; while (less(a[++i], temp)) if(i==hi) break; while (less(temp, a[--j])) if(j==lo) break; if (i&gt;=j) break; exch(a, i, j); &#125; exch(a, lo, j); return j; &#125; &#125; 时间复杂度分析&emsp;&emsp;快速排序被誉为21世纪十大重大算法之一,是一种非常快速的排序算法,对于大小为N的数组,他平均需要2NlgN（实际是1.39NlgN）次比较.最大需要$ N^2/2 $次比较，这种情况只有在每次枢纽元都是数组中最大或者最小的时候才会出现，可以通过随机打乱数组避免.归并排序和希尔排序一般都比快速排序慢,因为快速排序需要使用较少的移动数据的次数。而归并排序需要较多的数据移动。 几种改进方法 当待排序的数组元素个数小于5~15时,使用插入排序(Insertion)排序.即将if (lo &gt;= hi) return;替换为if(hi&lt;=lo+10)&#123;Insertion.sort(a,lo,hi);return;&#125; 对于大量重复的数组,使用三向切分来切分数组. public class Quick3way extends Quick &#123; public static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int lt = lo, gt = hi, i = lo + 1; Comparable temp = a[lo]; /** lo~lt-1 :小于temp的元素 lt~i:等于temp的元素 gt+1~hi:大于temp的元素 i~gt:未确定的元素 */ while (i &lt;= gt) &#123; int cmp = a[i].compareTo(temp); if (cmp &lt; 0) exch(a, lt++, i++); else if (cmp &gt; 0) exch(a, gt--, i); else i++; &#125; sort(a, lo, lt - 1); sort(a, gt + 1, hi); &#125; &#125; 对于大量重复元素的数组,三向切分的方法比二分法的运行效率高得多.他将排序时间从线性对数级别缩小到到线性级别。三向切分运行时的数据分布图如下： 快速三向切分法&emsp;&emsp;还没看懂T~T???","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://super-aviator.github.io/categories/Algorithm/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://super-aviator.github.io/tags/%E6%8E%92%E5%BA%8F/"}],"author":"熊乾坤"},{"title":"final关键字","slug":"final关键字","date":"2018-04-08T09:47:00.000Z","updated":"2021-02-23T13:00:12.000Z","comments":true,"path":"2018/04/08/final关键字/","link":"","permalink":"https://super-aviator.github.io/2018/04/08/final%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"final关键字代表的是”无法改变的”,在java中有许多种用法","text":"final关键字代表的是”无法改变的”,在java中有许多种用法 final作用于数据final作用于域final作用于域有两种情况:1: 一个永不改变的编译期常量2: 一个在运行时被初始化的值,不希望它被改变. 当是编译期常量时,有以下几种要求:它必须是作用于基本类型,以final修饰,并且必须赋初值.但是如果一个变量只用final修饰不一定表明它是编译期常量,例如static final int VALUE=rand.nextInt(100);则不是编译期常量. 当final作用于基本类型时,它要求数据本身不能发生改变,当final作用于引用时,它要求引用指向的对象不能改变(即不能指向别的对象),而对象本身可以发生改变. final作用于方法参数&emsp;&emsp;当参数是基本类型时,表示可以读参数,但是不能改变参数的值,这一性质主要用来向匿名内部类传递数据.&emsp;&emsp;但参数是对象的引用时,表明不能改变引用指向的对象.(对象本身可以改变) 空白final域&emsp;&emsp;final域指的是在定义变量时可以是其值可以是空的(null),但是在程序构造器中必须对其赋初值.(不能违背final的基本特性:必须赋值). final作用于方法&emsp;&emsp;final作用于方法表示该方法是最终的方法,不能被继承类修改它的含义.即final方法不能被继承类覆盖.但是可以被重载。&emsp;&emsp;private方法都隐式的指定为final,这是因为private方法不能被继承类读取,也就无法覆盖,对private方法增加final修饰没有任何额外的意义. final作用于类&emsp;&emsp;final作用于类表明该类不能被继承,因为final类不能被继承,所以类中的方法都不能被覆盖,所以final类中的所有方法都隐式的指定为final的.给final类中的方法增加final属性没有任何额外的意义.","categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"}],"tags":[{"name":"Java疑惑解答","slug":"Java疑惑解答","permalink":"https://super-aviator.github.io/tags/Java%E7%96%91%E6%83%91%E8%A7%A3%E7%AD%94/"}],"author":"熊乾坤"},{"title":"归并排序（java实现）","slug":"归并算法（java实现）","date":"2018-04-08T09:02:00.000Z","updated":"2021-02-23T13:00:12.000Z","comments":true,"path":"2018/04/08/归并算法（java实现）/","link":"","permalink":"https://super-aviator.github.io/2018/04/08/%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95%EF%BC%88java%E5%AE%9E%E7%8E%B0%EF%BC%89/","excerpt":"","text":"归并算法的分析 自顶向下的归并排序执行方法(先分再排)&emsp;&emsp;将一个数组排序，可以先将他的左边和右边分别排序，然后将结果归并起来。此算法吸引人的地方是它能够保证将任意长度为N的数组排序所需的时间和NlogN成正比。缺点是需要长度为N的附加空间。 代码实现public class Merge extends Sortable &#123; private static Comparable[] tmp; //驱动程序1 public static void sort(Comparable[] a) &#123; tmp = new Comparable[a.length];//定义临时数组 sort(a, 0, a.length - 1); &#125; //驱动程序2 private static void sort(Comparable[] a, int low, int up) &#123;//将数组的low到up排序 if (low &gt;= up) return; int mid = (up + low) / 2; sort(a, low, mid);//递归的对左半边排序 sort(a, mid + 1, up);//递归的对右半边排序 if (a[mid].compareTo(a[mid + 1]) &gt; 0) merge(a, low, mid, up); //将两半边合并(排除数组已经有序的情况) &#125; //算法核心 private static void merge(Comparable[] a, int lo, int mid, int hi) &#123; int i = lo, j = mid + 1; System.arraycopy(a, lo, tmp, lo, (hi - lo + 1)); //方式1 for (int k = lo; k &lt;= hi; k++) if (i &gt; mid) a[k] = tmp[j++]; else if (j &gt; hi) a[k] = tmp[i++]; else if (tmp[j].compareTo(tmp[i]) == -1) a[k] = tmp[j++]; else a[k] = tmp[i++]; //方式2 int k = lo; while (i &lt;= mid &amp;&amp; j &lt;= hi) if (tmp[j].compareTo(tmp[i]) == -1) a[k++] = tmp[j++]; else a[k++] = tmp[i++]; while (i &lt;= mid) a[k++] = tmp[i++]; while (j &lt;= hi) a[k++] = tmp[j++]; &#125; //测试用例 public static void main(String[] args) &#123; Integer[] a = &#123;2, 31, 4, 1, 34, 6, 2, 1, 5, 74&#125;; sort(a); System.out.println(Arrays.toString(a)); &#125; &#125; 时间复杂度分析&emsp;&emsp;归并排序与基本的排序不一样,归并排序能够处理百万级别的数据,这是基本排序方法所不能做到的,但是他的缺点是排序时需要额外的与N成正比的空间开销. 归并排序对于任意输入的数组,其需要$ 1/2*NlgN $次至$ NlgN $次比较.当N为16时，算法分析如图： 归并排序对于任意输入的数组,其最多需要访问数组6NlgN.(2N次用来赋值元素,2N次用来将排好序的数组移动回去,2N次用来比较时的访问数组.) 一点改进 使用插入排序 &emsp;&emsp;在处理小规模的排序时(例如15时),使用插入排序将更快.(快10%~15%). 这是因为在小规模数组中，插入排序的时间复杂度比归并排序要好。 判断是否有序&emsp;&emsp;如果数组已经有序,那么可以通过判断a[mid]&lt;a [mid+1] (a[mid].comparteTo(a[mid+1])&lt;=0)来跳过执行merge函数，这样当数组有序时就能够以线性时间运行. 避免辅助数组的拷贝&emsp;&emsp;在归并排序时,可以避免数组赋值的时间(空间不行).需要巧妙的交换输入数组和输出数组的角色. //优化代码的代码实现 public class Merge extends Sortable &#123; private static Comparable[] tmp; public static void sort(Comparable[] a) &#123; tmp = new Comparable[a.length];// 定义临时数组 sort(a, 0, a.length - 1); &#125; private static void sort(Comparable[] a, int low, int up) &#123;// 将数组的low到up排序 if (up &lt;= low + 10) &#123; // 如果是小数组(&lt;10),就执行插入排序. Insertion.sort(a, low, up); return; &#125; int mid = (up + low) / 2; sort(a, low, mid);// 递归的对左半边排序 sort(a, mid + 1, up);// 递归的对右半边排序 if (a[mid].compareTo(a[mid + 1]) &lt;= 0) return;//当数组已经有序时，跳过下面的归并。 merge(a, low, mid, up);// 将两半边合并 &#125; //算法核心 private static void merge(Comparable[] a, int lo, int mid, int hi) &#123; int i = lo, j = mid + 1; System.arraycopy(a, lo, tmp, lo, (hi - lo + 1)); //方式1 for (int k = lo; k &lt;= hi; k++) if (i &gt; mid) a[k] = tmp[j++]; else if (j &gt; hi) a[k] = tmp[i++]; else if (tmp[j].compareTo(tmp[i]) == -1) a[k] = tmp[j++]; else a[k] = tmp[i++]; //方式2 int k = lo; while (i &lt;= mid &amp;&amp; j &lt;= hi) if (tmp[j].compareTo(tmp[i]) == -1) a[k++] = tmp[j++]; else a[k++] = tmp[i++]; while (i &lt;= mid) a[k++] = tmp[i++]; while (j &lt;= hi) a[k++] = tmp[j++]; &#125; &#125; 自底向上的排序执行方式&emsp;&emsp;自底向下的归并排序代码量较少,它依次排序1…2…4…8…个数据. 代码实现:public class MergeUP extends Merge &#123; public static void sort(Comparable[] a) &#123; int N = a.length; for (int Increment = 1; Increment &lt; N; Increment += Increment) for (int start = 0; start &lt; N - Increment; start+=Increment*2)) //!注意!start&lt;N-Increment是由start+Increment-1&lt;N-1推导而出 merge(a, start, start + Increment - 1, Math.min(start + 2 * Increment - 1, N - 1)); &#125; &#125; //自底向上的排序方法中，在使用merge方法时,应当在merge方法中加上判断: if (temp == null) temp = new Comparable[a.length];// 定义临时数组 System.arraycopy(a, low, temp, low, length); // 拷贝temp因为temp数组在直接使用merge方法时并没有创建空间. 时间复杂度分析&emsp;&emsp;自底向上的归并排序比较适合链表组织的数据结构，与数组中交换顺序不同，链表只要重新组织链接就能够排序子数组（不需要重新分配结点）。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://super-aviator.github.io/categories/Algorithm/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://super-aviator.github.io/tags/%E6%8E%92%E5%BA%8F/"}],"author":"熊乾坤"},{"title":"初级排序算法(java实现)","slug":"初级排序算法-java实现","date":"2018-04-07T09:16:00.000Z","updated":"2021-02-23T13:00:08.000Z","comments":true,"path":"2018/04/07/初级排序算法-java实现/","link":"","permalink":"https://super-aviator.github.io/2018/04/07/%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-java%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"初级排序算法主要包括选择排序，插入排序，希尔排序，三种算法，其中希尔排序算法是对插入排序算法的改进，初级排序算法的特点是代码量少，但是运行时间比高级排序算法多，性能最好的初级排序算法是希尔排序希尔排序对于大数组也适用，选择排序运行时间最高，而插入排序适用于部分有序或者全部有序的数组。 研究算法的基本框架public class Example&#123; public static void sort(Comparable[] a)&#123; //各种排序算法的实现 &#125; private static boolean less(Comparable a,Comparable b)&#123; return a.compareTo(b)&lt;0; //如果a&lt;b,就返回真 &#125; private static void exch(Comparable[] a,int i,int j)&#123; Comparable temp=a[i];a[i]=a[j];a[j]=temp; //交换数组中第i和第j个数的顺序 &#125; private static void show(Comparable[] a)&#123; for(int i=0;i&lt;a.length;i++) System.out.print(a[i]+&quot; &quot;); System.out.println(); //打印数组内容 &#125; public static boolean isSorted(Comparable[] a)&#123; for(int i=1;i&lt;a.length;i++) if(less(a[i],a[i-1])) return false; return true; //测试数组是否有序。 &#125; public static void main(String[] args)&#123; //测试用例 &#125; &#125; 问题解析：&emsp;&emsp;对于特定情况例如：int[]数组，在编写特定的exch()方法时，如果使用这种方式实现：a[i]+=a[j],a[j]=a[i]-a[j],a[i]=a[i]-a[j],当i和j的下标相同时，会得到一个0的结果，具体的原因只需按步骤一步步执行就能发现问题所在。 排序算法的成本模型（时间消耗点）&emsp;&emsp;对于交换元素的排序算法，排序算法的成本模型是比较和交换的次数，对于不交换元素的排序算法，我们研究的是访问数组的次数。 Comparable接口的含义 Comparable接口实现了主键抽象—它给出了实现该接口的任意数据类型的对象的大小顺序的定义 如果a.comparTo(b)&lt;0说明a&lt;b 如果a.comparTo(b)=0说明a=b 如果a.comparTo(b)&gt;0说明a&gt;b Comparable接口的代码如下: interface Comparable&lt;T&gt;&#123; public int compareTo(T o); &#125; 计算算法的时间(Stopwatch)该类用于计算算法所需的时间 代码实现:public class Stopwatch &#123; private final long start; public Stopwatch() &#123; start=System.currentTimeMillis(); &#125; public double elapsedTimeMillis() &#123; long now=System.currentTimeMillis(); return (now-start)/1000.0; &#125; &#125; 各种基本排序算法介绍几种常用的排序算法: 选择排序(Selection Sort) 执行方式:&emsp;&emsp;每次从右边未排序的数组中选择最小元素,将其插入到左边已排序的数组中的最后位,直到整个数组已经有序. 代码实现:public static void sort(Comparable[] a) &#123; //各种排序算法的实现 int N = a.length; for (int i = 0; i &lt; N - 1; i++) &#123; //该循环控制交换的次数,N个元素交换N-1此 int min = i; for (int j = i + 1; j &lt; N; j++) //该循环用于查找剩下数据中最小的那一个 if (less(a[j], a[min])) min = j; //如果a[j]比a[min]小,就将j赋值给min exch(a, i, min); //交换最小的值和第i个数. &#125; &#125; 时间复杂度分析&emsp;&emsp;代码中exch(交换)方法执行的次数为N次,所以时间复杂度决定为比较的次数.第二个for循环中,比的次数为 $ (N-1)+(N-2)+…+2+1=N(N-1)/2=N^2/2 $ 插入排序(Insertion Sort) 执行方式:在右边未排序的数组中选择第一个,将其插入到左边已经排序的数组中去,必要时需要将左边数组中的部分数据向右移动移一位. 代码实现: public static void sort(Comparable[] a) &#123; //各种排序算法的实现 int N = a.length; for (int i = 1; i &lt; N - 1; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j - 1]); j--) //如果后一个数小于它的前一个数 exch(a, j, j - 1);//就将他们交换. &#125; &#125; 时间复杂度分析: &emsp;&emsp;该算法对于一个有序或者接近有序的数组跑需所需的时间(线性级)远远小于对相同大小的无序数组所需的时间(平方级)；所以该算法通常用来检查数组是否是有序的,当数组中的元素有序或者接近有序时或者主键都相同时,它的时间复杂度比选择排序快很多.&emsp;&emsp;和选择排序一样，最坏情况插入排序需要比较和交换次数为：$ (N-1)+(N-2)+…+2+1=N(N-1)/2=N^2/2 $&emsp;&emsp;插入排序算法平均情况下插入排序需要比较和交换$ N^2/4 $(因为平均每个元素都需要移动和比较一半左边已经排序的元素的数)&emsp;&emsp;最好情况下需要N-1次比较和0次交换.（数据已经有序） 插入排序需要交换的次数为数组中元素倒置的数量相同,比较的次数大于等于倒置数量，小于等于倒置的数量加上数据的大小再减一。 插入排序的改进(improvement)&emsp;&emsp;在常规的插入排序算法中，我们每次遇到一个逆序对，总是将他和后面的数交换，如果我们将内循环中比a[j]小的数直接向后移动，这样可以将访问数组元素的次数减小一半。 代码实现：public static void sort(Comparable[] a) &#123; int N = a.length; for (int i = 1; i &lt; N; i++) &#123; int temp = a[i], j; for (j = i; j &gt; 0 &amp;&amp; temp &lt; a[j - 1]; j--) a[j] = a[j - 1]; a[j] = temp; &#125; &#125; 插入排序和选择排序的比较&emsp;&emsp;对于无重复主键的大量数据，插入排序和选择排序的运行时间都是平方级别的，两者之间应该是一个较小的常数。&emsp;&emsp;对于部分有序或者小规模数组时，插入排序的效率很高，此算法也会在高级排序算法中使用。&emsp;&emsp;对于数组有序或者大量重复主键的数组，插入排序可能比任何算法都要快，这是它独有的特性。而选择排序则是平方级别的。 希尔排序(Shell) 执行方式&emsp;&emsp;希尔排序也是插入排序的另一种优化算法,它克服了插入排序想要移动一个元素到正确的位置所需要的最多N-1次移动的缺点,它为了加快排序速度,交换不相邻的元素以对数组的局部进行排序,并最终用插入排序将局部有序的数组排序. 代码实现:public static void sortShellIncrement(Comparable[] a) &#123;//使用希尔增量(较慢，较简单) int N = a.length; for (int Increment = N / 2; Increment &gt; 0; Increment /= 2)//希尔增量 for (int i = Increment; i &lt; N; i++) &#123; for (int j = i; j &gt;= Increment &amp;&amp; less(a[j], a[j - Increment]); j -= Increment) exch(a, j, j - Increment); &#125; &#125; public static void sortHibbardIncrement(Comparable[] a) &#123;//使用Hibbard增量(更快) int N = a.length; int Increment = 0; while (Increment &lt; N) Increment = Increment * 2 + 1; for (Increment /= 2; Increment &gt; 0; Increment /= 2)//Hibbard增量 for (int i = Increment; i &lt; N; i++) &#123; for (int j = i; j &gt;= Increment &amp;&amp; less(a[j], a[j - Increment]); j -= Increment) exch(a, j, j - Increment); &#125; &#125; public static void sortBookIncrement(Comparable[] a) &#123;//使用书上的增量(最快) int N = a.length; int Increment = 1; while (Increment &lt; N / 3) Increment = Increment * 3 + 1; for (; Increment &gt;= 1; Increment /= 3) for (int i = Increment; i &lt; N; i++) &#123; for (int j = i; j &gt;= Increment &amp;&amp; less(a[j], a[j - Increment]); j -= Increment) exch(a, j, j - Increment); &#125; &#125; ``` 时间复杂度分析:上面的代码采用了三种增量序列(Increment). 第一种为希尔增量(最坏时间复杂度为$ N^2 $):$ 1,2,4,…,N/2 $ 第二种为Hibbard增量(最坏时间复杂度为$ N^(3/2) $):$ 1,3,7,…,2^k-1 $ 第三种为书上给出的增量():$ 1,4,13,…,1/2*(3^k-1) $ 所以希尔排序最好的时间复杂度为$N^{1.3}$，最坏时间复杂度为$N^2$ 希尔排序算法特点&emsp;&emsp;希尔排序的运行时间比选择和插入排序低得多，数组越大对比越明显。&emsp;&emsp;对于中等大小的数组，希尔排序的运行时间是可以接受的，他的代码量少。而且不需要使用额外的内存空间。&emsp;&emsp;对于高级排序算法，它们也只比希尔排序快两倍（可能达不到），并且高级排序算法更加复杂，代码更多。在没有高级算法时，可以先使用希尔排序代替，然后再使用更加优秀的算法。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://super-aviator.github.io/categories/Algorithm/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://super-aviator.github.io/tags/%E6%8E%92%E5%BA%8F/"}],"author":"熊乾坤"},{"title":"Java符号表（SymbolTable）","slug":"Java符号表（SymbolTable）","date":"2018-04-05T04:38:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2018/04/05/Java符号表（SymbolTable）/","link":"","permalink":"https://super-aviator.github.io/2018/04/05/Java%E7%AC%A6%E5%8F%B7%E8%A1%A8%EF%BC%88SymbolTable%EF%BC%89/","excerpt":"","text":"符号表是保存键值对的数据结构，相当于java中的Map 符号表定义代码编写的基本规则 每个键有且仅有一个值 当向符号表中插入值时,如果该值和当前值冲突(相等),则用新的值代替旧的值. 键不能为null,否则抛出运行时异常. 值不能为null,一是因为当使用get时,我们用返回null表明未命中,二是我们将put第二个参数设为null时表示删除该key操作. 删除有两种实现方式，第一种是延时删除，通过将某个键对应的值置为空，然后在某个时刻删除，第二种是即时删除，即立即删除该元素。默认使用第一种方式。 符号表中的键支持迭代，使用keys()方法返回Iterable接口实现。 键的等值性是使用equals()方法实现的，对于自定义类型，需要重写equals()方法。 符号表实现链表实现符号表(键无序,顺序查找)代码实现: import java.util.Iterator; public class SequentialSearchST&lt;Key, Value&gt; implements Iterable&lt;Key&gt; &#123; private Node first; private int N; private class Node &#123; Key key; Value value; Node next; public Node(Key key, Value value, Node next) &#123; this.key = key; this.value = value; this.next = next; &#125; &#125; public Value get(Key key) &#123; for (Node x = first; x != null; x = x.next) if (key.equals(x.key)) return x.value; return null; &#125; public void put(Key key, Value value) &#123; if(value==null) &#123;//如果第二个参数为null,就删除此key对应的键. delete(key); return; &#125; for (Node x = first; x != null; x = x.next) if (key.equals(x.key)) &#123; x.value = value; return; &#125; first = new Node(key, value, first); N++; &#125; public void delete(Key key) &#123; for (Node x = first, y = null; x != null; y = x, x = x.next) if (key.equals(x.key)) &#123; y.next = x.next; x = null; N--; return; &#125; &#125; public boolean isEmpty() &#123; return N == 0; &#125; public Iterable&lt;Key&gt; keys() &#123; return new Iterable&lt;Key&gt;() &#123; @Override public Iterator&lt;Key&gt; iterator() &#123; // TODO Auto-generated method stub return new Iterator&lt;Key&gt;() &#123; Node current = first; @Override public boolean hasNext() &#123; // TODO Auto-generated method stub return current != null; &#125; @Override public Key next() &#123; // TODO Auto-generated method stub Key result = current.key; current = current.next; return result; &#125; &#125;; &#125; &#125;; &#125; public int size() &#123; return N; &#125; @Override public Iterator&lt;Key&gt; iterator() &#123; // TODO Auto-generated method stub return new Iterator&lt;Key&gt;() &#123; Node current = first; @Override public boolean hasNext() &#123; // TODO Auto-generated method stub return current != null; &#125; @Override public Key next() &#123; // TODO Auto-generated method stub Key result = current.key; current = current.next; return result; &#125; &#125;; &#125; &#125; 时间复杂度分析&emsp;&emsp;在符号表中的查找成果为命中,查找不成功为未命中,那么在链表中命中和未命中都需要N次比较,命中最坏情况为比较N次,向一个空表中插入N个不同的键值需要比较次数为:$N^2/2$ 基于数组的符号表(键有序,二分查找)代码实现 package Demo; import java.util.*; public class BinarySearchST&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123; private Key[] keys; private Value[] values; private int N; @SuppressWarnings(&quot;unchecked&quot;) public BinarySearchST(int size) &#123; keys=(Key[])new Object[size]; values=(Value[])new Object[size]; &#125; public BinarySearchST() &#123; keys=(Key[])new Comparable[30]; values=(Value[])new Object[30]; &#125; public int capacity() &#123; return keys.length; &#125; public int size() &#123; return N; &#125; public int rank(Key key) &#123; /* * 此方法返回数组中小于key的元素的个数. * 当key小于数组中的所有元素时,返回0(未命中) * 当key大于数组中的所有元素时,返回N(未命中) * 当key小于数组中的某个数时,返回这个数的索引(未命中) * 命中时,返回key的索引 */ int lo=0,hi=N-1; while(lo&lt;=hi) &#123; int mid=(lo+hi)/2; int cmp=keys[mid].compareTo(key); if(cmp&lt;0) lo=mid+1; else if(cmp&gt;0) hi=mid-1; else return mid; &#125; return lo; &#125; public void put(Key key,Value value) &#123; /* * 如果valuew为null,则删除对应的key. * 如果数组中有key,则将其value更新. * 如果没有,就插入到数组中. */ if(value==null) &#123; delete(key); return; &#125; int position=rank(key); if(position&lt;N&amp;&amp;keys[position].compareTo(key)==0)&#123; //判断position&lt;N的目的时防止position=N,则后面的语句会抛出空指正异常. values[position]=value; return; &#125; for(int j=N;j&gt;position;j--) &#123; keys[j]=keys[j-1]; values[j]=values[j-1]; &#125; keys[position]=key; values[position]=value; N++; &#125; public Value get(Key key) &#123; int position=rank(key); if(position&lt;N&amp;&amp;keys[position].compareTo(key)==0) return values[position]; else return null; &#125; public void delete(Key key) &#123; int position=rank(key); if(position&lt;N&amp;&amp;keys[position].compareTo(key)==0) &#123; for(int j=position+1;j&lt;N;j++) &#123; keys[j-1]=keys[j]; values[j-1]=values[j]; &#125; N--; &#125; &#125; public void deleteAll() &#123; for(int i=0;i&lt;N;i++) &#123; keys[i]=null; values[i]=null; &#125; N=0; &#125; public List&lt;Key&gt; keys() &#123; List&lt;Key&gt; list=new ArrayList&lt;Key&gt;(); for(int i=0;i&lt;N;i++) list.add(keys[i]); return list; &#125; public Key min() &#123; return keys[0]; &#125; public Key max() &#123; return keys[N-1]; &#125; public Key select(int index) &#123; return keys[index]; &#125; public Key ceiling(Key key) &#123; return keys[rank(key)]; &#125; public Key floor(Key key) &#123; int i=rank(key); return i&gt;=0&amp;&amp;i&lt;=N?keys[i-1]:keys[i]; &#125; &#125; 算法分析 N个键的二分查找需要lgN+1次比较 N个键的有序数组中插入一个元素最坏情况下需要访问2N次数组,像一个空符号表中插入N个元素在最坏情况下需要访问次数为:$N^2$","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://super-aviator.github.io/categories/Algorithm/"}],"tags":[{"name":"Java数据结构","slug":"Java数据结构","permalink":"https://super-aviator.github.io/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"熊乾坤"},{"title":"Linux中常见的配置文件","slug":"Linux中常见的配置文件","date":"2018-04-04T10:19:00.000Z","updated":"2021-02-23T13:00:04.000Z","comments":true,"path":"2018/04/04/Linux中常见的配置文件/","link":"","permalink":"https://super-aviator.github.io/2018/04/04/Linux%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"","text":"用户相关配置文件 用户信息文件/etc/passwd 密码信息文件/etc/shadow 网络相关配置文件 网卡配置文件/etc/sysconfig/network-scripts/ifcfg-eth n DNS配置文件/etc/resolv.conf 主机名配置文件/etc/sysconfig/network 静态主机名配置文件/etc/hosts 系统相关 开机挂载配置文件/etc/fstab /boot/grub/menu.lst /etc/inittab","categories":[{"name":"OperationSystem","slug":"OperationSystem","permalink":"https://super-aviator.github.io/categories/OperationSystem/"}],"tags":[{"name":"Linux配置文件","slug":"Linux配置文件","permalink":"https://super-aviator.github.io/tags/Linux%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"}],"author":"熊乾坤"},{"title":"Linux中的基础命令","slug":"Linux中的常用命令","date":"2018-04-04T08:39:00.000Z","updated":"2021-02-23T13:00:00.000Z","comments":true,"path":"2018/04/04/Linux中的常用命令/","link":"","permalink":"https://super-aviator.github.io/2018/04/04/Linux%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"linux使用中一些常用的命令 文件管理命令cd [相对路径或绝对路径] 命令行说明:切换到指定目录下 参数说明:想要切换的目录的相对或绝对路径 pwd 命令行说明:显示用户当前工作目录。 mkdir [-p] [目录名称及路径] 命令行说明:创建一个目录。 选项说明: p: 当父目录不存在时，连通父目录一起建立。 参数说明:想要创建的目录的名称 rmdir [-p] [目录名称及路径] 命令行说明:删除一个空的目录。使用-p选项，可以递归的删除空目录，例如：rmdir test1/test 将删除test目录，如果删除test后test1目录为空，则将test1也一并删除。如果删除的文件夹非空，则不能删除。 选项说明: p: 删除子目录时，若父目录为空则一并删除。 参数说明:目录及其路径 ls [-adhlnSt] 目录名称 命令行说明:查看指定文件下的文件或目录。 选项说明: a: 显示全部的文件，连通隐藏的文件。（以.开头的文件） d: 仅列出目录本身，而不列出目录内的文件数据。 h: 将文件容量以较易读的方式（GB,KB）显示出来。 l: 等同于(ll),显示文件的属性以及权限。 n: 列出UID和GID而非使用者与数组的名称。 S: 以文件容量大小排序，而不是文件名派速。 t：依时间排序而不是文件名。 参数说明:指定文件夹 cp [-iru] 源文件 目标文件 命令行说明:拷贝文件或目录。当时用-u选项时，如果源文件与目标文件相同（没有修改过），就不进行复制，否则复制。复制目录时，需要加上-r选项。 选项说明: i: 若目标文件已经存在，在覆盖时会先询问。 r: 可以进行目录的复制。如果需要拷贝一个文件夹，则需要加上此参数 u: 若源文件较新，或者没有目标文件时，才会进行复制，可用备份操作。 v: 显示复制的细节。 参数说明:源文件。目标文件。 rm [-fir] 文件或目录 命令行说明:移除文件或文件夹，当不使用选项时，默认为-i选项，即会询问你是否删除。当使用此命令删除文件夹时，需要使用功能-r或者-i选项，当删除文件时，需要使用-i或者-f选项。 选项说明: f: force,强制删除文件。 i: 互动模式，在删除前会进行询问是否删除。 r: 递归删除文件夹，删除目录下所有文件夹，非常危险。 参数说明:想要删除的文件或者文件夹。 mv [-fiu] 源文件 目标文件 命令行说明:移动文件或者文件夹，或者重命名文件。使用.代表当前目录可以更好的实现重命名效果。 选项说明: f: force强制的意思，如果文件已经存在，则强制覆盖该文件。 i: 若目标文件已经存在，就会询问是否覆盖。 u: 若文件已经存在，且源文件时目标文件的修改过的，才会覆盖。 参数说明: tar [主选项+副选项] 文件或目录 命令行说明:为文件和目录创建归档。下面是几种常用的使用方法：1：将 选项说明:主选项：（必须存在）-c: 创建新的备份文件，如果用户想要备份一个目录或者是一些文件，就要选择此选项。-r: 要把归档文件追加到文件末尾。-u: 更新文件，使用新增的文件取代原备份文件，如果在备份文件中找不到要更新的文件，则把他追加到备份文件的最后。-x: 从备份归档中释放文件。 副选项：（选用）-f: 使用备份归档或设备，这个选项通常是必选。-m: 在还原文件时，将所有文件修改为现在。-v: 详细报告tar处理的文件信息，若无此选项tar不报告文件信息。-z: 用gzip来压缩/解压缩文件，加上此选项后可将备份档文件进行压缩，还原时也一定要使用该选项进行解压缩。-j: 使使用zb2来压缩/解压缩文件，加上此选项后可将备份档文件进行压缩，还原时也一定要使用该选项进行解压缩。 参数说明:想要压缩的文件路径。 用户管理命令超级用户的切换su [-lcm] [username] 命令行说明:su命令是切换用户的工具，可以从当前用户切换到指定用户。当使用超级用户向普通或者伪用户切换时不需要用户的密码，而普通用户切换到其他任何用户都需要输入想要切换的指定用户的密码。 选项说明: l: 切换用户时使用想要切换的用户的所有相关环境设定配置。改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,logname。此外，也会变更PATH变量。 c: 同–command,仅进行一次root指令，后面可以加上想要执行的命令。 : 当不带选项或者选项为-时，为切换到root用户。 参数说明:想要切换到的用户名。 sudo [-u [username]|#uid] command 命令行说明:更加安全的su命令，使用此命令切换到指定用户时，不会像su一样需要输入root密码，而只需要root用户配置好/etc/sudoers文件即可，普通用户如果在该文件中有权限，只需输入当前用户的密码就可以执行root操作。root用户执行sudo时不需要输入密码。如果欲切换用户与执行者身份相同，也不需要输入密码。 选项说明: u: 使用sudo -u #500来切换到UID为500的用户。例如：sudo -u account touch /hime/test。使用sudo切换到account进行touch操作。 l: 列出用户在主机上可用的和被禁止的命令，一半般用于测试/etc/shdoers是否配置正确。 参数说明:想要执行的指令 sudo passwd 命令行说明:当使用ubuntu时，第一次使用默认没有开启root权限，所以要使用此命令激活root用户并设置密码。 选项说明: 参数说明: 用户账号管理useradd [-u UID] [-g initial_group] [-G other_group] [-Mm] [-c说明栏] [-d home] [-s Shell] username 命令行说明:添加一个用户。（root可用）值得注意的是，如果创建一个用户，没有使用-m或者没有使用-d选项建立用户家目录，那么使用GUI是无法登录该用户的。（不要问我为什么，血的教训。） 选项说明: u: 指定用户的UID g: 初始群组名称 G: 后面跟的群组名则是这个账号还可以支持的群组，这个参数会修改/etc/group的内容 M: 强制不要建立用户家目录 m: 强制建立家目录 c: 用户信息说明栏 d: 指定某个目录为家目录 r: 建立一个系统的账号,这个账号的UID会有限制.（1~499） s: 指定的shell名称，默认为/bin/shell 参数说明:指定该用户的用户名 usermod [-cdegGlsuLU] username 命令行说明:当创建用户时如果发现遗漏或者设置错误了某个选项，可以使用此命令进行微调。（root可用） 选项说明: c：后面跟用户的说明，即/etcpasswd中的第5栏。 d: 后面跟账号的家目录，即修改/etc/passwd第6栏 。 e: 后面跟日期，格式是YYYY-MM-DD ，设置用户的实效日期。 g: 后面跟群组名，修改用户的群组。 G: 后面跟群组名，指这个用户能够支持的群组名。 l: 后面跟用户名，修改用户的用户名。 s: 后面跟shell的实际文件，如;/bin/bash等。 u: 修改用户的UID. L: 暂时将用户冻结。实际是想shadow中的密码栏加上一个！ U: 将用户解冻。 参数说明:想要修改的用户名。 userdel [-r] username 命令行说明:删除系统中的用户。（root可用） 选项说明: r: 删除时连通用户家目录一起删除。 参数说明:想要删除的用户名。 passwd [username] 命令行说明:此命令用于修改用户的密码，如果不加参数，则为修改当前用户的密码，此命令有两种用法，第一种是如果当前用户是root，root可以修改任何用户的密码而不需要待修改用户的密码。而且此种方法设定的密码即使太简单，也能够设定，第二种如果当前用户是普通用户，直接使用passwd就可以修改当前用户的密码了，而此时密码不能够太简单。密码设定有三个原则：1：密码不能与账号相同，2：密码不要选用字典里面会出现的字符串3：密码需要超过8个字符 选项说明: S：查看用户的密码状态 d：删除用户的密码，设置用户的密码为空密码 l：locked,将用户的密码状态设置为锁定状态 u：unlock，将密码锁定状态的用户解除锁定 n：设置用户密码的最短使用期限，默认值为0天 x：设置用户密码的最长使用期限，默认值为99999天 w：设置用户的密码在到达最大使用期限之前多少天开始发出警告，默认7天 i：设置用户的密码在到达最大使用期限之后，还可以继续使用多少天，默认无穷大默认功能不开启，即无限期 参数说明:想要修改的用户名。 系统管理命令 shoutdown [-] 模板命令名 [-选项] [参数] 命令行说明: 选项说明: 参数说明:","categories":[{"name":"OperationSystem","slug":"OperationSystem","permalink":"https://super-aviator.github.io/categories/OperationSystem/"}],"tags":[{"name":"Linux常用命令","slug":"Linux常用命令","permalink":"https://super-aviator.github.io/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}],"author":"熊乾坤"},{"title":"这是我的第一篇博客","slug":"World","date":"2018-04-02T09:41:00.000Z","updated":"2021-02-23T13:00:06.000Z","comments":true,"path":"2018/04/02/World/","link":"","permalink":"https://super-aviator.github.io/2018/04/02/World/","excerpt":"我是梦想成为大牛的三本在校大学生(洗洗睡吧，梦里什么都有）&nbsp; o -_-)---○)°O°)","text":"我是梦想成为大牛的三本在校大学生(洗洗睡吧，梦里什么都有）&nbsp; o -_-)---○)°O°) # include&lt;stdio.h&gt; int main(void)&#123; print(&quot;Hello World!&quot;); return 0; &#125; public class Demo&#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello World!&quot;); &#125; &#125;","categories":[],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"https://super-aviator.github.io/tags/Hello-World/"}],"author":"熊乾坤"}],"categories":[{"name":"Java","slug":"Java","permalink":"https://super-aviator.github.io/categories/Java/"},{"name":"Middleware","slug":"Middleware","permalink":"https://super-aviator.github.io/categories/Middleware/"},{"name":"OperationSystem","slug":"OperationSystem","permalink":"https://super-aviator.github.io/categories/OperationSystem/"},{"name":"MicroService","slug":"MicroService","permalink":"https://super-aviator.github.io/categories/MicroService/"},{"name":"Other","slug":"Other","permalink":"https://super-aviator.github.io/categories/Other/"},{"name":"Daily","slug":"Daily","permalink":"https://super-aviator.github.io/categories/Daily/"},{"name":"Database","slug":"Database","permalink":"https://super-aviator.github.io/categories/Database/"},{"name":"Redis","slug":"Redis","permalink":"https://super-aviator.github.io/categories/Redis/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://super-aviator.github.io/categories/Elasticsearch/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://super-aviator.github.io/categories/SourceCode/"},{"name":"Spring","slug":"Spring","permalink":"https://super-aviator.github.io/categories/Spring/"},{"name":"Career","slug":"Career","permalink":"https://super-aviator.github.io/categories/Career/"},{"name":"NetWork","slug":"NetWork","permalink":"https://super-aviator.github.io/categories/NetWork/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://super-aviator.github.io/categories/Algorithm/"},{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://super-aviator.github.io/categories/DesignPattern/"},{"name":"Git","slug":"Git","permalink":"https://super-aviator.github.io/categories/Git/"},{"name":"DataStructure","slug":"DataStructure","permalink":"https://super-aviator.github.io/categories/DataStructure/"}],"tags":[{"name":"Java疑惑解答","slug":"Java疑惑解答","permalink":"https://super-aviator.github.io/tags/Java%E7%96%91%E6%83%91%E8%A7%A3%E7%AD%94/"},{"name":"Kafka","slug":"Kafka","permalink":"https://super-aviator.github.io/tags/Kafka/"},{"name":"Windows","slug":"Windows","permalink":"https://super-aviator.github.io/tags/Windows/"},{"name":"Linux","slug":"Linux","permalink":"https://super-aviator.github.io/tags/Linux/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://super-aviator.github.io/tags/SpringCloud/"},{"name":"Ribbon","slug":"Ribbon","permalink":"https://super-aviator.github.io/tags/Ribbon/"},{"name":"OpenFeign","slug":"OpenFeign","permalink":"https://super-aviator.github.io/tags/OpenFeign/"},{"name":"Hystrix","slug":"Hystrix","permalink":"https://super-aviator.github.io/tags/Hystrix/"},{"name":"Docker","slug":"Docker","permalink":"https://super-aviator.github.io/tags/Docker/"},{"name":"并发","slug":"并发","permalink":"https://super-aviator.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"MySQL","slug":"MySQL","permalink":"https://super-aviator.github.io/tags/MySQL/"},{"name":"生活","slug":"生活","permalink":"https://super-aviator.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"Redis","slug":"Redis","permalink":"https://super-aviator.github.io/tags/Redis/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://super-aviator.github.io/tags/Elasticsearch/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://super-aviator.github.io/tags/WebSocket/"},{"name":"Proxy","slug":"Proxy","permalink":"https://super-aviator.github.io/tags/Proxy/"},{"name":"Spring Data Jpa","slug":"Spring-Data-Jpa","permalink":"https://super-aviator.github.io/tags/Spring-Data-Jpa/"},{"name":"编码技巧","slug":"编码技巧","permalink":"https://super-aviator.github.io/tags/%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/"},{"name":"Spring","slug":"Spring","permalink":"https://super-aviator.github.io/tags/Spring/"},{"name":"Logback","slug":"Logback","permalink":"https://super-aviator.github.io/tags/Logback/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"https://super-aviator.github.io/tags/Spring-Data-JPA/"},{"name":"Java Web","slug":"Java-Web","permalink":"https://super-aviator.github.io/tags/Java-Web/"},{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://super-aviator.github.io/tags/Hexo%E5%8D%9A%E5%AE%A2/"},{"name":"NoSQL","slug":"NoSQL","permalink":"https://super-aviator.github.io/tags/NoSQL/"},{"name":"Lombok","slug":"Lombok","permalink":"https://super-aviator.github.io/tags/Lombok/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://super-aviator.github.io/tags/SpringBoot/"},{"name":"Maven","slug":"Maven","permalink":"https://super-aviator.github.io/tags/Maven/"},{"name":"工作总结","slug":"工作总结","permalink":"https://super-aviator.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"},{"name":"JUnit","slug":"JUnit","permalink":"https://super-aviator.github.io/tags/JUnit/"},{"name":"Linux常用命令","slug":"Linux常用命令","permalink":"https://super-aviator.github.io/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"name":"数据库优化","slug":"数据库优化","permalink":"https://super-aviator.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"},{"name":"HTTP","slug":"HTTP","permalink":"https://super-aviator.github.io/tags/HTTP/"},{"name":"面试","slug":"面试","permalink":"https://super-aviator.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"设计模式","slug":"设计模式","permalink":"https://super-aviator.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Servlet","slug":"Servlet","permalink":"https://super-aviator.github.io/tags/Servlet/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://super-aviator.github.io/tags/TCP-IP/"},{"name":"锁","slug":"锁","permalink":"https://super-aviator.github.io/tags/%E9%94%81/"},{"name":"Java NIO","slug":"Java-NIO","permalink":"https://super-aviator.github.io/tags/Java-NIO/"},{"name":"算法疑惑解答","slug":"算法疑惑解答","permalink":"https://super-aviator.github.io/tags/%E7%AE%97%E6%B3%95%E7%96%91%E6%83%91%E8%A7%A3%E7%AD%94/"},{"name":"深入理解计算机系统","slug":"深入理解计算机系统","permalink":"https://super-aviator.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"Git常用命令","slug":"Git常用命令","permalink":"https://super-aviator.github.io/tags/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"name":"符号表","slug":"符号表","permalink":"https://super-aviator.github.io/tags/%E7%AC%A6%E5%8F%B7%E8%A1%A8/"},{"name":"HTTP权威指南","slug":"HTTP权威指南","permalink":"https://super-aviator.github.io/tags/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"},{"name":"排序","slug":"排序","permalink":"https://super-aviator.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"Java数据结构","slug":"Java数据结构","permalink":"https://super-aviator.github.io/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Linux配置文件","slug":"Linux配置文件","permalink":"https://super-aviator.github.io/tags/Linux%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"name":"Hello World","slug":"Hello-World","permalink":"https://super-aviator.github.io/tags/Hello-World/"}]}