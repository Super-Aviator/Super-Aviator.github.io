<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"super-aviator.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":10,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="熊乾坤的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="孤独飞行员">
<meta property="og:url" content="https://super-aviator.github.io/page/5/index.html">
<meta property="og:site_name" content="孤独飞行员">
<meta property="og:description" content="熊乾坤的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="熊乾坤">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://super-aviator.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>孤独飞行员</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">孤独飞行员</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/06/22/Spring-Data-JPA%E4%B8%AD%E7%9A%84%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%8C%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/22/Spring-Data-JPA%E4%B8%AD%E7%9A%84%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%8C%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2/" class="post-title-link" itemprop="url">Spring Data JPA中的一对一，一对多，多对多查询</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-22 19:10:00" itemprop="dateCreated datePublished" datetime="2019-06-22T19:10:00+08:00">2019-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 20:59:58" itemprop="dateModified" datetime="2021-02-23T20:59:58+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/06/22/Spring-Data-JPA%E4%B8%AD%E7%9A%84%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%8C%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/06/22/Spring-Data-JPA%E4%B8%AD%E7%9A%84%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%8C%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这几天学习一下Spring Data JPA中的一对一、一对多、多对多映射。这些映射还分单向关联和双向关联，在双向关联时还需要考虑对象序列化为JSON字符串时的死循环问题。</p>
<h1 id="单向关联和双向关联"><a href="#单向关联和双向关联" class="headerlink" title="单向关联和双向关联"></a>单向关联和双向关联</h1><ul>
<li><p><strong>单向关联</strong>  单向关联指的是实体类A中有一个实体类B变量，但是实体类B中没有实体类A变量，即为单向关联。</p>
</li>
<li><p><strong>双向关联</strong>  双向关联指的是实体类A中有一个实体类B变量，而实体类B中也含有一个实体类A变量，即为双向关联。</p>
</li>
</ul>
<p><strong>值得注意的是：Spring Data JPA中属性的集合需要使用Set来保存，如果使用List会抛出异常。</strong></p>
<h1 id="双向关联中序列化的死循环问题"><a href="#双向关联中序列化的死循环问题" class="headerlink" title="双向关联中序列化的死循环问题"></a>双向关联中序列化的死循环问题</h1><p>在双向关联时，可能会存在对象序列化成JSON字符创时的死循环问题，因为A中包含B，B中也包含A，序列化A中的B时，因为B也含有A，A又含有B，所以会死循环。</p>
<blockquote>
</blockquote>
<p>特南克斯<br>首先你要理解这是双向关联，双向关联中你如果从数据库里面查询一个User对象，那么User对象里面有Role，Role里面又有User对象，那么你用syso输出User对象，如果toString方法里面包含有输出User.roles的话，那么是必然会造成死循环的。如果你用sping mvc等框架将后台数据返回给前台也是同理，也会造成返回的JSON数据死循环</p>
<p>使用Jackson时，可以使用@JsonIgnoreProperties注解来解决：</p>
<pre><code class="java"> @JsonIgnoreProperties(value = &#123; &quot;users&quot; &#125;)
    @ManyToMany(cascade = CascadeType.ALL,fetch = FetchType.LAZY)
    @JoinTable(
            name = &quot;TEACHER_USER_RELATION&quot;,
            joinColumns = 
            @JoinColumn(name = &quot;UserId&quot;,referencedColumnName = &quot;id&quot;),
            inverseJoinColumns = 
            @JoinColumn(name = &quot;TeacherId&quot;,referencedColumnName = &quot;id&quot;)
    )
    private Set&lt;Teacher&gt; teachers;
</code></pre>
<p>@JsonIgnoreProperties(value = { “users” })注解排除了Teacher中的User字段，从而避免了死循环问题。</p>
<h1 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h1><p>一对一映射需要@OneToOne注解和@JoinColumn注解配合使用，为了创建测试数据，首先定义一个User实体类，然后定义一个UserDetail实体类，其中User与UserDetail的关系是一对一的关系，即一个User对应一个UserDetail，一个UserDetail对应一个User。具体代码如下：</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;USER&quot;)
public class User &#123;

        ...

    /**
     * 一对一
     */
    @JoinColumn(name = &quot;id&quot;,referencedColumnName = &quot;id&quot;)
    @OneToOne(cascade = &#123;CascadeType.ALL&#125;,fetch = FetchType.LAZY)    
    private UserDetail userDetail;
&#125;
</code></pre>
<p>在被关联的UserDetail代码如下：</p>
<pre><code class="java">@Entity
@Data
@Table(name = &quot;USER_DETAIL&quot;)
public class UserDetail &#123;
    @Id
    @GeneratedValue
    @Column(name = &quot;ID&quot;)
    private Long id;

    @Column(name = &quot;CREDIT&quot;)
    private Float credit;

    @Column(name = &quot;ENROLLMENT_DATE&quot;)
    private Date enrollmentDate;

    @Column(name = &quot;USER_ID&quot;)
    private Long userId;
&#125;
</code></pre>
<p>UserDetail中没有User类型成员变量，所以User与UserDetail的关联是单向关联，如果UserDetail中也含有一个User类型的变量，则为双向关联；（单向和双向关联只与是否包含对象有关，和是否使用注解无关。）</p>
<p>同时需要在User类型的变量名中增加@OneToOne(mappedBy=”userDetail”)注解，表示两者的关系由User实体去维护，如果配置了Cascade，对User的操作也会影响到UserDetail实体。</p>
<p>上面代码中的@OneToOne注解中，可以定义级联操作，包括级联新建、级联删除、级联更新、级联刷新。</p>
<p><strong>@JoinColumn注解中的name元素为被关联对象的id，即UserDetail类的id，而referencedColumnName则为关联对象的id,即@JoinColumn所在实体类的id。</strong></p>
<h1 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h1><p>一对多需要使用@JoinColumn注解和@OneToMany配置使用，如果是双向关联，则还需要在被关联的实体类的成员变量中使用@ManyToOne。</p>
<p>为了创建测试环境，需要新建一个UserFriend实体类，一个User可以有一个或多个UserFriend。</p>
<p>User实体类中需要包含一个集合类型的UserFriend成员变量：</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;USER&quot;)
public class User &#123;
    
    ...
    
     /**
     * 一对多
     */
    @OneToMany(cascade = &#123;CascadeType.ALL&#125;,fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;userId&quot;,referencedColumnName = &quot;id&quot;)
    private Set&lt;UserFriend&gt; userFriends;
&#125;
</code></pre>
<p>@OneToMany注解和@JoinColumn注解需要配合使用，@OneToMany注解中同样可以指定级联操作和加载类型。</p>
<p><strong>@JoinColumn注解中，name元素为被被关联实体类中的id，而referencedColumnName元素为关联实体类中的id,即@JoinColumn所在实体类的id。</strong></p>
<p>UserFriend实体类代码如下：</p>
<pre><code class="java">@Entity
@Data
@Table(name = &quot;USER_FRIEND&quot;)
public class UserFriend &#123;
    @Id
    @GeneratedValue
    @Column(name = &quot;ID&quot;)
    private Long id;

    private Long userId;

    @Column(name = &quot;FRIEND_ID&quot;)
    private Long friendId;
&#125;
</code></pre>
<p>由于使用的是单向关联，UserFriend实体类没有对应的User成员变量，所以是单向关联，如果需要指定关系的维护方，需要在使用没有@JoinColumn的实体类上使用注解@OneToMany(mappedBy)。</p>
<h1 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h1><p>多对多和一对一、一对多不同，需要引入两者之间的关系表，关系表负责维护两者之间的关系，起到至关重要的作用，Spring Data JPA中，需要使用@ManyToMany注解和@JoinTable注解配合使用。</p>
<p>为了创建多对多的测试环境，需要创建一个Teacher实体类：</p>
<pre><code class="java">@Entity
@Data
@Table(name = &quot;TEACHER&quot;)
public class Teacher &#123;

    @Id
    @GeneratedValue
    @Column(name = &quot;ID&quot;)
    private Long id;

    @Column(name = &quot;NAME&quot;)
    private String name;

    @ManyToMany(mappedBy = &quot;teachers&quot;)
    private List&lt;User&gt; users;
&#125;
</code></pre>
<p>Teacher中，由于也包含User的集合，所以Teacher与User是双向关联，在Teacher中使用@ManyToMany(mappedBy)注解申明User类为双方关系的维护方，即删除User也会删除关联的Teacher和关系表中的数据，但删除Teacher不会删除User表中的数据。</p>
<p>User类中，需要加入@JoinTable和@ManyToMany注解：</p>
<pre><code class="java">public class User&#123;
    ...

    /**
     * 多对多
     */
    @JsonIgnoreProperties(value = &#123; &quot;users&quot; &#125;)
    @ManyToMany(cascade = CascadeType.ALL,fetch = FetchType.LAZY)
    @JoinTable(
            name = &quot;TEACHER_USER_RELATION&quot;,
            joinColumns = 
            @JoinColumn(name = &quot;UserId&quot;,referencedColumnName = &quot;id&quot;),
            inverseJoinColumns = 
            @JoinColumn(name = &quot;TeacherId&quot;,referencedColumnName = &quot;id&quot;)
    )
    private Set&lt;Teacher&gt; teachers;
&#125;
</code></pre>
<p><strong>@JoinTable中的name需要填写中间关系表的表明</strong></p>
<p>joinColumns中的name和inverseJoinColumns中的name需要填关系表TEACHER_USER_RELATION的实体的字段名<br>如果关系表TEACHER_USER_RELATION的实体中的字段使用了@Column(name)，那么需要填写注解中指定的名字，即表字段名。<br>referencedColumnName填写的是本实体类中的关联的字段。</p>
<h1 id="使用-OrderBy进行排序"><a href="#使用-OrderBy进行排序" class="headerlink" title="使用@OrderBy进行排序"></a>使用@OrderBy进行排序</h1><p>在一对多或者多对多映射中，如果想要对得到的集合进行排序，可以使用@OrderBy注解，@OrderBy中只需要指定想要排序的字段以及排序的方向即可：</p>
<pre><code class="java">    /**
     * 一对多
     */
    @OneToMany(cascade = &#123;CascadeType.ALL&#125;,fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;userId&quot;,referencedColumnName = &quot;id&quot;)
    @OrderBy(&quot;friend_id DESC&quot;)
    private Set&lt;UserFriend&gt; userFriends;
</code></pre>
<p>上面的代码中，Set中的UserFriend会使用Friend进行倒序排序。</p>
<p>值得注意的是，即使用Set集合也可以保证有序性，在Hibernate内部使用了自定义集合PersistentSet，此集合是有序集合。</p>
<h1 id="mappedBy元素说明"><a href="#mappedBy元素说明" class="headerlink" title="mappedBy元素说明"></a>mappedBy元素说明</h1><p>@OneToOne、@OneToMany、@ManyToMany中可以使用mappedBy元素定义被关联着和关联着的关系由谁去维护，即关系的操纵权在那一方，同时<strong>mappedBy不能和@JoinTable、@JoinColumn注解同时存使用</strong>。</p>
<h1 id="使用-EntityGraph和-NamedEntityGraph解决N-1问题"><a href="#使用-EntityGraph和-NamedEntityGraph解决N-1问题" class="headerlink" title="使用@EntityGraph和@NamedEntityGraph解决N+1问题"></a>使用@EntityGraph和@NamedEntityGraph解决N+1问题</h1><p>在常规的多对多和一对多查询时，会面临N+1问题：<br>N+1问题指的是，如果一个User对应N个Friend，在查询某id的User时，会首先执行一条SQL语句查询该User，然后会执行N条SQL语句查询该User对应的N个Friend,过程中一共使用了N+1条语句，效率会非常低下，正确的做法是使用内连接和外链接，只需要一条语句。</p>
<p>Spring Data JPA中针对N+1问题有相应的优化，使用@EntityGraph和@NamedEntityGraph就可以解决N+1问题。</p>
<p>首先需要在User实体类上使用@NamedEntityGraph注解：</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;USER&quot;)
@NamedEntityGraph(
        name = &quot;UserEntity&quot;,
        attributeNodes = &#123;
                @NamedAttributeNode(&quot;userDetail&quot;),
                @NamedAttributeNode(&quot;userFriends&quot;),
                @NamedAttributeNode(&quot;teachers&quot;),
        &#125;
)
public class User &#123;
...
&#125;
</code></pre>
<p>上面代码中，name可以随便定义，在@EntityGraph中会对其进行引用，@NamedAttributeNode中的value元素即为需要解决N+1问题的字段。</p>
<p>在Repository中，对需要解决N+1问题的方法上使用的@EntityGraph注解就可以了：</p>
<pre><code class="java">public interface UserJpaRepository&lt;T&gt; extends JpaRepository&lt;User,Long&gt; &#123;
   @EntityGraph(&quot;UserEntity&quot;)
   List&lt;User&gt; findByNameContaining(String name);
&#125;
</code></pre>
<p>注解中的value是@NamedEntityGraph定义的name。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/06/20/Spring-Data-JPA%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/20/Spring-Data-JPA%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Spring Data JPA进阶学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-20 12:14:00" itemprop="dateCreated datePublished" datetime="2019-06-20T12:14:00+08:00">2019-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-10 13:21:30" itemprop="dateModified" datetime="2021-03-10T13:21:30+08:00">2021-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/06/20/Spring-Data-JPA%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/06/20/Spring-Data-JPA%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这几天静下心来深入学习一下Spring Data Jpa的深入知识，参考书籍为《Spring Data JPA从入门到精通》，感觉作者写的很乱，不过收获应该还是很多的。</p>
<h1 id="Repository中方法的关键字"><a href="#Repository中方法的关键字" class="headerlink" title="Repository中方法的关键字"></a>Repository中方法的关键字</h1><p>Repository中的方法有很多关键字可以使用，在阅读书的时候发现了很多以前没有使用到并且没有注意到的细节问题：<br><img src="https://resource-1259322763.cos.ap-guangzhou.myqcloud.com/hexo-client/2021/03/10/4a80612f-efe1-4204-ad88-0b656d82338f.png" alt="VjOABt.png"></p>
<ul>
<li>小于使用LessThan关键字，大于使用GreaterThan关键字</li>
<li>小于等于使用LessThanEqual关键字，大于等于使用GreaterThanEqual关键字</li>
<li>时间的比较需要使用After和Before</li>
<li>like关键字不会在参数前后加上%,StartingWith关键字会在参数前加%，EndingWith关键字会在参数后加%，而Containing关键字会在参数前后都加上%，一般用于模糊查询。</li>
<li>In关键字的参数是Collection接口</li>
<li>对于忽略大小写的比较，可以使用IgnoreCase关键字</li>
</ul>
<h1 id="数据的分页和排序"><a href="#数据的分页和排序" class="headerlink" title="数据的分页和排序"></a>数据的分页和排序</h1><p>查询数据时如果想要对数据进行分页，只需要在查询方法中加入Pagable对象，并返回Page或者Slice对象即可，调用时，参数使用PageRequest，并在构造函数中传入起始页以及每页显示的项目数即可。如果想要对分页的数据进行排序，可以在PageRequest构造器中传入Sort对象即可。</p>
<h1 id="GeneratedValue的四种主键生成策略"><a href="#GeneratedValue的四种主键生成策略" class="headerlink" title="GeneratedValue的四种主键生成策略"></a>GeneratedValue的四种主键生成策略</h1><p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/hongchengshise/p/10612301.html">GenerationType四中类型</a></p>
<p>JPA提供的四种标准用法为TABLE,SEQUENCE,IDENTITY,AUTO.</p>
<ul>
<li>TABLE：使用一个特定的数据库表格来保存主键。</li>
<li>SEQUENCE：根据底层数据库的序列来生成主键，条件是数据库支持序列。</li>
<li>IDENTITY：主键由数据库自动生成（主要是自动增长型）</li>
<li>AUTO：主键由程序控制。</li>
</ul>
<h2 id="GenerationType-TABLE"><a href="#GenerationType-TABLE" class="headerlink" title="GenerationType.TABLE"></a>GenerationType.TABLE</h2><p>使用一个特定的数据库表格来保存主键,持久化引擎通过关系数据库的一张特定的表格来生成主键,这种策略的好处就是不依赖于外部环境和数据库的具体实现,在不同数据库间可以很容易的进行移植,但由于其不能充分利用数据库的特性,所以不会优先使用。该策略一般与另外一个注解一起使用@TableGenerator,@TableGenerator注解指定了生成主键的表(可以在实体类上指定也可以在主键字段或属性上指定),然后JPA将会根据注解内容自动生成一张表作为序列表(或使用现有的序列表)。如果不指定序列表,则会生成一张默认的序列表,表中的列名也是自动生成,数据库上会生成一张名为sequence的表(SEQ_NAME,SEQ_COUNT)。序列表一般只包含两个字段:第一个字段是该生成策略的名称,第二个字段是该关系表的最大序号,它会随着数据的插入逐渐累加。</p>
<pre><code class="java">@Id
    @Column(name=&quot;id&quot;)
    @GeneratedValue(strategy=GenerationType.TABLE,generator=&quot;table_gen&quot;)
    @TableGenerator(
            name = &quot;table_gen&quot;,  
            table=&quot;fendo_generator&quot;,  
            pkColumnName=&quot;seq_name&quot;,     //指定主键的名字
            pkColumnValue=&quot;fendos&quot;,      //指定下次插入主键时使用默认的值
            valueColumnName=&quot;seq_id&quot;,    //该主键当前所生成的值，它的值将会随着每次创建累加
            initialValue = 1,            //初始化值
            allocationSize=1             //累加值
            )
    public Integer getUid() &#123;
        return uid;
    &#125;
</code></pre>
<h2 id="GenerationType-SEQUENCE"><a href="#GenerationType-SEQUENCE" class="headerlink" title="GenerationType.SEQUENCE"></a>GenerationType.SEQUENCE</h2><p>在某些数据库中,不支持主键自增长,比如Oracle,其提供了一种叫做”序列(sequence)”的机制生成主键。此时,GenerationType.SEQUENCE就可以作为主键生成策略。该策略的不足之处正好与TABLE相反,由于只有部分数据库(Oracle,PostgreSQL,DB2)支持序列对象,MYsql不支持序列,所以该策略一般不应用于其他数据库。类似的,该策略一般与另外一个注解一起使用@SequenceGenerator,@SequenceGenerator注解指定了生成主键的序列.然后JPA会根据注解内容创建一个序列(或使用一个现有的序列)。如果不指定序列,则会自动生成一个序列SEQ_GEN_SEQUENCE。</p>
<pre><code>@Id  
@GeneratedValue(strategy = GenerationType.SEQUENCE,generator=&quot;fendo_seq&quot;)  
@SequenceGenerator(name=&quot;fendo_seq&quot;, sequenceName=&quot;seq_name&quot;)
</code></pre>
<h2 id="GenerationType-IDENTITY"><a href="#GenerationType-IDENTITY" class="headerlink" title="GenerationType.IDENTITY"></a>GenerationType.IDENTITY</h2><p>此种主键生成策略就是通常所说的主键自增长,数据库在插入数据时,会自动给主键赋值,比如MySQL可以在创建表时声明”auto_increment” 来指定主键自增长。该策略在大部分数据库中都提供了支持(指定方法或关键字可能不同),但还是有少数数据库不支持,所以可移植性略差。使用自增长主键生成策略是只需要声明strategy = GenerationType.IDENTITY即可。</p>
<pre><code class="java">@Id  
@GeneratedValue(strategy = GenerationType.IDENTITY)
</code></pre>
<h2 id="GenerationType-AUTO"><a href="#GenerationType-AUTO" class="headerlink" title="GenerationType.AUTO"></a>GenerationType.AUTO</h2><p>把主键生成策略交给持久化引擎(persistence engine),持久化引擎会根据数据库在以上三种主键生成策略中选择其中一种。此种主键生成策略比较常用,由于JPA默认的生成策略就是GenerationType.AUTO,所以使用此种策略时.可以显式的指定@GeneratedValue(strategy = GenerationType.AUTO)也可以直接@GeneratedValue。</p>
<pre><code class="java">@Id  
@GeneratedValue(strategy = GenerationType.AUTO)
</code></pre>
<h2 id="各种数据库支持的类型"><a href="#各种数据库支持的类型" class="headerlink" title="各种数据库支持的类型"></a>各种数据库支持的类型</h2><p><img src="https://s2.ax1x.com/2019/06/20/VvNLYd.png" alt="各种数据库支持的类型"></p>
<h1 id="使用Projections查询部分字段"><a href="#使用Projections查询部分字段" class="headerlink" title="使用Projections查询部分字段"></a>使用Projections查询部分字段</h1><p>在写代码时常常有这样的业务逻辑，就是仅仅查询实体类的部分字段，而忽略其他的字段，比如查询用户，不包括用户的密码等敏感信息。</p>
<p>Spring Data JPA对Projections有很好的支持，使用方式如下：<br>对于如下的实体类：</p>
<pre><code class="java">@Data
@Entity
public class User &#123;
    @Id
    @GeneratedValue
    private Long id;
    private String name;
    private String email;
    private String address;
&#125;
</code></pre>
<p>如果只想查询用户的name和email字段，首先需要定义一个接口，包含想要查询的字段的<strong>getter方法</strong>：</p>
<pre><code class="java">/**
 * @author Aviator
 */
@ToString
public interface User &#123;
    String getName();
    String getEmail();
&#125;
</code></pre>
<p>然后在Repository中，编写查询方法，方法返回的集合中包含该接口：</p>
<pre><code class="java">public interface UserJpaRepository extends Repository&lt;User,Long&gt; &#123;
    /**
     * 查询所有name的用户
     * @param name 字符串类型
     * @return projection，查询特定字段的值,集合中的User为编写的接口。
     */
    List&lt;User&gt; findUserByName(String name);
&#125;
</code></pre>
<p>这样就可以查询User实体类的name和email字段了：</p>
<pre><code class="java">@RestController
public class UserController &#123;

    @Autowired
    UserJpaRepository userRepository;

    @GetMapping(&quot;/user&quot;)
    public List&lt;UserDTO&gt; getAllUser()&#123;
        return userRepository.findUserByName(&quot;熊乾坤&quot;);
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<pre><code class="json">[&#123;&quot;name&quot;:&quot;熊乾坤&quot;,&quot;email&quot;:&quot;2372389705@qq.com&quot;&#125;,&#123;&quot;name&quot;:&quot;熊乾坤&quot;,&quot;email&quot;:&quot;2372389705@qq.com&quot;&#125;]
</code></pre>
<p>除了使用接口的方式，JPA中也可以使用DTO类来实现Projections:</p>
<pre><code class="java">@Getter
@ToString
public class UserDTO &#123;
    /**
     * 使用Projection时，字段必须为final修饰
     */
    private final String name, email;

    public UserDTO(String name, String email) &#123;
        this.name = name;
        this.email = email;
    &#125;
&#125;
</code></pre>
<p><strong>值得注意的是：如果使用DTO类的方式，类中的字段必须使用final修饰，否则会抛出没有转换器的异常，要注意一下。</strong></p>
<h1 id="使用动态Projections"><a href="#使用动态Projections" class="headerlink" title="使用动态Projections"></a>使用动态Projections</h1><p>上面学习的Projections也支持动态的操作，在Repository定义的方法中，使用泛型，就可以达到动态的映射，可以根据判定条件查询实体类的某些字段：</p>
<pre><code class="java">public interface UserJpaRepository&lt;T&gt; extends Repository&lt;User,Long&gt; &#123;
    /**
     * 使用模糊查询
     * @param name 字符串类型
     * @param tClass 类型信息
     * @return 用户列表
     */
    List&lt;T&gt; findUserByName(String name,Class&lt;T&gt; tClass);
&#125;
</code></pre>
<p>此时，如果想查询User的所有字段，则调用findUserByName方法时只需要指定tClass参数为User.class,如果只需要查询User的部分参数，则tClass参数传入UserDTO.class即可。</p>
<h1 id="合理使用-Modifying注解"><a href="#合理使用-Modifying注解" class="headerlink" title="合理使用@Modifying注解"></a>合理使用@Modifying注解</h1><p>在使用Spring Data JPA对数据库中的数据进行修改或者删除操作时，在使用@Query注解的同时，也需要使用到@Modifying注解，但是单独使用@Modifying注解时可能会因为缓存而导致一些问题。</p>
<p>JPA 的 Repository 提供一种非常易用的机制用于 ORM 方式处理数据，但是如果需要一次性更新一批数据的部分字段，构造所有实体并逐个修改字段再存回数据库就显得有些臃肿。在 JPA 中提供了 @Query 注解用于使用 JPQL 执行数据库操作，如果数据库操作是修改数据而非查询数据，则需要再额外使用 @Modifying 注解提示 JPA 该操作是修改操作。</p>
<p>当进行 find 操作时，JPA 在 EntityManager 中缓存了 find 生成的对象，当再次 find 时会直接返回该对象。于是可能会出现下面这种情况 ,用@Query 定义一个修改状态的方法</p>
<pre><code class="java">public interface EntityRepository extends JpaRepository&lt;Entity, Integer&gt; &#123;

    @Modifying
    @Query(&quot;update Entity set status = &#39;IGNORED&#39; where id = ?1&quot;)
    int updateStatus(int id);

&#125;
</code></pre>
<p>先读取一个对象，再修改对象状态，再次读取对象</p>
<pre><code class="java">Optional&lt;Entity&gt; entityBefore = repository.findById(1);

repository.updateStatus(1);

Optional&lt;Entity&gt; entityAfter = repository.findById(1);
</code></pre>
<p>结果会发现 entityBefore 和 entityAfter 中的 Entity 对象 id 是相同的，中间对状态的修改并没有体现出来！当然，其原因也很明确，**@Query 跟 find 和 save 系列方法是两套不同的体系**，@Query 引起的数据库变更 EntityManager 并不能发现，更进一步说，使用其它工具或者其它框架修改数据库中的数据，也不能及时反应到 JPA 的 find 系列方法上来。</p>
<p>当然，只要有缓存机制就一定不可避免存在此类问题，这仅是个取舍问题而不要认为是 BUG。如果要解决 find 得到的值不是数据库中最新值的问题可以有几种方式，避免使用 @Query 是一种方式，在需要时显式清理 EntityManager 的缓存也是一种方式。Spring Data JPA 提供了另外一种方式则是 @Modifying(clearAutomatically = true)，@Modifying 的 clearAutomatically 属性为 true 时，执行完 modifying query 之后就会清理缓存，从而在下次 find 时就可以读取到数据库中的最新值。</p>
<p>自动清理之后还会带来一个新的问题，clear 操作清理的缓存中，还包括提交后未 flush 的数据，例如调用 save 而不是 saveAndFlush 就有可能不会立即将修改内容更新到数据库中，在 save 之后 flush 之前调用 @Modifying(clearAutomatically = true) 修饰的方法就有可能导致修改丢失。如果再要解决这个问题，还可以再加上另外一个属性 @Modifying(clearAutomatically = true, flushAutomatically = true)，**@Modifying 的 flushAutomatically 属性为 true 时，执行 modifying query 之前会先调用 flush 操作，从而避免数据丢失问题。**</p>
<p>在实际运行中，clear 和 flush 操作都可能需要消耗一定的时间，要根据系统实际情况可以选择使用其中的一个或两个属性，以保证系统的正确性。</p>
<p>参考: flushAutomatically 属性是在 <a target="_blank" rel="noopener" href="https://jira.spring.io/browse/DATAJPA-806">https://jira.spring.io/browse/DATAJPA-806</a> 提出并被采纳的。</p>
<p><strong>参考地址：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://my.oschina.net/u/1762727/blog/2960653">@Modifying注解详解</a></li>
</ul>
<h1 id="Entity中常用的注解"><a href="#Entity中常用的注解" class="headerlink" title="Entity中常用的注解"></a>Entity中常用的注解</h1><p>实体类中有很多可以使用的注解，下面是常用的一些注解：</p>
<h2 id="Basic-fetch-FetchType-optional-true"><a href="#Basic-fetch-FetchType-optional-true" class="headerlink" title="@Basic(fetch=FetchType,optional=true)"></a>@Basic(fetch=FetchType,optional=true)</h2><p>　　@Basic表示一个简单的属性到数据库表的字段的映射,对于没有任何标注的getXxxx()方法,默认 即为 @Basic</p>
<p>　　fetch: 表示该属性的读取策略,有EAGER和LAZY两种,分别表示主支抓取和延迟加载,默认为EAGER.</p>
<ul>
<li>FetchType.LAZY：懒加载，加载一个实体时，定义懒加载的属性不会马上从数据库中加载。</li>
<li>FetchType.EAGER：急加载，加载一个实体时，定义急加载的属性会立即从数据库中加载。</li>
</ul>
<p>比方User类有两个属性，name跟address，就像百度知道，登录后用户名是需要显示出来的，此属性用到的几率极大，要马上到数据库查，用急加载;而用户地址大多数情况下不需要显示出来，只有在查看用户资料是才需要显示，需要用了才查数据库，用懒加载就好了。所以，并不是一登录就把用户的所有资料都加载到对象中，于是有了这两种加载模式。 optional:表示该属性是否允许为null,默认为true</p>
<pre><code class="java">@Basic(optional=false)

　　public String getAddress() &#123; return address; &#125;
</code></pre>
<h2 id="Transient"><a href="#Transient" class="headerlink" title="@Transient"></a>@Transient</h2><p>@Transient表示该属性并非一个到数据库表的字段的映射，表示<br>非持久化属性，与@Basic作用相反。JPA映射数据库的时候忽略它。如果一个属性并非数据库表的字段映射,就务必将其标示为 @Transient ,否则,ORM框架默认其注解为 @Basic</p>
<h2 id="Temporal-TemporalType"><a href="#Temporal-TemporalType" class="headerlink" title="@Temporal(TemporalType)"></a>@Temporal(TemporalType)</h2><p>@Temporal用来设置Date类型的属性映射到对应精度的字段。</p>
<ul>
<li>@Temporal(TemporalType.DATE)映射为日期date（只有<br>日期）。</li>
<li>@Temporal(TemporalType.TIME)映射为时间time（只有<br>时间）。</li>
<li>@Temporal(TemporalType.TIMESTAMP)映射为日期date+<br>time（日期+时间）。</li>
</ul>
<h2 id="Lob"><a href="#Lob" class="headerlink" title="@Lob"></a>@Lob</h2><p>@Lob 将属性映射成数据库支持的大对象类型，支持以下两种数<br>据库类型的字段。</p>
<ul>
<li>Clob（Character Large Ojects）类型是长字符串类型，<br>java.sql.Clob、Character[]、char[]和String将被映射为Clob类 型。</li>
<li>Blob（Binary Large Objects）类型是字节类型，<br>java.sql.Blob、Byte[]、byte[]和实现了Serializable接口的类型 将被映射为Blob类型。</li>
<li>Clob、Blob占用内存空间较大，一般配合<br>@Basic(fetch=FetchType.LAZY)将其设置为延迟加载。</li>
</ul>
<h2 id="Enumerated"><a href="#Enumerated" class="headerlink" title="@Enumerated"></a>@Enumerated</h2><p>在数据库中创建字段时，可以创建枚举类型的字段，例如在User表中，GENDER字段为枚举类型ENUM(‘MALE’,FEMALE)。那么在Entity实体类中需要在字段上使用使用@Enumerated注解，并创建相应的枚举类：</p>
<p>创建Enum：</p>
<pre><code class="java">public enum Gender &#123;
    //男性
    MALE(&quot;男性&quot;),
    //女性
    FEMALE(&quot;女性&quot;);

    private String value;
    Gender(String str)&#123;
        value=str;
    &#125;
&#125;
</code></pre>
<p>然后在实体类中使用@Enumerated注解：</p>
<pre><code class="java">@Entity
@Data
@Table(name = &quot;USER&quot;)
public class User &#123;
    @Id
    @GeneratedValue
    private Long id;

    @Column(name = &quot;NAME&quot;)
    private String name;

    @Column(name = &quot;EMAIL&quot;)
    private String email;

    @Column(name = &quot;ADDRESS&quot;)
    private String address;

    @Enumerated(EnumType.STRING)
    @Column(name = &quot;GENDER&quot;)
    private Gender gender;
&#125;
</code></pre>
<p>这样就可以在实体类中使用枚举类型啦。</p>
<p>值得注意的是，这时插入两条数据，数据库里面的值是MAIL/FMAIL，而不是“男<br>性”/“女性”。<strong>如果我们用@Enumerated(EnumType.ORDINAL)，那么 这时数据库里面的值是0、1。但是实际工作中，不建议用数字下标，因为枚举里面的属性值是会不断新增的，如果新增一个，位置变化了就惨了。</strong></p>
<h2 id="CreatedDate"><a href="#CreatedDate" class="headerlink" title="@CreatedDate"></a>@CreatedDate</h2><p>用来指定当前的时间字段的数据为数据插入时的时间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/06/04/%E8%BD%AC%E8%BD%BD-Lombok%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/04/%E8%BD%AC%E8%BD%BD-Lombok%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" class="post-title-link" itemprop="url">[转载]Lombok安装与常见的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-04 11:26:00" itemprop="dateCreated datePublished" datetime="2019-06-04T11:26:00+08:00">2019-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 20:59:58" itemprop="dateModified" datetime="2021-02-23T20:59:58+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/06/04/%E8%BD%AC%E8%BD%BD-Lombok%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/06/04/%E8%BD%AC%E8%BD%BD-Lombok%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文地址：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuyuegb2312/p/9750462.html">lombok踩坑与思考</a></p>
<p>在实习的时候公司的代码中用到了Lombok，主要是为了简化实体类的代码量，以前这些Getter和Setter方法都是用IDEA的ctrl+insert来生成的，但是为了代码风格的一致性，以后得改用Lombok了。在网上看到一篇关于Lombok踩坑的文章，抄袭一下。</p>
<h1 id="Lombok安装"><a href="#Lombok安装" class="headerlink" title="Lombok安装"></a>Lombok安装</h1><p>想要使用Lombok，首先需要在maven中加入Lombok的依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后需要在IDEA中安装Lombok的插件，在IDEA中点击File-&gt;Settings-&gt;Plugins，然后所有Lombok插件进行安装并重启IDEA，</p>
<p>最后，需要打开IDEA的Annotation Processors，在IDEA中选择File-&gt;Settings-&gt;Build,Execution,deployment-&gt;Compiler-&gt;Annotation Processors，然后勾选Enable annotation processing选项就OK啦。接下来就可以使用Lombok啦。</p>
<h1 id="一些杂七杂八的问题"><a href="#一些杂七杂八的问题" class="headerlink" title="一些杂七杂八的问题"></a>一些杂七杂八的问题</h1><p>以下这些是最初我不喜欢lombok的原因。</p>
<h2 id="额外的环境配置"><a href="#额外的环境配置" class="headerlink" title="额外的环境配置"></a>额外的环境配置</h2><p>作为IDE插件+jar包，需要对IDE进行一系列的配置。目前在idea中配置还算简单，几年前在eclipse下也配置过，会复杂不少。</p>
<h2 id="传染性"><a href="#传染性" class="headerlink" title="传染性"></a>传染性</h2><p>一般来说，对外打的jar包最好尽可能地减少三方包依赖，这样可以加快编译速度，也能减少版本冲突。一旦在resource包里用了lombok，别人想看源码也不得不装插件。</p>
<p>而这种不在对外jar包中使用lombok仅仅是约定俗成，当某一天lombok第一次被引入这个jar包时，新的感染者无法避免。</p>
<h2 id="降低代码可读性"><a href="#降低代码可读性" class="headerlink" title="降低代码可读性"></a>降低代码可读性</h2><p>定位方法调用时，对于自动生成的代码，getter/setter还好说，找到成员变量后find usages，再根据上下文区分是哪种；equals()这种，想找就只能写段测试代码再去find usages了。</p>
<p>目前主流ide基本都支持自动生成getter/setter代码，和lombok注解相比不过一次键入还是一次快捷键的区别，实际减轻的工作量十分微小。</p>
<h1 id="EqualsAndHashCode和equals"><a href="#EqualsAndHashCode和equals" class="headerlink" title="@EqualsAndHashCode和equals()"></a>@EqualsAndHashCode和equals()</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当这个注解设置callSuper=true时，会调用父类的equlas()方法，对应编译后class文件代码片段如下：</p>
<pre><code class="java">public boolean equals(Object o) &#123;
    if (o == this) &#123;
        return true;
    &#125; else if (!(o instanceof BaseVO)) &#123;
        return false;
    &#125; else &#123;
        BaseVO other = (BaseVO)o;
        if (!other.canEqual(this)) &#123;
            return false;
        &#125; else if (!super.equals(o)) &#123;
            return false;
        &#125; else &#123; 
            // 各项属性比较
        &#125;
    &#125;
&#125;
</code></pre>
<p>如果一个类的父类是Object（java中默认没有继承关系的类父类都是Object），那么这里会调用Object的equals()方法，如下</p>
<pre><code class="java">public boolean equals(Object obj) &#123;
    return (this == obj);
&#125;
</code></pre>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>对于父类是Object且使用了@EqualsAndHashCode(callSuper = true) 注解的类，这个类由lombok生成的equals()方法只有在两个对象是同一个对象时，才会返回true，否则总为false，无论它们的属性是否相同。这个行为在大部分时间是不符合预期的，equals()失去了其意义。即使我们期望equals()是这样工作的，那么其余的属性比较代码便是累赘，会大幅度降低代码的分支覆盖率。以一个近6000行代码的业务系统举例，是否修复该问题并编写对应测试用例，可以使整体的jacoco分支覆盖率提高10%~15%。</p>
<p>相反地，由于这个注解在jacoco下只算一行代码，未覆盖行数倒不会太多。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>有几种解决方法可以参考：</p>
<ul>
<li>不使用该注解。大部分pojo我们是不会调用equals进行比较的，实际用到时再重写即可。</li>
<li>去掉callSuper = true。如果父类是Object，推荐使用。</li>
<li>重写父类的equals()方法，确保父类不会调用或使用类似实现的Ojbect的equals()。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>@data注解包含@EqualsAndHashCode注解，由于不调用父类equals()，避免了Object.equals()的坑，但可能带来另一个坑。详见@data章节。</p>
<h1 id="data"><a href="#data" class="headerlink" title="@data"></a>@data</h1><h2 id="从一个坑出来掉到另一个大坑"><a href="#从一个坑出来掉到另一个大坑" class="headerlink" title="从一个坑出来掉到另一个大坑"></a>从一个坑出来掉到另一个大坑</h2><p>上文提到@EqualsAndHashCode(callSuper = true) 注解的坑，那么 @data 是否可以避免呢？很不幸的是，这里也有个坑。<br>由于 @data 实际上就是用的 @EqualsAndHashCode，没有调用父类的equals()，当我们需要比较父类属性时，是无法比较的。示例如下：</p>
<pre><code class="java">@Data
public class ABO &#123;
    private int a;

&#125;

@Data
public class BBO extends ABO &#123;

    private int b;

    public static void main(String[] args) &#123;

        BBO bbo1 = new BBO();
        BBO bbo2 = new BBO();

        bbo1.setA(1);
        bbo2.setA(2);

        bbo1.setB(1);
        bbo2.setB(1);

        System.out.print(bbo1.equals(bbo2)); // true
    &#125;
&#125;
</code></pre>
<p>很显然，两个子类忽略了父类属性比较。这并不是因为父类的属性对于子类是不可见——即使把父类private属性改成protected，结果也是一样——而是因为lombok自动生成的equals()只比较子类特有的属性。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>用了 @data 就不要有继承关系，类似kotlin的做法，具体探讨见下一节</li>
<li>自己重写equals()，lombok不会对显式重写的方法进行生成</li>
<li>显式使用@EqualsAndHashCode(callSuper = true)。lombok会以显式指定的为准。</li>
</ul>
<h2 id="关于-data和data"><a href="#关于-data和data" class="headerlink" title="关于@data和data"></a>关于@data和data</h2><p>在了解了 @data 的行为后，会发现它和kotlin语言中的data修饰符有点像：都会自动生成一些方法，并且在继承上也有问题——前者一旦有继承关系就会踩坑，而后者修饰的类是final的，不允许继承。kotlin为什么要这样做，二者有没有什么联系呢？在一篇流传较广的文章(抛弃 Java 改用 Kotlin 的六个月后，我后悔了(译文))中，对于data修饰符，提到：</p>
<p>Kotlin 对 equals()、hashCode()、toString() 以及 copy() 有很好的实现。在实现简单的DTO 时它非常有用。但请记住，数据类带有严重的局限性。你无法扩展数据类或者将其抽象化，所以你可能不会在核心模型中使用它们。</p>
<p>这个限制不是 Kotlin 的错。在 equals() 没有违反 Liskov 原则的情况下，没有办法产生正确的基于值的数据。</p>
<p>对于Liskov（里氏替换）原则，可以简单概括为：</p>
<p>一个对象在其出现的任何地方，都可以用子类实例做替换，并且不会导致程序的错误。换句话说，当子类可以在任意地方替换基类且软件功能不受影响时，这种继承关系的建模才是合理的。</p>
<p>根据上一章的讨论，equals()的实现实际上是受业务场景影响的，无论是否使用父类的属性做比较都是有可能的。但是kotlin无法决定equals()默认的行为，不使用父类属性就会违反了这个原则，使用父类属性有可能落入调用Object.equals()的陷阱，进入了两难的境地。</p>
<p>kotlin的开发者回避了这个问题，不使用父类属性并且禁止继承即可。只是kotlin的使用者就会发现自己定义的data对象没法继承，不得不删掉这个关键字手写其对应的方法。</p>
<p>回过头来再看 @data ，它并没有避免这些坑，只是把更多的选择权交给开发者决定，是另一种做法。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>其他lombok注解实际使用较少，整体阅读了 官方文档暂时没有发现其他问题，遇到以后继续更新。<br>实际上官方文档中也提到了equals()的坑。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/06/02/SpringBoot%E5%B8%B8%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/02/SpringBoot%E5%B8%B8%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9/" class="post-title-link" itemprop="url">SpringBoot常用的配置项</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-02 11:49:00" itemprop="dateCreated datePublished" datetime="2019-06-02T11:49:00+08:00">2019-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 20:59:58" itemprop="dateModified" datetime="2021-02-23T20:59:58+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/06/02/SpringBoot%E5%B8%B8%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/06/02/SpringBoot%E5%B8%B8%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>SpringBoot减少了Spring应用的大量的配置，但是开发者可能还需要对项目的细节进行微调，以满足自己特殊的需求，而这些配置项都应该在项目自带的配置文件application.properties中进行配置，如下是一些经常会用到的配置项，以后忘记了可以到这里看一看：</p>
<h1 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h1><pre><code class="yaml">spring:
  datasource:
    url:jdbc: mysql://127.0.0.1:3306/yxb?useSSL=false&amp;useUnicode=true
            &amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai
    driver: com.mysql.cj.jdbc.Driver    #一般不需要指定
    username: root
    password: 123456
</code></pre>
<h1 id="设置项目的启动端口和IP"><a href="#设置项目的启动端口和IP" class="headerlink" title="设置项目的启动端口和IP"></a>设置项目的启动端口和IP</h1><pre><code class="yaml">#启动端口和IP
server:
  port: 8080
  address: 192.168.1.10    #在部署到服务器时不需要此配置
</code></pre>
<h1 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h1><pre><code class="yaml">spring:
  jpa:
    show-sql: true    #打印sql语句
    properties:
      hibernate:
        enable_lazy_load_no_trans: true #解决缺少session的问题
        format_sql: true #格式化sql语句
        ddl_auto: true #实体类可以更改数据库结构，在@Table注解中加上catalog属性，值为数据库名。
</code></pre>
<h1 id="Banner"><a href="#Banner" class="headerlink" title="Banner"></a>Banner</h1><pre><code class="yaml">spring:
  banner:
    location: banner.txt    #指定banner.txt的位置
    
</code></pre>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><pre><code class="yaml">logging:
  level:
    root: info    #定义日志的打印等级
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/06/02/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/02/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">SpringBoot学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-02 10:37:00" itemprop="dateCreated datePublished" datetime="2019-06-02T10:37:00+08:00">2019-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 20:59:58" itemprop="dateModified" datetime="2021-02-23T20:59:58+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/06/02/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/06/02/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考文章：<br><a target="_blank" rel="noopener" href="https://docshome.gitbooks.io/springboot/content/">SpringBoot中文文档</a><br><a href="">SpringBoot实战</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liaojie970/p/8043150.html">@ConfigurationProperties注解</a>    </p>
<p>现在公司新项目使用的是SpringBoot，所以趁现在有时间学习一下SpringBoot,为以后的开发做好准备。</p>
<h1 id="spring-boot-maven-plugin插件"><a href="#spring-boot-maven-plugin插件" class="headerlink" title="spring-boot-maven-plugin插件"></a>spring-boot-maven-plugin插件</h1><p>SpringBoot项目中会自带一个插件：<code>org.springframework.boot：spring-boot-maven-plugin</code>，这个插件有如下几个目标可以使用：</p>
<ul>
<li>spring-boot:build-info</li>
<li>spring-boot:help 运行该目标能够显示其他目标的说明文字</li>
<li>spring-boot:repackage</li>
<li>spring-boot:run 启动你的项目</li>
<li>spring-boot:start</li>
<li>spring-boot:stop</li>
</ul>
<p>Spring Boot Maven plugin的最主要goal就是repackage，其在Maven的package生命周期阶段，能够将mvn package生成的软件包，再次打包为可执行的软件包，并将mvn package生成的软件包重命名为*.original。使用命令<code>mvn package spring-boot:repackage</code>将生成一个可以直接执行的jar包，使用java -jar执行，同时原生的jar使用.original后缀保存。</p>
<h1 id="指定SpringBoot启动时运行的类"><a href="#指定SpringBoot启动时运行的类" class="headerlink" title="指定SpringBoot启动时运行的类"></a>指定SpringBoot启动时运行的类</h1><p>你还可以指定要执行的类，如果不指定的话，Spring会找有这个【public static void main(String[] args)】方法的类，当做可执行的类。</p>
<p>如果你想指定的话，可以用下面两个方法：</p>
<ul>
<li>如果你的POM是继承spring-boot-starter-parent的话，只需要下面的指定就行。</li>
</ul>
<pre><code class="xml">&lt;properties&gt;
    &lt;!-- The main class to start by executing java -jar --&gt;
    &lt;start-class&gt;com.mycorp.starter.HelloWorldApplication&lt;/start-class&gt;
&lt;/properties&gt;
</code></pre>
<ul>
<li>如果你的POM不是继承spring-boot-starter-parent的话，需要下面的指定。</li>
</ul>
<pre><code class="xml">    &lt;plugin&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
      &lt;configuration&gt;
        &lt;mainClass&gt;$&#123;start-class&#125;&lt;/mainClass&gt;
        &lt;layout&gt;ZIP&lt;/layout&gt;
      &lt;/configuration&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;goals&gt;
            &lt;goal&gt;repackage&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
</code></pre>
<h1 id="SpringBootApplication注解"><a href="#SpringBootApplication注解" class="headerlink" title="@SpringBootApplication注解"></a>@SpringBootApplication注解</h1><p>@SpringBootApplication开启了Spring的组件扫描和Spring Boot的自动配置功能。实际上，@SpringBootApplication将三个有用的注解组合在了一起。</p>
<ul>
<li>Spring的@Configuration：标明该类使用Spring基于Java的配置。虽然本书不会写太多 配置，但我们会更倾向于使用基于Java而不是XML的配置。</li>
<li>Spring的@ComponentScan：启用组件扫描，这样你写的Web控制器类和其他组件才能被 自动发现并注册为Spring应用程序上下文里的Bean。本章稍后会写一个简单的Spring MVC 控制器，使用@Controller进行注解，这样组件扫描才能找到它。</li>
<li>Spring Boot的@EnableAutoConfiguration：这个不起眼的小注解也可以称为 @Abracadabra<br>，就是这一行配置开启了Spring Boot自动配置的魔力，让你不用再写成篇的配置了。</li>
</ul>
<p>在Spring Boot的早期版本中，你需要在ReadingListApplication类上同时标上这三个注<br>解，但从Spring Boot 1.2.0开始，有@SpringBootApplication就行了。</p>
<h1 id="使用-ConfigurationProperties注解"><a href="#使用-ConfigurationProperties注解" class="headerlink" title="使用@ConfigurationProperties注解"></a>使用@ConfigurationProperties注解</h1><p>在application.yml中，假如有如下配置：</p>
<pre><code class="yml">#自定义配置
myconfig:
  config1: this is myconfig
</code></pre>
<p>如果想将myconfig下的配置包装成一个对象，并提供getter和setter方法进行读取和写入，应该如何实现呢？这就需要使用<code>@ConfigurationProperties</code>注解去实现。使用这个注解主要由以下步骤：</p>
<ol>
<li>为项目于添加spring-boot-configuration-processor依赖</li>
<li>创建一个Bean,并定义myconfig下的所有属性，并提供getter或者setter方法。</li>
<li>在需要使用到的地方使用getter和setter方法进行读取和写入。</li>
</ol>
<p>要使用ConfigurationProperties注解，首先需要为项目添加所需的依赖，在pom文件中添加：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后创建bean:</p>
<pre><code class="java">package com.xqk.yxb.dto;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * @author Aviator
 */
@Data
@Component
@ConfigurationProperties(prefix = &quot;myconfig&quot;)
public class MyConfig &#123;
    private String config1;
&#125;
</code></pre>
<p>bean中的@ConfigurationProperties注解定义了属性在配置文件中的前缀为myconfig，并定义了myconfig下的属性config1。并提供了getter和setter方法。</p>
<p>需要使用自定义的属性时，只需要注入我们自定义的bean，就可以使用：</p>
<pre><code class="java">package com.xqk.yxb.controller;

import com.xqk.yxb.dto.HTTPResponse;
import com.xqk.yxb.dto.MyConfig;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * @author Aviator
 */
@RestController
public class HomeController &#123;

    @Autowired
    private MyConfig myConfig;

    private Logger log=Logger.getLogger(&quot;HomeController&quot;);

    @RequestMapping(value = &quot;/index&quot;,method = RequestMethod.GET)
    public HTTPResponse home()&#123;
        log.log(Level.INFO,myConfig.getConfig1());
        myConfig.setConfig1(&quot;项目搭建成功&quot;);
        log.log(Level.INFO,myConfig.getConfig1());
        return new HTTPResponse(1,&quot;项目搭建成功&quot;);
    &#125;
&#125;
</code></pre>
<p>也可以在@bean注解的方法上使用@ConfigurationProperties注解，这样就不需要在实体类上使用@Component和@Configuration注解了,在启动类中定义bean：</p>
<pre><code class="java">package com.dxz.property4;

import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;

@SpringBootApplication
public class TestProperty4 &#123;

    @Bean
    @ConfigurationProperties(locations = &quot;classpath:mail.properties&quot;,prefix = &quot;mail&quot;)
    public MailProperties mailProperties()&#123;
        MailProperties mp = new MailProperties();
        System.out.println(&quot;zheli &quot; + mp);
        return mp;

    &#125;

    public static void main(String[] args) &#123;
        //SpringApplication.run(TestProperty1.class, args);
        new SpringApplicationBuilder(TestProperty4.class).web(true).run(args);

    &#125;
&#125;
</code></pre>
<blockquote>
<p><strong>开启配置属性</strong> 从技术上来说，@ConfigurationProperties注解不会生效，除<br>非先向Spring配置类添加@EnableConfigurationProperties注解。但通常无需这么 做，因为Spring Boot自动配置后面的全部配置类都已经加上了@EnableConfigurationProperties注解。因此，除非你完全不使用自动配置（那怎么可能？），否则就无需显式地添加@EnableConfigurationProperties。</p>
</blockquote>
<h1 id="使用-ApplicationRunner-或-CommandLineRunner"><a href="#使用-ApplicationRunner-或-CommandLineRunner" class="headerlink" title="使用 ApplicationRunner 或 CommandLineRunner"></a>使用 ApplicationRunner 或 CommandLineRunner</h1><p>如果您需要在 SpringApplication 启动时运行一些代码，可以实现 ApplicationRunner 或者 CommandLineRunner 接口。这两个接口的工作方式是一样的，都提供了一个单独的 run 方法，它将在 SpringApplication.run(​…) 完成之前调用。</p>
<p>CommandLineRunner 接口提供了访问应用程序字符串数组形式参数的方法，而 ApplicationRunner 则使用了上述的 ApplicationArguments 接口。以下示例展示 CommandLineRunner 和 run 方法的使用：</p>
<pre><code class="java">import org.springframework.boot.*;
import org.springframework.stereotype.*;

@Component
public class MyBean implements CommandLineRunner &#123;

    public void run(String... args) &#123;
        // Do something...
    &#125;

&#125;
</code></pre>
<p>如果您定义了多个 CommandLineRunner 或者 ApplicationRunner bean，则必须指定调用顺序，您可以实现 org.springframework.core.Ordered 接口，也可以使用 org.springframework.core.annotation.Order 注解解决顺序问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/05/21/Maven%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/21/Maven%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Maven知识点总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-21 11:51:00" itemprop="dateCreated datePublished" datetime="2019-05-21T11:51:00+08:00">2019-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:02" itemprop="dateModified" datetime="2021-02-23T21:00:02+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/05/21/Maven%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/05/21/Maven%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考地址：<a target="_blank" rel="noopener" href="http://ifeve.com/maven-pom/">并发编程网-maven文档翻译</a>    </p>
<p>实习结束后从上海到武汉已经休息了大半个月了，是时候学习点东西了，首先想学习一下关于Maven的知识，回想起来貌似还没有系统的学过Maven，平时最多的也就用到过Maven的依赖管理，公司项目的POM文件很多标签都不知道什么意思,所以系统学习一下Maven还是很有必要的，网上找了一本扫描版的Maven实战的电子书凑活看一下。等Maven学完之后再将公司实习的时候每周总结的知识点学习一遍，岂不美哉？so,开始吧。    </p>
<h1 id="Maven的安装与配置"><a href="#Maven的安装与配置" class="headerlink" title="Maven的安装与配置"></a>Maven的安装与配置</h1><p>用户下载Maven的安装包，然后解压到指定目录，配置M2_HOME的环境变量，并将<code>%M2_HOME%/bin</code>添加到path环境变量中。同时如果需要修改本地仓库路径，可以在 Maven 目录下的 conf/setting.xml 文件中，通过 <localRepository /> 来指定本地仓库路径，默认路径为<code>~/.m2/repository</code>。</p>
<p>在首次运行mvn命令行时，可能会抛出<code>No compiler is provided in this environment. Perhaps you are running on a JRE rather than a JDK?</code>错误，这是因为mvn打包需要jdk的环境，而它自己没有找到jdk的配置目录，所以就报错了，首先应该检查自己的jdk环境变量是否有问题，如果没问题，就需要修改一下bin目录中的mvn.bat或者mvn.sh文件的代码：<img src="https://resource-1259322763.cos.ap-guangzhou.myqcloud.com/blog/Maven%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Maven%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png" alt="图片"><br>在mvn.bat文件中，手动设置JAVA_HOME的目录，就可以解决这个问题：<br><img src="https://resource-1259322763.cos.ap-guangzhou.myqcloud.com/blog/Maven%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/maven%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF.png" alt="图片"></p>
<h1 id="问题-idea-maven-有jar包，就是报错整个项目找不到jar"><a href="#问题-idea-maven-有jar包，就是报错整个项目找不到jar" class="headerlink" title="[问题]idea maven 有jar包，就是报错整个项目找不到jar"></a>[问题]idea maven 有jar包，就是报错整个项目找不到jar</h1><p>idea中的mvn很容易出现各种各样的问题，有时候明明mvn中有jar包，但是编译的时候还是提示却少jar包，这有可能是idea的解析有问题，删除.iml文件，让他重新生成，试了几次之后就成功了。</p>
<h1 id="pom-xml中最基本的标签"><a href="#pom-xml中最基本的标签" class="headerlink" title="pom.xml中最基本的标签"></a>pom.xml中最基本的标签</h1><pre><code class="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;
  &lt;artifactId&gt;my-app&lt;/artifactId&gt;
  &lt;version&gt;1&lt;/version&gt;
  &lt;name&gt;项目名称&lt;/name&gt;
  &lt;description&gt;Parent pom providing dependency and plugin
  management for applications built with Maven&lt;/description&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
&lt;/project&gt;
</code></pre>
<ul>
<li>modelVersion 指定xml的版本，在maven3和2中只能为4.0.0</li>
<li>groupId和artifactId是maven项目的坐标</li>
<li>version 工程的版本</li>
<li>packaging 项目打包的格式，可以是jar、war、pom，当项目为聚合或者继承项目时，必须要将其申明为pom</li>
<li>name 项目的输出名称，在mvn命令时会显示该名称</li>
<li>description 项目的简要描述</li>
</ul>
<h1 id="依赖引入（dependencies）"><a href="#依赖引入（dependencies）" class="headerlink" title="依赖引入（dependencies）"></a>依赖引入（dependencies）</h1><pre><code class="xml">&lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。 --&gt; 
&lt;dependencies&gt; 
  &lt;dependency&gt; 
    &lt;!-- 依赖的group ID --&gt; 
    &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; 

    &lt;!-- 依赖的artifact ID --&gt; 
    &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt; 

    &lt;!-- 依赖的版本号。 在 Maven 2 里，也可以配置成版本号的范围。 --&gt; 
    &lt;version&gt;3.8.1&lt;/version&gt; 

    &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展
                 名或分类器。类型经常和使用的打包方式对应，尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。
                 如果设置extensions为 true，就可以在plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt; 
    &lt;type&gt;jar&lt;/type&gt; 

    &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，
                 如果你想要构建两个单独的构件成JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生
                 成两个单独的JAR构件。 --&gt; 
    &lt;classifier&gt;&lt;/classifier&gt; 

    &lt;!-- 依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 
                - compile ：默认范围，用于编译 
                - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath 
                - runtime: 在执行时需要使用 
                - test: 用于test任务时使用 
                - system: 需要外在提供相应的元素。通过systemPath来取得 
                - systemPath: 仅用于范围为system。提供相应的路径 
                - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt; 
    &lt;scope&gt;test&lt;/scope&gt; 

    &lt;!-- 仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件
                 系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt; 
    &lt;systemPath&gt;&lt;/systemPath&gt; 

    &lt;!-- 当计算传递依赖时，从依赖构件列表里，列出被排除的依赖构件集。即告诉 Maven 你只依赖指定的项目，不依赖项目的
                 依赖。此元素主要用于解决版本冲突问题 --&gt; 
    &lt;exclusions&gt; 
      &lt;exclusion&gt; 
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt; 
        &lt;groupId&gt;org.springframework&lt;/groupId&gt; 
      &lt;/exclusion&gt; 
    &lt;/exclusions&gt; 

    &lt;!-- 可选依赖，如果你在项目 B 中把 C 依赖声明为可选，你就需要在依赖于 B 的项目（例如项目 A）中显式的引用对 C 的依赖。
                 可选依赖阻断依赖的传递性。 --&gt; 
    &lt;optional&gt;true&lt;/optional&gt; 
  &lt;/dependency&gt; 
&lt;/dependencies&gt;
</code></pre>
<h1 id="仓库配置"><a href="#仓库配置" class="headerlink" title="仓库配置"></a>仓库配置</h1><pre><code class="xml">&lt;!-- 发现依赖和扩展的远程仓库列表。 --&gt; 
&lt;repositories&gt; 
  &lt;!-- 包含需要连接到远程仓库的信息 --&gt; 
  &lt;repository&gt; 
    &lt;!-- 如何处理远程仓库里发布版本的下载 --&gt; 
    &lt;releases&gt; 
      &lt;!-- true 或者 false 表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; 
      &lt;enabled&gt;&lt;enabled&gt; 

      &lt;!-- 该元素指定更新发生的频率。Maven 会比较本地 POM 和远程 POM 的时间戳。
             这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; 
      &lt;updatePolicy&gt;&lt;/updatePolicy&gt; 

        &lt;!-- 当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt; 
      &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; 
    &lt;/releases&gt; 

    &lt;!-- 如何处理远程仓库里快照版本的下载。有了 releases 和 snapshots 这两组配置，POM 就可以在每个单独的仓库中，
         为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。 --&gt; 
    &lt;snapshots&gt; 
      &lt;enabled&gt;&lt;enabled&gt;
      &lt;updatePolicy&gt;&lt;/updatePolicy&gt;
      &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; 
    &lt;/snapshots&gt; 

    &lt;!-- 远程仓库唯一标识符。可以用来匹配在 settings.xml 文件里配置的远程仓库 --&gt; 
    &lt;id&gt;banseon-repository-proxy&lt;/id&gt; 

    &lt;!-- 远程仓库名称 --&gt; 
    &lt;name&gt;banseon-repository-proxy&lt;/name&gt; 

    &lt;!-- 远程仓库 URL，按 protocol://hostname/path 形式 --&gt; 
    &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt; 

    &lt;!-- 用于定位和排序构件的仓库布局类型-可以是 default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认
         的布局；然而，Maven 1.x 有一种不同的布局。我们可以使用该元素指定布局是 default（默认）还是 legacy（遗留）。 --&gt; 
    &lt;layout&gt; default &lt;/layout&gt; 
  &lt;/repository&gt; 
&lt;/repositories&gt;
</code></pre>
<h1 id="项目的聚合（Aggregator）"><a href="#项目的聚合（Aggregator）" class="headerlink" title="项目的聚合（Aggregator）"></a>项目的聚合（Aggregator）</h1><p>在实习的时候，发现公司的项目不是单单的一个模块，而是由四个小模块组合而成，最后所有的模块由一个总的pom文件进行管理，当时看的一脸懵逼，其实这就是使用的maven的工程聚合的功能，具体的目录结构如下：</p>
<pre><code class="java">|
|\
|  module1
|     \
|      pom.xml
|\
| module2
|    \
|     pom.xml
|\
| module3
|    \
|     pom.xml
|\pom.xml
</code></pre>
<p>在项目中有一个工程仅仅用来聚合其他的工程，所以该maven工程没有常规的src等目录，只有一个pom.xml文件，当对聚合工程执行maven命令时，会对所有聚合的工程都执行该命令，起到项目总体管理的目的。</p>
<p>工程聚合和工程继承很相似，但不是从子模块指定父POM，而是从父POM指定子模块。这样做的话，父工程就知道子模块的存在了，而且如果Maven命令从父工程调用，在子模块中也能顺利执行。工程聚合要求如下做法：</p>
<ol>
<li>将父POM的packageing属性设为”pom”</li>
<li>在父POM中指定模块的目录(子POM)</li>
</ol>
<p>在聚合项目的pom.xml中，具体的示例如下：</p>
<pre><code class="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;
  &lt;artifactId&gt;my-app&lt;/artifactId&gt;
  &lt;version&gt;1&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;name&gt;项目描述&lt;/name&gt;
 
  &lt;modules&gt;
    &lt;module&gt;module1&lt;/module&gt;
    &lt;module&gt;../module2&lt;/module&gt;
    &lt;!--标签的数据为相对路径，module2与聚合项目为平行目录--&gt;
  &lt;/modules&gt;
&lt;/project&gt;
</code></pre>
<p>modules标签指定一个或多个子模块的文件夹的相对路径。这样，如果在顶级目录执行的mvn命令，那么在子模块中也会被执行相同的命令。</p>
<h1 id="项目的继承（Extend）"><a href="#项目的继承（Extend）" class="headerlink" title="项目的继承（Extend）"></a>项目的继承（Extend）</h1><p>maven项目中，如果多个子模块中都引用了相同的依赖，势必会有许许多多的重复性的代码，而且如果每个模块申明的依赖版本不一样，那么就会导致许多奇怪的问题，maven中一个解决方法是将公共的依赖申明到父类的pom中，如果需要则从父类的pom文件中引用。</p>
<p>想要使用到工程的继承，只需要在子工程的pom文件中使用parent标签申明父类的pom就可以引用到父类的pom文件,具体步骤如下所示：</p>
<ul>
<li>在所有子POM中指定它们的父POM。</li>
<li>将父POM的packaging元素的值设为”pom”。</li>
<li>在父POM中指定子模块(子POM)的目录。</li>
</ul>
<p>在子类的pom中需要如下配置：</p>
<pre><code class="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;
    &lt;artifactId&gt;my-app&lt;/artifactId&gt;
    &lt;version&gt;1&lt;/version&gt;
    &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt;
  &lt;/parent&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;artifactId&gt;my-module&lt;/artifactId&gt;
&lt;/project&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
    ...
   &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>relativePath指定了父类pom的相对路径，其默认的路径为../pom.xml，所以如果是默认路径则不需要指定relativePath标签。</p>
<p>如上面所看到的的，如果需要指定子模块的version和父模块的version相同，则只需要在子模块的pom文件中，<strong>去除本项目的groupId和version即可</strong>，这样子模块的version就继承了父模块的version。</p>
<p>上述pom文件中申明的依赖和插件都会被所有子模块所继承，这会导致不需要该依赖的模块也会继承这些依赖和插件。为了子模块更灵活的继承父类的模块和依赖，需要使用更灵活的方法。</p>
<h1 id="使用dependencyManagement和pluginManagement"><a href="#使用dependencyManagement和pluginManagement" class="headerlink" title="使用dependencyManagement和pluginManagement"></a>使用dependencyManagement和pluginManagement</h1><p>使用dependencyManagement和pluginManagement标签包含的依赖和plugin不会被主动的继承，如果子pom文件中显示的申明了和父类pom中相同坐标的依赖或者插件，该依赖和插件才会被继承到子pom中。具体用法如下所示：</p>
<pre><code class="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;
  &lt;artifactId&gt;my-app&lt;/artifactId&gt;
  &lt;version&gt;1&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;name&gt;项目描述&lt;/name&gt;
 
  &lt;modules&gt;
    &lt;module&gt;module1&lt;/module&gt;
    &lt;module&gt;../module2&lt;/module&gt;
    &lt;!--标签的数据为相对路径，module2与聚合项目为平行目录--&gt;
  &lt;/modules&gt;
  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
    &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot&lt;/artifactId&gt;
    &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-test&lt;/artifactId&gt;
    &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-test-autoconfigure&lt;/artifactId&gt;
    &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;/dependencyManagement&gt;
    &lt;build&gt;
    &lt;pluginManagement&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
          &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;
          &lt;version&gt;$&#123;kotlin.version&#125;&lt;/version&gt;
          &lt;executions&gt;
            &lt;execution&gt;
              &lt;id&gt;compile&lt;/id&gt;
              &lt;phase&gt;compile&lt;/phase&gt;
              &lt;goals&gt;
                &lt;goal&gt;compile&lt;/goal&gt;
              &lt;/goals&gt;
            &lt;/execution&gt;
            &lt;execution&gt;
              &lt;id&gt;test-compile&lt;/id&gt;
              &lt;phase&gt;test-compile&lt;/phase&gt;
              &lt;goals&gt;
                &lt;goal&gt;test-compile&lt;/goal&gt;
              &lt;/goals&gt;
            &lt;/execution&gt;
          &lt;/executions&gt;
          &lt;configuration&gt;
            &lt;jvmTarget&gt;$&#123;java.version&#125;&lt;/jvmTarget&gt;
            &lt;javaParameters&gt;true&lt;/javaParameters&gt;
          &lt;/configuration&gt;
        &lt;/plugin&gt;
        &lt;/pluginManagement&gt;
   &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<p>在子pom中只需要声明父类相同坐标的依赖，不需要声明版本，就能继承父类pom的依赖和插件，而那些在子pom文件中未申明的依赖和插件则不会被继承：</p>
<pre><code class="xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h1 id="maven反应堆构建顺序"><a href="#maven反应堆构建顺序" class="headerlink" title="maven反应堆构建顺序"></a>maven反应堆构建顺序</h1><p>反应堆指的是maven中所有模块构成的一个体系，反应堆的构建顺序如下：</p>
<pre><code class="text">聚合模块-&gt;父类模块-&gt;子模块1-&gt;子模块2-&gt;...
</code></pre>
<h1 id="maven中的变量"><a href="#maven中的变量" class="headerlink" title="maven中的变量"></a>maven中的变量</h1><p>Maven鼓励的做法是不要做重复的工作(don’t repeat yourself)。但总有在不同的地方使用相同属性的情况。为了确保属性值指定一次，Maven允许你在POM使用你自己的变量或者预先定义的变量。</p>
<p>maven中有两种变量，一种为用户自定义类型的变量，一种是工程的变量，包含了整个工程的详细信息。</p>
<h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><p>在pom文件中，使用properties标签可以自定义一个或者多个属性</p>
<pre><code class="xml">&lt;properties&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
&lt;/properties&gt;
</code></pre>
<p>在项目中，可以使用<code>$&#123;java.version&#125;</code>来引用自定义的属性。</p>
<pre><code class="xml">&lt;plugin&gt;
&lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
&lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;
&lt;version&gt;$&#123;kotlin.version&#125;&lt;/version&gt;
&lt;executions&gt;
    &lt;execution&gt;
        &lt;id&gt;compile&lt;/id&gt;
        &lt;phase&gt;compile&lt;/phase&gt;
        &lt;goals&gt;
            &lt;goal&gt;compile&lt;/goal&gt;
        &lt;/goals&gt;
    &lt;/execution&gt;
    &lt;execution&gt;
        &lt;id&gt;test-compile&lt;/id&gt;
        &lt;phase&gt;test-compile&lt;/phase&gt;
        &lt;goals&gt;
            &lt;goal&gt;test-compile&lt;/goal&gt;
        &lt;/goals&gt;
    &lt;/execution&gt;
&lt;/executions&gt;
&lt;configuration&gt;
    &lt;jvmTarget&gt;$&#123;java.version&#125;&lt;/jvmTarget&gt;&lt;!--引用自定义属性--&gt;
    &lt;javaParameters&gt;true&lt;/javaParameters&gt;
&lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<p>要注意的是这些变量在继承之后才会被处理。这意味着如果一个父工程使用了一个变量，它们在子工程中的定义与在父工程中的定义会不一样，是最后使用的那个。<strong>即，从父pom中继承的属性会被自定义的属性覆盖</strong></p>
<h2 id="工程变量"><a href="#工程变量" class="headerlink" title="工程变量"></a>工程变量</h2><p>一个Model的任何字段都是一个单独的可以做为变量引用的值元素。例如，<code>$&#123;project.groupId&#125;</code>, <code>$&#123;project.version&#125;</code>,<code>$&#123;project.build.sourceDirectory&#125;</code>等等。参考POM reference 列举的全部属性。这些变量都用”project”前缀来引用。你可以看看pom references. 作为前缀，或者完全省略前缀 – 这些形式现在已经废弃不再使用了。</p>
<h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><table>
<thead>
<tr>
<th>变量</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>project.basedir</td>
<td>当前工程所在的目录</td>
</tr>
<tr>
<td>project.baseUri</td>
<td>当前工程所在的目录，表示为一个URI，Maven 2.1.0之后</td>
</tr>
<tr>
<td>maven.build.timestamp</td>
<td>时间戳，表示开始构建的时间，Maven 2.1.0-M1之后</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/04/13/CentOS%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%89%E8%A3%85rpm%E5%8C%85%E7%9A%84MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/13/CentOS%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%89%E8%A3%85rpm%E5%8C%85%E7%9A%84MySQL/" class="post-title-link" itemprop="url">CentOS系统下安装rpm格式的MySQL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-13 09:45:00" itemprop="dateCreated datePublished" datetime="2019-04-13T09:45:00+08:00">2019-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:10" itemprop="dateModified" datetime="2021-02-23T21:00:10+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Database/" itemprop="url" rel="index"><span itemprop="name">Database</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/13/CentOS%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%89%E8%A3%85rpm%E5%8C%85%E7%9A%84MySQL/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/13/CentOS%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%89%E8%A3%85rpm%E5%8C%85%E7%9A%84MySQL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>通过<a target="_blank" rel="noopener" href="https://dev.mysql.com/downloads/mysql/">官网</a>我们可以通过各种方式安装MySQL,但是如果通过官方下载的镜像安装时，由于网络的问题，会链接不到镜像，所以可以通过下载rpm格式的安装包，然后通过rpm命令去安装MySQL。</p>
<h1 id="下载rpm的安装包"><a href="#下载rpm的安装包" class="headerlink" title="下载rpm的安装包"></a>下载rpm的安装包</h1><p>可以通过<a target="_blank" rel="noopener" href="https://dev.mysql.com/downloads/mysql/">官网</a>去下载RedHat对应版本的tar压缩包，需要注意的是如果CentOS上没有MySQL组件或者版本不对，则需要下载RPM Bundle包，里面有MySQL的所有组件。</p>
<h1 id="解压tar文件"><a href="#解压tar文件" class="headerlink" title="解压tar文件"></a>解压tar文件</h1><p>下载之后会有一个.tar格式的压缩包，使用<code>tar -xvf 压缩包名</code>去解压，需要注意是**.tar格式和.tar.gz格式解压和压缩区别是不带-z参数。<strong>解压之后会得到以下文件（第一个文件不是的，截图手抖多截了一个QAQ）：<br><img src="https://s2.ax1x.com/2019/04/12/AbFghQ.png" alt="AbFghQ.png"><br>然后依次安装</strong>common-&gt;libs-&gt;client-&gt;server**，安装顺序不能错哦。</p>
<h1 id="使用rpm命令安装MySQL组件-参考文章"><a href="#使用rpm命令安装MySQL组件-参考文章" class="headerlink" title="使用rpm命令安装MySQL组件(参考文章)"></a>使用rpm命令安装MySQL组件(<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zqwang0929/p/3352237.html">参考文章</a>)</h1><p>rpm安装命令：</p>
<pre><code class="bash">rpm -i example.rpm    #安装 example.rpm 包；
rpm -iv example.rpm   #安装 example.rpm 包并在安装过程中显示正在安装的文件信息；
rpm -ivh example.rpm  #安装 example.rpm 包并在安装过程中显示正在安装的文件信息及安装进度
</code></pre>
<p>rpm卸载命令：</p>
<pre><code class="bash"> # rpm -e example
</code></pre>
<p>如果出现：</p>
<pre><code class="bash">error: Failed dependencies:
    mysql-community-client(x86-64) &gt;= 5.7.9 is needed by mysql-community-server-5.7.25-1.el7.x86_64
    mysql-community-common(x86-64) = 5.7.25-1.el7 is needed by mysql-community-server-5.7.25-1.el7.x86_64
    mariadb-server is obsoleted by mysql-community-server-5.7.25-1.el7.x86_64
</code></pre>
<p>则表明组件的安装顺序有问题。</p>
<p>如果出现：</p>
<pre><code class="bash">Preparing...                          ################################# [100%]
    file /usr/share/mysql/czech/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/danish/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/dutch/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/english/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/estonian/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/french/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/german/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/greek/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/hungarian/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/italian/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/japanese/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/korean/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
</code></pre>
<p>这是因为安装的rpm包和系统已有的组件冲突了，可以通过如下方式删除系统中的组件：<br>首先使用yum查看系统的MySQL组件：</p>
<pre><code>yum list installed | grep &quot;mysql&quot;
</code></pre>
<p>然后如果已经安装的MySQL组件和想要安装的组件有冲突，就删除它们吧：</p>
<pre><code>yum -y remove 想要删除的组件名
</code></pre>
<p>删除之后再使用rpm安装就ok了。</p>
<h1 id="启动并设置密码（参考文章）"><a href="#启动并设置密码（参考文章）" class="headerlink" title="启动并设置密码（参考文章）"></a>启动并设置密码（<a target="_blank" rel="noopener" href="https://blog.csdn.net/hello_world_qwp/article/details/79551789">参考文章</a>）</h1><p>启动MySQL并查看运行状态:</p>
<pre><code class="bash">sudo service mysqld start;#启动
sudo service mysqld status;#查看是否运行
</code></pre>
<p>因为安装时会给root设置一个默认密码，可以通过如下方式查看保存在log文件中的密码：</p>
<pre><code class="bash">sudo grep &#39;temporary password&#39; /var/log/mysqld.log
</code></pre>
<p>然后使用这个密码登陆MySQL：</p>
<pre><code class="sql">mysql -uroot -p
</code></pre>
<p>修改密码可以使用如下命令：</p>
<pre><code class="sql"> ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;NewPassword&#39;;#方式一
 SET password=password(&#39;NewPassword&#39;);
</code></pre>
<p>设置密码时，如果密码太简单，会因为MySQL密码的安全策略而报错,可以通过如下命令修改安全策略：</p>
<pre><code class="sql">SHOW VARIABLES LIKE &#39;validate_password%&#39;; #查看系统安全策略
set global validate_password_policy=LOW; #设置密码的验证强度等级为低，就只会检查密码长度
set global validate_password_length=6; #设置密码长度为6，默认长度为8
</code></pre>
<p>MySQL安全各策略字段含义如下：</p>
<ul>
<li>validate_password_length  固定密码的总长度；</li>
<li>validate_password_dictionary_file 指定密码验证的文件路径；</li>
<li>validate_password_mixed_case_count  整个密码中至少要包含大/小写字母的总个数；</li>
<li>validate_password_number_count  整个密码中至少要包含阿拉伯数字的个数；</li>
<li>validate_password_policy 指定密码的强度验证等级，默认为 MEDIUM；</li>
<li>validate_password_special_char_count 整个密码中至少要包含特殊字符的个数；</li>
</ul>
<p>关于 validate_password_policy 的取值：<br>    0/LOW：只验证长度；<br>    1/MEDIUM：验证长度、数字、大小写、特殊字符；<br>    2/STRONG：验证长度、数字、大小写、特殊字符、字典文件；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/03/27/Sping-Data-JPA%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/27/Sping-Data-JPA%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">Sping Data JPA入门学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-27 19:23:00" itemprop="dateCreated datePublished" datetime="2019-03-27T19:23:00+08:00">2019-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:10" itemprop="dateModified" datetime="2021-02-23T21:00:10+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/03/27/Sping-Data-JPA%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/27/Sping-Data-JPA%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://ityouknow.gitbooks.io/spring-data-jpa-reference-documentation/content/Working-with-Spring-Data-Repositories/spring-data-repositories.html">Spring Data JPA的官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/opensource/os-cn-spring-jpa/index.html">IMB Develop 博客</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ccwm0129/article/details/80663151">CSDN博客</a></li>
</ul>
<p>目前的公司的项目需要用到Spring Data JPA，记得刚开始看的时候感觉一脸懵逼，后来稍微看懂了以后感觉项目中如果业务逻辑比较简单的话，使用JPA比Mybatis更省事省力，它不需要使用JDBC中的那套麻烦的API，甚至也不需要写Mybatis那样的映射，定义好接口就可以直接用，感觉非常神奇，好好学习一下，今天下雨，就不加班了吧。</p>
<p>2019.3.28，我配这个花了差不多两天的时间，各种jar包不兼容，缺这里少哪里，我都感觉快得抑郁症了，真滴痛苦，好在最后好点了，非常感谢参考的文章的博主以及《Spring In Action》的作者，给了我黑暗的人生一点阳光。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/AwJlIf"><img src="https://s2.ax1x.com/2019/03/28/AwJlIf.png" alt="AwJlIf.png"></a></p>
<p>最后的图片是很久以前在豆瓣看的一只飞机耳的猫，有点阔爱。</p>
<h1 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h1><p>对数据库的一切操作的第一步是数据源（DataSource），学习Mybatis的时候应也是得先配置数据源，Spirng中有三种数据源：</p>
<ul>
<li>通过JDBC驱动程序定义的数据源</li>
<li>JNDI查找的数据源（测试环境推荐）</li>
<li>基于连接池的数据源（生产环境推荐）</li>
</ul>
<p>在配置数据源之前，需要添加MySQL驱动的jar:</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>jar包的版本很重要，有时候版本不兼容是很麻烦的。</p>
<h2 id="配置JDBC驱动程序定义的数据源"><a href="#配置JDBC驱动程序定义的数据源" class="headerlink" title="配置JDBC驱动程序定义的数据源"></a>配置JDBC驱动程序定义的数据源</h2><p>不支持池化的链接，推荐开发时使用。</p>
<h2 id="配置JNDI数据源"><a href="#配置JNDI数据源" class="headerlink" title="配置JNDI数据源"></a>配置JNDI数据源</h2><p>可以在应用之外对数据源进行控制。</p>
<h2 id="配置连接池的数据源"><a href="#配置连接池的数据源" class="headerlink" title="配置连接池的数据源"></a>配置连接池的数据源</h2><p>重点记录一下基于连接池的数据源，生产环境推荐使用，性能更好。连接池有一下三种实现方式：</p>
<ul>
<li>Apache Commons DBCP</li>
<li>c3p0</li>
<li>BoneCP</li>
</ul>
<p>记录一下第一种配置DataSource的方式，其他的方式类似，首先导入需要的jar包：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;
    &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;
    &lt;version&gt;1.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后通过xml文件配置的方式：</p>
<pre><code class="xml">&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/spring_data_jpa?
        characterEncoding=utf8&amp;amp;userSSL=false&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
        &lt;property name=&quot;initialSize&quot; value=&quot;10&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>或者可以通过注解的方式获得一个bean：</p>
<pre><code class="java">    @Bean
    public DataSource dataSource()&#123;
        BasicDataSource dataSource=new BasicDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://127.0.0.1:3306/spring_data_jpa?
        characterEncoding=utf8&amp;amp;userSSL=false&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;123456&quot;);
    &#125;
</code></pre>
<p>也可以在.properties后缀的文件中写入配置项，然后使用<code>$&#123;配置项名称&#125;</code>的方式在xml文件中引用配置项，如下是在jdbcConfiguration.properties文件中定义jdbc配置项：</p>
<pre><code class="txt">jdbcConfiguration.properties
jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/springdata?useSSL=false&amp;characterEncoding=utf-8
jdbc.username=root
jdbc.password=123456
</code></pre>
<p><strong>这里需要注意的是，在properties文件中<code>&amp;</code>不需要转译成<code>&amp;amp;</code>，否则所有中文会变成???，而在xml文件中配置时则需要转译成<code>&amp;amp;</code></strong></p>
<p>对DataSource进行测试：</p>
<pre><code class="java">import org.apache.commons.dbcp.BasicDataSource;
import org.junit.jupiter.api.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;

public class DataSourceTest &#123;
    private ApplicationContext context;
    private Connection con;

    @Test
    public void testDataSource() &#123;
        context = new ClassPathXmlApplicationContext(&quot;WEB-INF/applicationContext.xml&quot;);
        DataSource dataSource = context.getBean(DataSource.class);
        try &#123;
            con = dataSource.getConnection();
            System.out.println(con);
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            try &#123;
                if (con != null)
                    con.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

&#125;

output:
jdbc:mysql://127.0.0.1:3306/spring_data_jpa?characterEncoding=utf8&amp;userSSL=false
,UserName=root@localhost, MySQL-AB JDBC Driver
</code></pre>
<h1 id="配置实体管理器（EntityManager）"><a href="#配置实体管理器（EntityManager）" class="headerlink" title="配置实体管理器（EntityManager）"></a>配置实体管理器（EntityManager）</h1><p>实体管理器是负责管理Entity的对象。对Entity的操作包括添加、删除、修改和查询，都是通过实体管理器来实现的。使用JPA的第一个步骤就是配置一下EntityManager，而EntityManager都是通过EntityManagerFactory得到的，JPA定义了两种类型的实体管理器：</p>
<ul>
<li><p>应用程序类型管理器<br>适用于不是运行在JavaEE容器中的独立应用程序，用户需要对其进行打开、关闭、事物处理等控制，配置比较繁琐。由<code>LocalEntityManagerFactoryBean</code>生成对应的<code>EntityManager</code>。</p>
</li>
<li><p>容器类型管理器<br>由JavaEE负责创建和管理，适合JaveEE容器，配置比应用程序管理器简单很多。由<code>LocalContinerManagerFactoryBean</code>生成对应的<code>EntityManager</code>。</p>
</li>
</ul>
<p>两种配置方式没有什么大的区别，Spring都会负责管理两种EntityManager。如何配置两种EntityManager对Spring应用程序来说是透明的，你只需要把注意力放在如何处理业务逻辑上，数据访问的细节被隐藏起来了。            </p>
<p>JpaVenderAdapter类是JPA的具体实现类，有四种JPA实现厂商：</p>
<ul>
<li>EclipseLinkJpaVenderAdapter</li>
<li>HibernateJpaVneterAdapter</li>
<li>OpenJpaVneterAdapter</li>
<li>TopLinkJpaVneterAdapter</li>
</ul>
<p>在applicatinContext.xml文件中进行配置：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd 
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/data/jpa
       http://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;&gt;

    &lt;!--引入jdbc配置文件--&gt;
    &lt;context:property-placeholder location=&quot;jdbcConfiguration.properties&quot;/&gt;

   &lt;!--使用jpa命名空间开启Repository接口自动扫描--&gt;
    &lt;jpa:repositories base-package=&quot;com.spring.model&quot;/&gt;

    &lt;!--配置数据源--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; &gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--配置Jpa实现供应商--&gt;
    &lt;bean id=&quot;jpaVendorAdapter&quot; class=&quot;org.springframework.orm.jpa.vendor
    .HibernateJpaVendorAdapter&quot;&gt;
        &lt;property name=&quot;database&quot; value=&quot;MYSQL&quot; /&gt;
        &lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot; /&gt;
        &lt;property name=&quot;showSql&quot; value=&quot;false&quot; /&gt;
        &lt;property name=&quot;generateDdl&quot; value=&quot;false&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--配置实体管理器工厂--&gt;
    &lt;bean id=&quot;entityManagerFactory&quot; 
    class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;property name=&quot;jpaVendorAdapter&quot; ref=&quot;jpaVendorAdapter&quot; /&gt;
        &lt;property name=&quot;packagesToScan&quot; value=&quot;com.spring.model&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--配置事务管理器--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<h1 id="继承接口继承Repository接口"><a href="#继承接口继承Repository接口" class="headerlink" title="继承接口继承Repository接口"></a>继承接口继承Repository接口</h1><h2 id="Repository接口"><a href="#Repository接口" class="headerlink" title="Repository接口"></a>Repository接口</h2><p>Repository是一个标记接口，所有继承（或者间接继承）了这个接口的接口都会被Spring自动扫描到，然后自动创建这个接口的实现类。<br>如果用户只需要定义自己特有的方法，而不使用CrudRepository接口中自带的方法，则只需要继承Repository接口：</p>
<pre><code class="java">interface PersonRepository extends Repository&lt;Person, Long&gt; &#123;
  List&lt;Person&gt; findByLastname(String lastname);
&#125;
</code></pre>
<p>也可以使用下面的这种方式：</p>
<pre><code class="java">@RepositoryDefinition(domainClass = AccountInfo.class, idClass = Long.class) 
public interface UserDao &#123; …… &#125;
</code></pre>
<h2 id="CrudRepository接口"><a href="#CrudRepository接口" class="headerlink" title="CrudRepository接口"></a>CrudRepository接口</h2><p>以下部分内容来自Spring Data JPA的<a target="_blank" rel="noopener" href="https://ityouknow.gitbooks.io/spring-data-jpa-reference-documentation/content/Working-with-Spring-Data-Repositories/spring-data-repositories.html">官方文档</a>以及<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/opensource/os-cn-spring-jpa/index.html">IBM Develop的大神</a>的文章。</p>
<p>Spring Data库的核心接口是<code>Repository</code>。它使用domain类去管理，domain类中的id类型作为类型参数。这个接口主要作为一个标记接口(没有任何方法)，依靠具体的类型运作并帮助您发现接口，CrudRepository 提供丰富的CRUD功能去管理实体类。</p>
<pre><code class="java">import java.io.Serializable;

@NoRepositoryBean
public interface CrudRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; &#123;
    &lt;S extends T&gt; S save(S var1);

    &lt;S extends T&gt; Iterable&lt;S&gt; save(Iterable&lt;S&gt; var1);

    T findOne(ID var1);

    boolean exists(ID var1);

    Iterable&lt;T&gt; findAll();

    Iterable&lt;T&gt; findAll(Iterable&lt;ID&gt; var1);

    long count();

    void delete(ID var1);

    void delete(T var1);

    void delete(Iterable&lt;? extends T&gt; var1);

    void deleteAll();
&#125;
</code></pre>
<p>有@NoRepositoryBean注解的接口Spring不会为其创建实现类。两个接口的中间接口一般需要使用@NoRepositoryBean注解。<br>通过CrudRepository类的定义可以看到，CrudRepository类定义了11种对数据库操作的常用方法。</p>
<p><strong>如果持久层接口较多，且每一个接口都需要声明相似的增删改查方法，直接继承 Repository 就显得有些啰嗦，这时可以继承 CrudRepository，它会自动为域对象创建增删改查方法，供业务层直接使用。开发者只是多写了 “Crud” 四个字母，即刻便为域对象提供了开箱即用的十个增删改查方法。</strong></p>
<p>**但是，使用 CrudRepository 也有副作用，它可能暴露了你不希望暴露给业务层的方法。比如某些接口你只希望提供增加的操作而不希望提供删除的方法。针对这种情况，开发者只能退回到 Repository 接口，然后到 CrudRepository 中把希望保留的方法声明复制到自定义的接口中即可。 **</p>
<p>用户可以定义一个接口继承CrudRepository类来定义访问数据库的方法，当然也可以使用CrudRepository接口中自带的方法：</p>
<pre><code class="java">public interface UserRepository extends CrudRepository&lt;User, Long&gt; &#123;

  //查询并统计
  Long countByLastname(String lastname);
  
  //查询并删除
  Long deleteByLastname(String lastname);
  List&lt;User&gt; removeByLastname(String lastname);
&#125;
</code></pre>
<h2 id="PagingAndSortingRepository接口"><a href="#PagingAndSortingRepository接口" class="headerlink" title="PagingAndSortingRepository接口"></a>PagingAndSortingRepository接口</h2><p><code>CrudRepository</code>有一个<code>PagingAndSortingRepository</code> 抽象,增加了额外的方法来简化对实体的分页访问:</p>
<pre><code class="java">public interface PagingAndSortingRepository&lt;T, ID extends Serializable&gt;
  extends CrudRepository&lt;T, ID&gt; &#123;

  Iterable&lt;T&gt; findAll(Sort sort);

  Page&lt;T&gt; findAll(Pageable pageable);
&#125;
</code></pre>
<p>进入用户类别的第二页（每一页的条目是20），可以照下面这样来分页</p>
<pre><code class="java">PagingAndSortingRepository&lt;User, Long&gt; repository = // … get access to a bean
Page&lt;User&gt; users = repository.findAll(new PageRequest(1, 20));
</code></pre>
<h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p><strong>上述四个接口，开发者到底该如何选择？其实依据很简单，根据具体的业务需求，选择其中之一。笔者建议在通常情况下优先选择 Repository 接口。因为 Repository 接口已经能满足日常需求，其他接口能做到的在 Repository 中也能做到，彼此之间并不存在功能强弱的问题。只是 Repository 需要显示声明需要的方法，而其他则可能已经提供了相关的方法，不需要再显式声明，但如果对 Spring Data JPA 不熟悉，别人在检视代码或者接手相关代码时会有疑惑，他们不明白为什么明明在持久层接口中声明了三个方法，而在业务层使用该接口时，却发现有七八个方法可用，从这个角度而言，应该优先考虑使用 Repository 接口。</strong></p>
<h2 id="为接口的方法声明自定义查询"><a href="#为接口的方法声明自定义查询" class="headerlink" title="为接口的方法声明自定义查询"></a>为接口的方法声明自定义查询</h2><p>方法名定义查询的规则：</p>
<ul>
<li>And — 等价于 SQL 中的 and 关键字，比如 findByUsernameAndPassword(String user, Striang pwd)；</li>
<li>Or — 等价于 SQL 中的 or 关键字，比如 findByUsernameOrAddress(String user, String addr)；</li>
<li>Between — 等价于 SQL 中的 between 关键字，比如 findBySalaryBetween(int max, int min)；</li>
<li>LessThan — 等价于 SQL 中的 “&lt;”，比如 findBySalaryLessThan(int max)；</li>
<li>GreaterThan — 等价于 SQL 中的”&gt;”，比如 findBySalaryGreaterThan(int min)；</li>
<li>IsNull — 等价于 SQL 中的 “is null”，比如 findByUsernameIsNull()；</li>
<li>IsNotNull — 等价于 SQL 中的 “is not null”，比如 findByUsernameIsNotNull()；</li>
<li>NotNull — 与 IsNotNull 等价；</li>
<li>Like — 等价于 SQL 中的 “like”，比如 findByUsernameLike(String user)；</li>
<li>NotLike — 等价于 SQL 中的 “not like”，比如 findByUsernameNotLike(String user)；</li>
<li>OrderBy — 等价于 SQL 中的 “order by”，比如 findByUsernameOrderBySalaryAsc(String user)；</li>
<li>Not — 等价于 SQL 中的 “！ =”，比如 findByUsernameNot(String user)；</li>
<li>In — 等价于 SQL 中的 “in”，比如 findByUsernameIn(Collection<String> userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；</li>
<li>NotIn — 等价于 SQL 中的 “not in”，比如 findByUsernameNotIn(Collection<String> userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；</li>
</ul>
<p>在使用方法名定义查询时，会有一些限制，比如方法名太长、想要的查询很难用方法名去表达时，我们可以通过@Query注解自定义查询：</p>
<pre><code class="java">
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;
    @Query(&quot;SELECT a FROM User AS a WHERE a.user_id= ?1&quot;)//指定SQL语句
    User findById(Long id);
&#125;
</code></pre>
<p><strong>需要注意的是，占位符？后面必须按顺序接上数字。同时FROM后面的表明需要为实体类名，具体的原因还没弄清楚，可能是JPQL的特定语法</strong></p>
<p>很多开发者在创建 JPQL 时喜欢使用命名参数来代替位置编号，@Query 也对此提供了支持。JPQL 语句中通过”: 变量”的格式来指定参数，同时在方法的参数前面使用 @Param 将方法参数与 JPQL 中的命名参数对应，示例如下：</p>
<pre><code class="java">public interface UserDao extends Repository&lt;AccountInfo, Long&gt; &#123;

    public AccountInfo save(AccountInfo accountInfo);

    @Query(&quot;from AccountInfo a where a.accountId = :id&quot;)
    public AccountInfo findByAccountId(@Param(&quot;id&quot;)Long accountId);

    @Query(&quot;from AccountInfo a where a.balance &gt; :balance&quot;)
    public Page&lt;AccountInfo&gt; findByBalanceGreaterThan(
            @Param(&quot;balance&quot;)Integer balance,Pageable pageable);
&#125;
</code></pre>
<p>此外，开发者也可以通过使用 @Query 来执行一个更新操作，为此，我们需要在使用 @Query 的同时，用 @Modifying 来将该操作标识为修改查询，这样框架最终会生成一个更新的操作，而非查询。如下所示：</p>
<pre><code class="java">@Modifying 
@Query(&quot;update AccountInfo a set a.salary = ?1 where a.salary &lt; ?2&quot;) 
public int increaseSalary(int after, int before);//返回值必须为void、Integer/int
</code></pre>
<h2 id="定义实体类（Entity）"><a href="#定义实体类（Entity）" class="headerlink" title="定义实体类（Entity）"></a>定义实体类（Entity）</h2><p>对于接口中要使用到的实体类，需要使用以下方法定义：</p>
<pre><code class="java">import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity//声明一个实体类
@Table(name = &quot;user&quot;)//定义表名
public class User &#123;

    public User() &#123;
    &#125;

    @Id
    private Long user_id;

    private String user_name;
    private int user_age;
    private String user_addr;

    public User(Long user_id, String user_name, int user_age, String user_addr) &#123;
        this.user_id = user_id;
        this.user_name = user_name;
        this.user_age = user_age;
        this.user_addr = user_addr;
    &#125;

    public Long getUser_id() &#123;
        return user_id;
    &#125;

    setter/getter方法
&#125;
</code></pre>
<p>** 需要注意的是所有的POJO都要有默认构造器，因为反射需要有默认构造器。同时，在使用AutoIncrement时，需要在自增的属性上使用@GeneratedValue(strategy=GenerationType.IDENTITY) 或者添加注解：<code>&lt;property name=&quot;hibernate.id.new_generator_mappings&quot;&gt;false&lt;/property&gt;</code> **</p>
<p>可以在配置LocalContainerEntityManagerFactoryBean时，调用方法<code>setPackageToScan</code>来定义扫描Entity类的路径:</p>
<pre><code class="java">emf.setPackagesToScan(new String[]&#123;&quot;com.rick.entities&quot;&#125;);
</code></pre>
<h1 id="为这些接口创建代理实例"><a href="#为这些接口创建代理实例" class="headerlink" title="为这些接口创建代理实例"></a>为这些接口创建代理实例</h1><p>有了自定义的Repository接口，我们并不需要为这些接口提供实现类，我们只需要像配置<code>&lt;context:component-scan base-package=&quot;com.spring&quot; /&gt; </code>一样开启自动的Repository扫描，在<strong>启动</strong>时Spring就会扫描指定目录下的所有实现了Repository接口的接口，并自动为我们创建实现类，实现类的行为都是通过方法名实现的，专业名词叫做(领域特定语言)DSL，我也不懂是个啥，反正非常的炫酷。开启扫描有两种方式：<br>在xml中开启：</p>
<pre><code class="xml">&lt;jpa:repositories base-package=&quot;com.spring.model&quot;/&gt;
</code></pre>
<p>通过Java配置类开启：</p>
<pre><code class="java">import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@EnableJpaRepositories(&quot;com.acme.repositories&quot;)
class Config &#123;&#125;
</code></pre>
<h1 id="获得repository-实例注入并使用它。"><a href="#获得repository-实例注入并使用它。" class="headerlink" title="获得repository 实例注入并使用它。"></a>获得repository 实例注入并使用它。</h1><p>在需要对数据库进行操作的地方，直接注入一个repository，然后就可以调用我们定义的那些方法啦：</p>
<pre><code class="java">import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations= &quot;classpath:spring-config.xml&quot;)//得到xml配置文件
public class UserRepositoryIntegrationTest &#123;

    @Autowired
    UserRepository repository;//注入自定义的Repository接口

    @Test
    public void sampleTestCase() &#123;
        User result = repository.findById(10002l);
        User user=new User(10003l,&quot;caf&quot;,123,&quot;新洲蘑菇棒&quot;);
        repository.save(user);
        System.out.println(result);
        System.out.println(repository.count());
        System.out.println(repository.findById(10003l));
    &#125;
&#125;
</code></pre>
<h1 id="为接口中的部分方法提供自定义实现"><a href="#为接口中的部分方法提供自定义实现" class="headerlink" title="为接口中的部分方法提供自定义实现"></a>为接口中的部分方法提供自定义实现</h1><p>有些时候，开发者可能需要在某些方法中做一些特殊的处理，此时自动生成的代理对象不能完全满足要求。为了享受 Spring Data JPA 带给我们的便利，同时又能够为部分方法提供自定义实现，我们可以采用如下的方法：</p>
<ol>
<li>将需要开发者手动实现的方法从持久层接口（假设为 AccountDao ）中抽取出来，独立成一个新的接口（假设为 AccountDaoPlus ），并让 AccountDao 继承 AccountDaoPlus；<code>AccountDap extends CurdRepository&lt;User,long&gt;,AccountDaoPluse</code></li>
<li>为 AccountDaoPlus 提供自定义实现（默认为接口加上Impl,即为 AccountDaoPlusImpl ）； <code>AccountDaoPlusImple implements AccountDapPlus</code></li>
<li>将 AccountDaoPlusImpl 配置为 Spring Bean；</li>
<li>在业务层注入并使用AccountDaoPlus；</li>
</ol>
<h2 id="指定自定义实现类"><a href="#指定自定义实现类" class="headerlink" title="指定自定义实现类"></a>指定自定义实现类</h2><pre><code class="xml">&lt;jpa:repositories base-package=&quot;footmark.springdata.jpa.dao&quot;&gt; 
&lt;jpa:repository id=&quot;accountDao&quot; repository-impl-ref=&quot; accountDaoPlus &quot; /&gt; 
&lt;/jpa:repositories&gt; 

&lt;bean id=&quot;accountDaoPlus&quot; class=&quot;.......&quot;/&gt;
</code></pre>
<p>此外，&lt;jpa:repositories &gt; 提供了一个 repository-impl-postfix 属性，用以指定实现类的后缀。例如如下配置：</p>
<pre><code class="xml">&lt;--指定自定义实现类为自定义接口名+Impl;--&gt;
&lt;jpa:repositories base-package=&quot;footmark.springdata.jpa.dao&quot;
repository-impl-postfix=&quot;Impl&quot;/&gt;
</code></pre>
<p>基于Java类的配置时做如下配置：</p>
<pre><code class="java">@EnableRepositories(
    base-packet=&quot;com.spring.model&quot;
    repositoryImplementationPostfix=&quot;Helper&quot;//指定自定义实现类为自定义接口名+Helper;
)
</code></pre>
<h1 id="启用Spring注解事务"><a href="#启用Spring注解事务" class="headerlink" title="启用Spring注解事务"></a>启用Spring注解事务</h1><p><strong>SpringDataJPA，中在插入修改删除等需要对数据进行修改的操作时需要使用事务，而查找操作则不需要使用事务</strong>要启用Spring的注解事务，需要做如下配置，关于事务我还没有认真学习过，清明节放假好好学习一下：</p>
<p>首先需要在配置文件中开启注解事务：</p>
<pre><code class="xml">&lt;!--开启注解事务--&gt;
&lt;jx:annotation-driven/&gt;
</code></pre>
<p>同时需要引入jx的命名空间<code>xmlns:jx=&quot;http://www.springframework.org/schema/tx&quot;</code>.</p>
<p>在开启注解事物之后，就可以使用<code>@Transactional</code>注解来使用事务了。<br><code>@Transactional</code>注解只能使用在public修饰的方法中，对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能，同时需要在业务层使用，而不能在DAO接口层。</p>
<p><strong>Spring团队的建议是你在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。你当然可以在接口上使用 @Transactional 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是 不能继承 的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）。因 此，请接受Spring团队的建议并且在具体的类上使用</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zheng0518/article/details/52214310">博客原文</a></p>
<p>业务层代码：</p>
<pre><code class="java">import javax.transaction.Transactional;

/**
 * 业务层，用于定义对User的常规操作
 */
public class UserOptService &#123;

    private UserRepository repository;

    public UserOptService(UserRepository repository) &#123;
        this.repository = repository;
    &#125;

    @Transactional
    public void updateUserAddr(long id, String addr)&#123;
        repository.updateUserAddr(id,addr);
    &#125;

    public User findByUserId(long id)&#123;
        return repository.findById(id);
    &#125;

    public User addUser(User user)&#123;
        return repository.save(user);
    &#125;
&#125;
</code></pre>
<p>在DAO层（也就是Repository接口），对涉及删除、修改、增加的方法添加@Modifying注解：</p>
<pre><code class="java">import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;
    @Query(&quot;SELECT a FROM User AS a WHERE a.user_id= ?1&quot;)
    User findById(Long id);

    @Modifying//增加的注解
    @Query(&quot;UPDATE User SET user_addr = :addr WHERE user_id= :id&quot;)
    void updateUserAddr(@Param(&quot;id&quot;) Long id, @Param(&quot;addr&quot;) String addr);
&#125;
</code></pre>
<p>测试事务是否能正常运行：</p>
<pre><code class="java">import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations= &quot;classpath:spring-config.xml&quot;)
public class UserRepositoryIntegrationTest &#123;

    @Autowired
    UserOptService service;

    @Test
    public void sampleTestCase() &#123;
        User result = service.findByUserId(10002l);
        System.out.println(result);
        User user=new User(&quot;caf&quot;,134,&quot;新洲蘑菇棒&quot;);
        service.addUser(user);


        String addr=&quot;美丽繁华的魔都嗯嗯嗯！&quot;;
        service.updateUserAddr(10001l,addr);//可以成功修改
        service.updateUserAddr(100011l,addr);//使用错误的ID，不能成功修改
        System.out.println(service.findByUserId(10001l));
    &#125;
&#125;
</code></pre>
<p>在测试类中，使用正确的ID可以插入，而使用错误的ID则无法插入。(发生异常，数据回滚)</p>
<hr>
<p><img src="https://s2.ax1x.com/2019/03/27/Ade71f.png" alt="Ade71f.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/03/21/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8Multipart%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/21/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8Multipart%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">Spring中使用Multipart上传文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-21 22:10:00" itemprop="dateCreated datePublished" datetime="2019-03-21T22:10:00+08:00">2019-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:06" itemprop="dateModified" datetime="2021-02-23T21:00:06+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/03/21/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8Multipart%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/21/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8Multipart%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在web应用中，我们常常需要使用到文件上传功能，比如用户注册时需要上传用户自定义的头像，在聊天室需要发送聊天图片等等，这就需要使用到Multipart功能，要使用文件上传功能，前端的表单代码需要做一些小修改，同时后台Spring也需要添加对Multipart的解析器（Resolver）.</p>
<h1 id="前台代码的修改"><a href="#前台代码的修改" class="headerlink" title="前台代码的修改"></a>前台代码的修改</h1><p>当表单需呀使用到Multipart时，需要在form标签中加上enctype属性：</p>
<pre><code class="html">&lt;form method=&quot;POST&quot; action=&quot;http://localhost:8080/uploadImg&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;uploadImg&quot; accept=&quot;image/jpg,image/png&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot; &gt;
&lt;/form&gt;
</code></pre>
<p>需要注意的时上面的代码中的<code>enctype=&quot;multipart/form-data&quot;</code>,当使用此属性时，form表单会被拆分为多个part，包含文件的part中，存放的数据即为文件的二进制数据。<br>input标签中的<code>accept=&quot;image/jpg,image/png&quot;</code>属性指明了所需的文件类型。</p>
<h1 id="Spring中使用Multipart接收文件"><a href="#Spring中使用Multipart接收文件" class="headerlink" title="Spring中使用Multipart接收文件"></a>Spring中使用Multipart接收文件</h1><p>Spring中接收Multipart数据需要添加相应的解析器（Resolver）,Spring中主要有两种multipart解析器：</p>
<ul>
<li>StandardServletMultipartResovler 依赖于Servlet3.0对Multipart的支持，不需要依赖其他的包。</li>
<li>CommonsMultipartResolver 使用Jakarta Commons FileUpload解析multipart请求。</li>
</ul>
<p>如果需要把应用部署到Servlet3.0的容器中或者使用3.1之前的Spring版本，则需要使用CommonsMultipartResolver，否则，一般情况下我们使用StandardServletMultipartResovler。</p>
<h1 id="配置StandardServletMultipartResolver解析器"><a href="#配置StandardServletMultipartResolver解析器" class="headerlink" title="配置StandardServletMultipartResolver解析器"></a>配置StandardServletMultipartResolver解析器</h1><p>如果配置StandardServletMultipartResolver解析器，首先需要在WebConfig配置类中添加Bean。</p>
<pre><code class="java">@Bean
public MultipartResolver multipartResolver()&#123;
    return new StandardServletMultipartResolver();
&#125;
</code></pre>
<p>由于StandardServletMultipartResolver类没有属性和构造器参数，所以不能对其进行设置，我们需要重写AbstractAnnotationCongifDispatcherServlet类的customizeRegistration方法，在这个方法中去对StandardServletMultipartResolver进行设置：</p>
<pre><code class="java">@Override
protected void customizeRegistration(ServletRegistration.Dynamic registration) &#123;
    registration.setMultipartConfig(new MultipartConfigElement(&quot;E://avatar//&quot;,2097152,4194304,0));
&#125;
</code></pre>
<p>对于Multipart，我们一般需要配置一下几个参数：</p>
<ul>
<li>文件临时存放的路径<code>例如：&quot;E://avatar//&quot;</code></li>
<li>上传的文件的最大长度 <code>例如：2MB</code></li>
<li>整个请求的最大长度 <code>例如：4MB</code></li>
<li>上传过程中，如果文件大于某个数，则需要将其存入临时存放的路径中 <code>例如：0（即任何大小的文件都需要存到临时路径中）</code></li>
</ul>
<p>如果是基于web.xml的配置，则需要在DispatcherServlet的Servlet中添加<code>&lt;multipart-config&gt;</code>标签：</p>
<pre><code class="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;application&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.
    DispatcherServlet&lt;/servlet-class&gt;

    &lt;init-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;org.springframework.web.context.support.
        AnnotationConfigWebApplicationContext&lt;/param-value&gt;
    &lt;/init-param&gt;

    &lt;!--定义contextConfigLocation的初始化参数--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;com.spring.mvc.WebConfig&lt;/param-value&gt;
    &lt;/init-param&gt;

    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    
    &lt;multipart-config&gt;
        &lt;location&gt;E://avatar//&lt;/location&gt;
        &lt;max-file-size&gt;2097152&lt;/max-file-size&gt;
        &lt;max-request-size&gt;4194304&lt;/max-request-size&gt;
    &lt;/multipart-config&gt;

&lt;/servlet&gt;
</code></pre>
<h1 id="配置CommonsMultipartResolver解析器"><a href="#配置CommonsMultipartResolver解析器" class="headerlink" title="配置CommonsMultipartResolver解析器"></a>配置CommonsMultipartResolver解析器</h1><p>CommonsMultipartResolver可以作为StandardMultipartResolver的替代方案，配置CommonsMultipartResolver需要引入单独的jar包：</p>
<pre><code class="xml">&lt;dependency&gt;
      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
      &lt;artifactId&gt;com.springsource.org.apache.commons.fileupload&lt;/artifactId&gt;
      &lt;version&gt;1.2.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;commons-io&lt;/groupId&gt;
      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
      &lt;version&gt;2.5&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;  
</code></pre>
<p>然后在WebConfig.java中申明Bean:</p>
<pre><code class="java">@Bean
public MultipartResolver commonsMultipartResolver() throws IOException &#123;
    CommonsMultipartResolver resolver= new CommonsMultipartResolver();
    resolver.setUploadTempDir(new FileSystemResource(&quot;E://avatar//&quot;));
    resolver.setMaxUploadSize(2097152);
    resolver.setMaxInMemorySize(0);
    return resolver;
&#125;
</code></pre>
<p>与StandardMultipartRsolver不同的是，CommonsMultipartResolver可以在申明时直接配置参数，不过CommonsMultipartResolver类无法配置<code>整个请求的最大长度</code>这一参数。</p>
<h1 id="处理Multipart数据"><a href="#处理Multipart数据" class="headerlink" title="处理Multipart数据"></a>处理Multipart数据</h1><p>在Controller中，需要对Multipart进行写入处理：</p>
<pre><code class="java">import java.io.File;
import java.io.IOException;

import static org.springframework.web.bind.annotation.RequestMethod.POST;

@Controller
@RequestMapping(value = &quot;/uploadImg&quot;)
public class UploadImgController &#123;

    @RequestMapping(method = POST)
    public @ResponseBody LoginMsg uploadImg(@RequestParam(&quot;uploadImg&quot;)MultipartFile img
    ,User user) throws IOException &#123;
        System.out.println(&quot;UploadImgController has been visited&quot;);
        File f=new File(&quot;E://avatar//&quot;+img.getOriginalFilename());
        img.transferTo(f);
        String path=f.getAbsolutePath();
        return new LoginMsg(0,path);
    &#125;

&#125;
</code></pre>
<p>在处理表单对应的方法中，需要使用<code>@RequestParam</code>注解，并将前端的文件的标签的name属性作为参数传递进去，Spring会自动将其包装为MultipartFile对象，此对象包含了文件的所有信息：字节数组、文件名等，以及写入到磁盘的快捷方法<code>transferTo()</code>.<br>上面的方法中，还返回了代表成功失败的json对象，用于前端判断图片是否上传成功。同时，表单中的其他项则被包装到User类中。<br>同理，如果需要上传多个文件，则可以将参数设置为<code>@RequestParam(&quot;uploadImg&quot;)MultipartFile[] img</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/03/19/%E5%9F%BA%E4%BA%8EJava%E7%B1%BB%E9%85%8D%E7%BD%AE%E7%9A%84Spring%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89Servlet%E5%92%8CFilter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/19/%E5%9F%BA%E4%BA%8EJava%E7%B1%BB%E9%85%8D%E7%BD%AE%E7%9A%84Spring%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89Servlet%E5%92%8CFilter/" class="post-title-link" itemprop="url">基于Java类配置的SpringMVC中添加自定义Servlet和Filter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-19 21:59:00" itemprop="dateCreated datePublished" datetime="2019-03-19T21:59:00+08:00">2019-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:00" itemprop="dateModified" datetime="2021-02-23T21:00:00+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/03/19/%E5%9F%BA%E4%BA%8EJava%E7%B1%BB%E9%85%8D%E7%BD%AE%E7%9A%84Spring%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89Servlet%E5%92%8CFilter/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/19/%E5%9F%BA%E4%BA%8EJava%E7%B1%BB%E9%85%8D%E7%BD%AE%E7%9A%84Spring%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89Servlet%E5%92%8CFilter/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在基于Java类的Spring配置中，通过继承<code>AbstractAnnotationConfigDispatcherServletInitializer</code>类来初始化ContextLoadListener和DispatcherServlet,通过这种方式配置Spring时如何添加自定义的Servlet和Filter呢？比如解决跨域访问时，需要添加自定义的Filter去解决。</p>
<h1 id="重写AbstractAnnotationConfigDispatcherServletInitializer类的方法来添加Filter"><a href="#重写AbstractAnnotationConfigDispatcherServletInitializer类的方法来添加Filter" class="headerlink" title="重写AbstractAnnotationConfigDispatcherServletInitializer类的方法来添加Filter"></a>重写AbstractAnnotationConfigDispatcherServletInitializer类的方法来添加Filter</h1><p>如果想要添加DispatcherServlet相同映射路径的Filter,可以使用一种快捷的方法，即重写getServletFilters()方法，如下所示：</p>
<pre><code class="java">//AbstractAnnotationConfigDispatcherServletInitializer类中
@Override
public Filter[] getServletFilters()&#123;
    return new Filter[]&#123;new MyFilter()&#125;;
&#125;
</code></pre>
<p>该方法可以返回任意多的Filter,所有的Filter都会映射到DispatcherServlet路径上。</p>
<h1 id="实现WebApplicationInitializer接口添加自定义的Servlet和Filter"><a href="#实现WebApplicationInitializer接口添加自定义的Servlet和Filter" class="headerlink" title="实现WebApplicationInitializer接口添加自定义的Servlet和Filter"></a>实现WebApplicationInitializer接口添加自定义的Servlet和Filter</h1><p>这种方法更加灵活，可以将Servlet和Filter映射到自定义的路径下。</p>
<ul>
<li>添加自定义Servlet<pre><code class="java">import javax.servlet.ServletRegistration.Dynamic;
</code></pre>
</li>
</ul>
<p>public class MyServletInitializer implements WebApplicationInitializer{<br>    @Override<br>    public void onStartup(ServletContext servletContext) throws ServletException{<br>        Dynamic mySerlvet=servletContext.addServlet(“myServlet”,MyServlet.class);<br>        myServlet.addMapping(“/mypath/*”);<br>    }<br>}</p>
<pre><code>
- 添加自定义Filter
```java
import javax.servlet.FilterRegistration.Dynamic;

public class MyServletInitializer implements WebApplicationInitializer&#123;
    @Override
    public void onStartup(ServletContext servletContext) throws ServletException&#123;
        Dynamic myFilter=servletContext.addFilter(&quot;myFilter&quot;,MyFilter.class);
        myFilter.addMappingForUrlPatterns(null,false,&quot;/mypath/*&quot;);
    &#125;
&#125;
</code></pre>
<h1 id="重写AbstractAnnotationConfigDispatcherServletInitializer类的方法来自定义DispatcherServlet配置"><a href="#重写AbstractAnnotationConfigDispatcherServletInitializer类的方法来自定义DispatcherServlet配置" class="headerlink" title="重写AbstractAnnotationConfigDispatcherServletInitializer类的方法来自定义DispatcherServlet配置"></a>重写AbstractAnnotationConfigDispatcherServletInitializer类的方法来自定义DispatcherServlet配置</h1><p><code>AbstractAnnotationConfigDispatcherServletInitializer</code>类我们重写了必须重写的三个方法，getServletConfigClasses、getRootConfigClasses、getServletMappings,但是还有非常多的方法可以去重写，比如重写**customizeRegistration()**方法，在将DispatcherServlet注册到Servlet容器之中后，就会调用customizeRegistration()方法，并将DispatcherServlet注册之后得到的Dynamic对象传递进来，通过此方法可以自定义DispatcherServlet的很多事情，比如开启Multipart文件上传功能：</p>
<pre><code class="java">@Override
protected void customizeRegistration(ServletRegistration.Dynamic registration)&#123;
    registration.setMultipartCongif(
        new MultimartConfigElement(&quot;/tmp/uploads&quot;);
    );
    
    //或者设置LoadOnStartup参数
    registration.setLoadOnStartup(1);
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/03/16/IDEA%E4%B8%AD%E9%85%8D%E7%BD%AETomcat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/16/IDEA%E4%B8%AD%E9%85%8D%E7%BD%AETomcat/" class="post-title-link" itemprop="url">Windows系统下配置Tomcat</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-16 21:11:14" itemprop="dateCreated datePublished" datetime="2019-03-16T21:11:14+08:00">2019-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:06" itemprop="dateModified" datetime="2021-02-23T21:00:06+08:00">2021-02-23</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/03/16/IDEA%E4%B8%AD%E9%85%8D%E7%BD%AETomcat/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/16/IDEA%E4%B8%AD%E9%85%8D%E7%BD%AETomcat/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Tomcat下载并解压"><a href="#Tomcat下载并解压" class="headerlink" title="Tomcat下载并解压"></a>Tomcat下载并解压</h1><p>首先去官网下载一个Tomcat安装包,JDK当然也是需要滴。</p>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>下载下来的压缩包解药到文件夹中，比如说我解压到了<code>G:\apache-tomcat-7.0.86</code>文件夹，然后配置环境变量： </p>
<ul>
<li><p>计算机→属性→高级系统设置→高级→<strong>系统</strong>环境变量 </p>
</li>
<li><p>新建TOMCAT_HOME变量 </p>
<ul>
<li>变量名TOMCAT_HOME</li>
<li>变量值为解压的Tomcat安装包的路径,比如<code>G:\apache-tomcat-7.0.86</code></li>
</ul>
</li>
<li><p>新建CATALINA_HOME变量</p>
<ul>
<li>变量名CATALINA_HOME</li>
<li>变量值同样为解压的Tomcat安装包的路径</li>
</ul>
</li>
<li><p>修改变量Path</p>
<ul>
<li>在系统变量中找到Path变量名，双击或点击编辑，在末尾添加如下内容<code>;%TOMCAT_HOME%\bin;%CATALINA_HOME%\lib</code></li>
<li>这里要注意，各个变量值之间一定要用;分隔。</li>
</ul>
</li>
<li><p>在cmd命令窗口下输入startup回车（或者点击bin目录下的startup.bat文件），如果没有报错就说明成功</p>
</li>
<li><p>在浏览器中输入<code>http://localhost:8080</code>或<code>http://127.0.0.1:8080</code>，如果出现tomcat服务器页面即为配置成功。</p>
</li>
</ul>
<h2 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h2><p>如果输入startup出现<code>Neither the JAVA_HOME nor the JRE_HOME environment variable is defined</code>错误，原因是后来较新版本的JDK（例如我使用的JDK1.6）安装完不会自动登记环境变量JAVA_HOME，JRE_HOME。像我在单位的环境，我的用户是受限制的(PowerUser)，不方便设环境变量，于是我就找到了另外一个方法。<br>先看Tomcat的startup.bat，它调用了catalina.bat,而catalina.bat则调用了setclasspath.bat。只要在setclasspath.bat的开头声明环境变量，修改方法如下：<br>在文件中加入以下两行手动设置JAVA_HOME和JAR_HOME的路径：</p>
<pre><code class="bat">set JAVA_HOME=D:\Java\jdk1.6.0_11
set JRE_HOME=D:\Java\jre6
</code></pre>
<p>在linux系统中需要将set替换为export。</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/toutou/p/7910194.html">参考地址1</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37909508/article/details/79481926">参考地址2</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37909508/article/details/79481926">参考地址3</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/03/16/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%80%E5%91%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/16/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%80%E5%91%A8/" class="post-title-link" itemprop="url">工作总结-第一周</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-16 20:53:00" itemprop="dateCreated datePublished" datetime="2019-03-16T20:53:00+08:00">2019-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:04" itemprop="dateModified" datetime="2021-02-23T21:00:04+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Career/" itemprop="url" rel="index"><span itemprop="name">Career</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/03/16/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%80%E5%91%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/16/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%80%E5%91%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在军训结束之后，我顺利的度过了实习的第一周，这一周总的来说很寂寞，很空虚，也很慌，一方面是人际关系的慌，一方面是能力不足引起的恐慌，但是我觉得人的成长总是需要时间的，一切都会慢慢好起来，第一周的收货还是有很多滴，我决定工作的接下来每一周都把上一周遇到的不会的、不熟悉的技术总结一下，犯过的错误坚决不能犯第二次，还有一些比较重要的需要单独总结一下比较好,写到一起也没有关系，因为可以使用博客的搜索功能。废话不多说，开始吧。</p>
<h1 id="MySQL中JOIN的用法"><a href="#MySQL中JOIN的用法" class="headerlink" title="MySQL中JOIN的用法"></a>MySQL中JOIN的用法</h1><p>在弄毕业实际的时候，使用到了Mybatis，其中含有一对多的映射关系，其实做好只有回想起来也没有很复杂，但是我却零零散散想了有个把星期，其中的关键就是JOIN的用法以及<collection>标签的用法。首先记录一下JOIN的用法，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/38549/what-is-the-difference-between-inner-join-and-outer-join">StackOverflow</a>上有非常详细的解答，我就直接总结一下吧（偷一下懒先）：<br><img src="https://s2.ax1x.com/2019/03/16/AZYGKf.png" alt="AZYGKf.png"></p>
<p><img src="https://s2.ax1x.com/2019/03/16/AZY6qU.png" alt="AZY6qU.png"></p>
<ul>
<li><p>INNER JOIN:返回两个表都的部分。如图所示：<img src="https://s2.ax1x.com/2019/03/16/AZJyAH.png" alt="AZJyAH.png"></p>
</li>
<li><p>OUTER JOIN:返回两个表中都有的部分，然后加上左边和右边特有的部分<br><img src="https://s2.ax1x.com/2019/03/16/AZY7qO.png" alt="AZY7qO.png"></p>
</li>
<li><p>LEFT OUTER JOIN ：返回两个表中都有的部分，然后加上左边特有的部分。<br><img src="https://s2.ax1x.com/2019/03/16/AZYjJA.png" alt="AZYjJA.png"></p>
</li>
<li><p>RIGHT OUTER JOIN ：返回两个表中都有的部分，然后加上右边特有的部分。</p>
</li>
</ul>
<p>JOIN还有很多特殊的用法，上面图中已经涉及到了，这里就不一一写了，脑阔有点疼。</p>
<h1 id="FastJSON中的-JSONFiled注解"><a href="#FastJSON中的-JSONFiled注解" class="headerlink" title="FastJSON中的@JSONFiled注解"></a>FastJSON中的@JSONFiled注解</h1><p>FastJSON库的功能十分强大，导师说以后使用的时间也会非常多，那就先看一下非常常用的一个注解@JSONField的部分功能吧，更多的用法可以看看<a href="(https://www.w3cschool.cn/fastjson/fastjson-jsonfield.html)">文档</a></p>
<h2 id="自定义属性序列化的顺序"><a href="#自定义属性序列化的顺序" class="headerlink" title="自定义属性序列化的顺序"></a>自定义属性序列化的顺序</h2><p>有时候前台的JSON字符串的格式是固定的，所以后台就需要对POJO序列化的顺序进行控制，可以在成员变量上使用@JSONField(ordinal = 1)来对属性的序列化进行控制。</p>
<h2 id="将数值类型序列化为字符类型"><a href="#将数值类型序列化为字符类型" class="headerlink" title="将数值类型序列化为字符类型"></a>将数值类型序列化为字符类型</h2><p>数字类型在传递到前台时可能会出现溢出，导致出错，所以一般可以把数值类型序列化为字符类型，可以在数值类型的成员变量上使用@JSONField(serializeUsing = ToStringSerializer.class)来控制</p>
<blockquote>
<p>serializeUsing 这个属性是在fastjson 1.2.16后才有的。要检查下fastJson的版本</p>
</blockquote>
<h2 id="将对象属性序列化为指定的名称"><a href="#将对象属性序列化为指定的名称" class="headerlink" title="将对象属性序列化为指定的名称"></a>将对象属性序列化为指定的名称</h2><p>有时对象的属性并不能序列化为指定的名字，此时就需要使用注解来指定序列化之后的名字，可以使用@JSONField(name=”name”),同样此注解可以使用在geter或者seter方法上，也可以使用在成员变量上，对序列化进行不同控制。</p>
<h2 id="对时间进行格式化"><a href="#对时间进行格式化" class="headerlink" title="对时间进行格式化"></a>对时间进行格式化</h2><p>对于Data时间格式，可以使用@JSONField(format=”yyyyMMdd”)来格式化时间</p>
<p>##使用serialize/deserialize指定字段不序列化</p>
<pre><code class="java">public class A &#123;
      @JSONField(serialize=false)
      public Date date;
 &#125;

 public class A &#123;
      @JSONField(deserialize=false)
      public Date date;
 &#125;
</code></pre>
<p>更多的用法可以<a target="_blank" rel="noopener" href="https://www.w3cschool.cn/fastjson/fastjson-jsonfield.html">查看文档</a></p>
<h1 id="Mybatis中JavaType和JDBCType的对应"><a href="#Mybatis中JavaType和JDBCType的对应" class="headerlink" title="Mybatis中JavaType和JDBCType的对应"></a>Mybatis中JavaType和JDBCType的对应</h1><p>在弄毕设的时候，数据库中的BIGINT会被映射为Java的Long类型，但是在今天做映射的时候，BIGINT且被映射为Integer类型，具体的原因我还没弄清除，可能是BIGINT（20）由于数字太小进行了自动转换，等下次遇到的时候再去研究一下，先记录下JDBCType和JavaType数据类型的对应关系：</p>
<pre><code class="JAVA">  JDBCType            JavaType
    CHAR                String
    VARCHAR             String
    LONGVARCHAR         String
    NUMERIC             java.math.BigDecimal
    DECIMAL             java.math.BigDecimal
    BIT                 boolean
    BOOLEAN             boolean
    TINYINT             byte
    SMALLINT            short
    INTEGER             int
    BIGINT              long
    REAL                float
    FLOAT               double
    DOUBLE              double
    BINARY              byte[]
    VARBINARY           byte[]
    LONGVARBINARY       byte[]
    DATE                java.sql.Date
    TIME                java.sql.Time
    TIMESTAMP           java.sql.Timestamp
    CLOB                Clob
    BLOB                Blob
    ARRAY               Array
    DISTINCT            mapping of underlying type
    STRUCT              Struct
    REF                 Ref
    DATALINK            java.net.URL[color=red][/color]
    ```
    
# Mybatis中&lt; collection &gt;标签的使用
在做课设处理映射时，使用到了一对多的映射，先还原场景，然后看一看&lt; collection &gt;标签的用法。

## 表结构：
user_info(用户信息表)：
![AeUPfJ.png](https://s2.ax1x.com/2019/03/17/AeUPfJ.png)
packet_info(用户分组信息，每个分组保存了用户的好友)：
![AeUMfH.png](https://s2.ax1x.com/2019/03/17/AeUMfH.png)
user_packet_info(用户所建的分组)：
![AeUt78.png](https://s2.ax1x.com/2019/03/17/AeUt78.png)
packet_user_info(分组中保存的好友)：
![AeUdhQ.png](https://s2.ax1x.com/2019/03/17/AeUdhQ.png)

## 所要是实现的功能
项目中所要实现的功能是查询某一个user_id的所有分组下的好友，返回的主要部分JSON格式需要如下：

```text
&#123;    //好友列表
    &quot;friend&quot;: [&#123;
      &quot;groupname&quot;: &quot;前端码屌&quot; //好友分组名
      ,&quot;id&quot;: 1 //分组ID
      ,&quot;list&quot;: [&#123; //分组下的好友列表
        &quot;username&quot;: &quot;贤心&quot; //好友昵称
        ,&quot;id&quot;: &quot;100001&quot; //好友ID
        ,&quot;avatar&quot;: &quot;a.jpg&quot; //好友头像
        ,&quot;sign&quot;: &quot;这些都是测试数据，实际使用请严格按照该格式返回&quot; //好友签名
        ,&quot;status&quot;: &quot;online&quot; //若值为offline代表离线，online或者不填为在线
      &#125;, …… ]
    &#125;, …… ]
    
&#125;
</code></pre>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>ResultMap:</p>
<pre><code class="xml">&lt;select id=&quot;SelectFriendInfo&quot; resultMap=&quot;FriendInfoResultMap&quot;&gt;
        SELECT packet_name  ,C.packet_id
        FROM user_packet_info AS A
        INNER JOIN packet_info AS C ON A.packet_id=C.packet_id
        WHERE A.user_id=#&#123;id&#125;;
    &lt;/select&gt;

    &lt;select id=&quot;SelectUserFriend&quot; resultType=&quot;FriendInfo&quot;&gt;
        SELECT E.user_id AS id,username,sign,avatar,status
        FROM user_packet_info AS A
        INNER JOIN packet_user_info AS E ON A.packet_id=E.packet_id
        INNER JOIN user_info AS B ON E.user_id=B.user_id AND B.user_id!=A.user_id
        WHERE E.packet_id=#&#123;id&#125;;
    &lt;/select&gt;

    &lt;resultMap id=&quot;FriendInfoResultMap&quot; type=&quot;PacketInfo&quot;&gt;
        &lt;constructor&gt;
            &lt;idArg column=&quot;packet_id&quot; javaType=&quot;Long&quot;/&gt;
            &lt;arg column=&quot;packet_name&quot; javaType=&quot;String&quot;/&gt;
        &lt;/constructor&gt;
        &lt;collection property=&quot;list&quot; ofType=&quot;FriendInfo&quot; javaType=&quot;ArrayList&quot; column=&quot;packet_id&quot; select=&quot;SelectUserFriend&quot;&gt;
            &lt;id column=&quot;id&quot; javaType=&quot;Long&quot;/&gt;
            &lt;result  column=&quot;username&quot; javaType=&quot;String&quot;/&gt;
            &lt;result  column=&quot;sign&quot; javaType=&quot;String&quot;/&gt;
            &lt;result  column=&quot;status&quot; javaType=&quot;String&quot;/&gt;
            &lt;result  column=&quot;avatar&quot; javaType=&quot;String&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
</code></pre>
<p>其中的&lt; collection &gt;中，需要使用一个column属性，将上层的packet_id传递给下层的查询语句作为参数，association同样也需要。而且不能将两个SELECT合并为一个查询语句。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/02/01/JUnit%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/01/JUnit%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">JUnit基础用法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-01 16:05:00" itemprop="dateCreated datePublished" datetime="2019-02-01T16:05:00+08:00">2019-02-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:06" itemprop="dateModified" datetime="2021-02-23T21:00:06+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/02/01/JUnit%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/02/01/JUnit%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JUnit4和JUnit5常用注解-Annotations"><a href="#JUnit4和JUnit5常用注解-Annotations" class="headerlink" title="JUnit4和JUnit5常用注解(Annotations)"></a>JUnit4和JUnit5常用注解(Annotations)</h1><ul>
<li><p>@BeforeClass(等价于JUnit5中的@BeforeAll)<br>该注解作用于方法之上，含有此注解的方法在<strong>所有方法执行之前</strong>执行，方法必须使用<code>public static void</code>修饰，不能有参数，通常用来加载资源或配置文件。</p>
</li>
<li><p>@BeforeClass(等价于JUnit5中的@AfterAll)<br>该注解作用于方法之上，含有此注解的方法在<strong>所有方法执行之后</strong>执行，方法必须使用<code>public static void</code>修饰，不能有参数，通常用来释放资源。</p>
</li>
<li><p>@Before(等价于JUnit5中的@BeforeEach)<br>该注解作用于方法之上，含有此注解的方法在**每个测试方法(@Test注解的方法)**执行之后执行，方法必须使用<code>public void</code>修饰，不能有参数。</p>
</li>
<li><p>@After(等价于JUnit5中的@AfterEach)<br>该注解作用于方法之上，含有此注解的方法在**每个测试方法(@Test注解的方法)**执行之后执行，方法必须使用<code>public void</code>修饰，不能有参数。</p>
</li>
<li><p>@Test<br>该注解作用于方法之上，表示该方法是一个<strong>测试方法</strong>，方法必须使用<code>public void</code>修饰，不能有参数。</p>
</li>
<li><p>@Ignore(等价于JUnit5中的@Disable)<br>该注解作用于@Test注解的测试方法之上，表示忽略此测试方法，此测试方法不会被执行，此注解不能作用在类上。</p>
</li>
</ul>
<ul>
<li>@DisplayName（JUnit5新增）<br>该注解可作用于类或者方法上，可以更改测试类的显示名称，例如使用<code>@DisplayName(&quot;Aviator&quot;)</code>则测试类名显示为Aviator，通过@DisplayName，开发人员可以为每个测试用例添加更具体的名字，更容易传达用例所要测试的内容。</li>
</ul>
<hr>
<p>常用注释表(<a target="_blank" rel="noopener" href="https://blog.csdn.net/winteroak/article/details/80591598">CSDN博客原表格地址</a>)：</p>
<table>
<thead>
<tr>
<th>JUnit4</th>
<th>JUnit5</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Test</td>
<td>@Test</td>
<td>表示该方法是一个测试方法。JUnit5与JUnit 4的@Test注解不同的是，它没有声明任何属性，因为JUnit Jupiter中的测试扩展是基于它们自己的专用注解来完成的。这样的方法会被继承，除非它们被覆盖；</td>
</tr>
<tr>
<td>@BeforeClass</td>
<td>@BeforeAll</td>
<td>表示使用了该注解的方法应该在当前类中所有使用了@Test @RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之前 执行；</td>
</tr>
<tr>
<td>@AfterClass</td>
<td>@AfterAll</td>
<td>表示使用了该注解的方法应该在当前类中所有使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之后执行；</td>
</tr>
<tr>
<td>@Before</td>
<td>@BeforeEach</td>
<td>表示使用了该注解的方法应该在当前类中每一个使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之前 执行</td>
</tr>
<tr>
<td>@After</td>
<td>@AfterEach</td>
<td>表示使用了该注解的方法应该在当前类中每一个使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之后 执行</td>
</tr>
<tr>
<td>@Ignore</td>
<td>@Disabled</td>
<td>用于禁用一个测试类或测试方法</td>
</tr>
<tr>
<td>@Category</td>
<td>@Tag</td>
<td>用于声明过滤测试的tags，该注解可以用在方法或类上；类似于TesgNG的测试组或JUnit 4的分类。</td>
</tr>
<tr>
<td>@Parameters</td>
<td>@ParameterizedTest</td>
<td>表示该方法是一个参数化测试</td>
</tr>
<tr>
<td>@RunWith</td>
<td>@ExtendWith</td>
<td>@Runwith就是放在测试类名之前，用来确定这个类怎么运行的</td>
</tr>
<tr>
<td>@Rule</td>
<td>@ExtendWith</td>
<td>Rule是一组实现了TestRule接口的共享类，提供了验证、监视TestCase和外部资源管理等能力</td>
</tr>
<tr>
<td>@ClassRule</td>
<td>@ExtendWith</td>
<td>@ClassRule用于测试类中的静态变量，必须是TestRule接口的实例，且访问修饰符必须为public。</td>
</tr>
</tbody></table>
<h1 id="JUnit4和5中的断言（Assertion）"><a href="#JUnit4和5中的断言（Assertion）" class="headerlink" title="JUnit4和5中的断言（Assertion）"></a>JUnit4和5中的断言（Assertion）</h1><p><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-junit5/">点击查看原文地址</a><br>断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。这些断言方法都是 <code>org.junit.jupiter.api.Assertions</code> 的静态方法。JUnit 5 内置的断言可以分成如下几个类别：</p>
<hr>
<p>第一类是简单断言，用来对单个值进行简单的验证，常用的方法见表：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>assertEquals</td>
<td>判断两个对象或两个原始类型是否相等</td>
</tr>
<tr>
<td>assertNotEquals</td>
<td>判断两个对象或两个原始类型是否不相等</td>
</tr>
<tr>
<td>assertSame</td>
<td>判断两个对象引用是否指向同一个对象</td>
</tr>
<tr>
<td>assertNotSame</td>
<td>判断两个对象引用是否指向不同的对象</td>
</tr>
<tr>
<td>assertTrue</td>
<td>判断给定的布尔值是否为 true</td>
</tr>
<tr>
<td>assertFalse</td>
<td>判断给定的布尔值是否为 false</td>
</tr>
<tr>
<td>assertNull</td>
<td>判断给定的对象引用是否为 null</td>
</tr>
<tr>
<td>assertNotNull</td>
<td>判断给定的对象引用是否不为 null</td>
</tr>
</tbody></table>
<p>在<strong>JUnit5</strong>中这些方法都有多个重载方法(JUnit4不支持)，可以提供额外的消息来作为断言不满足时的提示消息(Message)，还可以接受 Java 8 中的函数式编程接口 Supplier来获取要判断的值和显示的消息。下面代码给出了简单断言的使用示例:</p>
<pre><code class="java">    @Test
    @DisplayName(&quot;simple assertion&quot;)
    public void simple() &#123;
        assertEquals(3, 1 + 2, &quot;simple math&quot;);//接受String作为提示
        assertEquals(1,2-1,()-&gt;&quot;simple math&quot;);//接受Java8的Supplier接口作为提示
        assertNotEquals(3, 1 + 1);

        assertNotSame(new Object(), new Object());
        Object obj = new Object();
        assertSame(obj, obj);
        assertSame(obj, obj,&quot;not same new Object()&quot;);//接受String作为提示
        assertSame(obj, obj,()-&gt;&quot;not same new Object()&quot;);//接受Java8的Supplier接口

        assertFalse(1 &gt; 2);
        assertTrue(1 &lt; 2);

        assertNull(null);
        assertNotNull(new Object());
 
 ...
    &#125;
</code></pre>
<hr>
<p>第二类是通过 assertArrayEquals 方法来判断两个对象或原始类型的<strong>数组</strong>是否相等,或者通过assertIterableEquals方法来判断两个<strong>可迭代对象</strong>是否相等，如下所示：</p>
<pre><code class="java">    @Test
    @DisplayName(&quot;array assertion&quot;)
    public void array() &#123;
        assertArrayEquals(new int[]&#123;1, 2&#125;, new int[] &#123;1, 2&#125;);//同样也可以指定消息或者使用Supplier接口。
    &#125;
    
    
    @Test
    @DisplayName(&quot;iterable assertion&quot;)
    public void iterable() &#123;
        assertIterableEquals(Arrays.asList(1,2,3),Arrays.asList(1,2,3),&quot;Iterable Not Equal&quot;);
    &#125;
</code></pre>
<hr>
<p>第三类是通过assertAll方法来判断一组断言是否满足。assertAll 方法接受多个<code>org.junit.jupiter.api.Executable（方法签名为void-&gt;void）</code>函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言，assertAll的第一个参数是标题（heading），表示一组Executtable共有的属性，如下代码所示：</p>
<pre><code class="java">    @Test
    @DisplayName(&quot;assert all&quot;)
    public void all() &#123;
        assertAll(&quot;Math&quot;,
                () -&gt; assertEquals(2, 1 + 1),
                () -&gt; assertTrue(1 &gt; 0)
        );
    &#125;
</code></pre>
<hr>
<p>第四类是通过 assertThrows 或 expectThrows 来判断是否抛出期望的异常类型。两个方法的参数都是所期望的异常类型和对应的 Executable 接口的实现对象，区别在于 expectThrows 方法会<strong>返回抛出的异常对象</strong>。在下面代码中，1/0 会抛出 ArithmeticException 异常，下面代码使用assertThrows 用来验证这一点。</p>
<pre><code class="java">    @Test
    @DisplayName(&quot;throws exception&quot;)
    public void exception() &#123;
        assertThrows(ArithmeticException.class, () -&gt; System.out.println(1 / 0));
    &#125;
</code></pre>
<hr>
<p>第五类是fail方法，用来直接使一个测试方法失败，如下代码所示：</p>
<pre><code class="java">    @Test
    @DisplayName(&quot;fail&quot;)
    public void shouldFail() &#123;
        fail(&quot;This should fail&quot;);
    &#125;
</code></pre>
<h1 id="JUnit中测试异常-Exception-和超时-Timeout"><a href="#JUnit中测试异常-Exception-和超时-Timeout" class="headerlink" title="JUnit中测试异常(Exception)和超时(Timeout)"></a>JUnit中测试异常(Exception)和超时(Timeout)</h1><p>在<strong>JUnit4</strong>中（JUnit5不支持），可以对@Test注解进行扩展，使用expected和timeout属性，以便支持测试方法是否抛出特定异常和检测方法的运行时间。</p>
<ul>
<li><p>@Test(expected=xx.class)：xx.class表示想要抛出的异常类，表示测试的方法抛出此异常时，认为是正常的测试通过的，如果没有抛出特定异常，则测试不通过。</p>
</li>
<li><p>@Test(timeout=毫秒数)：测试方法执行时间是否符合预期，如果方法运行时间超过给定的毫秒数，则测试不通过，否则测试通过，一般用来测试方法的性能。</p>
</li>
</ul>
<p>JUnit5中可以使用断言来测试异常和超时,,以下方法都有一个参数为<code>org.junit.jupiter.api.Executable（方法签名为void-&gt;void）</code>，同时可以指定一个String类型的message或者使用函数式接口Supplier来提供message,如下所示：</p>
<ul>
<li><p>assertThrows：断言所提供的可执行代码块的执行会引发expectedType的异常并返回异常。如果没有抛出异常，或者抛出了不同类型的异常，则此方法将失败。如果不想对异常实例执行其他检查，只需忽略返回值。</p>
</li>
<li><p>assertDoesNotThrow：断言所提供的可执行代码块的执行不会引发expectedType的异常并返回异常。如果抛出异常，则此方法将失败。</p>
</li>
<li><p>expectThrows：和assertThrows功能相同，区别在于 expectThrows 方法会返回抛出的异常对象。</p>
</li>
<li><p>assertTimeout：断言在超出给定超时之前，所提供的可执行代码块的执行完成。注意：可执行代码块将在与调用代码相同的线程中执行。因此，如果超过超时，则不会抢先中止执行可执行代码块，<strong>即如果发生超时方法不会立即结束</strong>。</p>
</li>
<li><p>assertTimeoutPreemptively：断言在超出给定超时之前，所提供的可执行代码块的执行完成。注意：可执行代码块将在与调用代码不同的线程中执行。此外，如果超时，则可抢占地执行可执行代码块，<strong>即如果超时方法会立即结束</strong>。</p>
</li>
</ul>
<h1 id="参数化测试（Parameters）"><a href="#参数化测试（Parameters）" class="headerlink" title="参数化测试（Parameters）"></a>参数化测试（Parameters）</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/01/17/Intellij-IDEA%E4%B8%AD%E6%B7%BB%E5%8A%A0JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/17/Intellij-IDEA%E4%B8%AD%E6%B7%BB%E5%8A%A0JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">Intellij IDEA中添加JUnit单元测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-17 14:01:00" itemprop="dateCreated datePublished" datetime="2019-01-17T14:01:00+08:00">2019-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:02" itemprop="dateModified" datetime="2021-02-23T21:00:02+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/01/17/Intellij-IDEA%E4%B8%AD%E6%B7%BB%E5%8A%A0JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/01/17/Intellij-IDEA%E4%B8%AD%E6%B7%BB%E5%8A%A0JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>JUnit是一个很出名的单元测试测试框架，在非常多的项目中被使用，这几天想学习一下JUnit 4。目前广泛使用的是 JUnit 4 版本，同时JUnit 5也可以使用，JUnit 5 在增加了很多的新特性的同时，又保持了对 JUnit 4 的向后兼容性。等具体学习的时候再来看，首先学习在IDEA中添加JUint。</p>
<h1 id="下载jar包"><a href="#下载jar包" class="headerlink" title="下载jar包"></a>下载jar包</h1><p>首先需要去下载JUnit的jar包以及一个依赖包hamcrest.core，他们的下载地址如下：<br><a target="_blank" rel="noopener" href="https://search.maven.org/artifact/junit/junit/4.13-beta-1/jar">junit:junit:4.13-beta-1</a><br><a target="_blank" rel="noopener" href="https://search.maven.org/artifact/org.ops4j.pax.tipi/org.ops4j.pax.tipi.hamcrest.core/1.3.0.1/bundle">hamcrest.core:1.3.0.1</a><br>需要注意的是hamcrest.core包不能使用2.1版本的，因为4.13版本的JUnit和它不兼容，会抛出<code>ClassNotFoundException</code>异常。</p>
<h1 id="在Intellij-IDEA项目中添加jar包"><a href="#在Intellij-IDEA项目中添加jar包" class="headerlink" title="在Intellij IDEA项目中添加jar包"></a>在Intellij IDEA项目中添加jar包</h1><p>首先需要在IDEA中添加刚才下载好的包：<br><img src="https://s2.ax1x.com/2019/01/18/k99r3F.png" alt="k99r3F.png"></p>
<p>记得勾选Export选项。</p>
<h1 id="下载插件并进行设置"><a href="#下载插件并进行设置" class="headerlink" title="下载插件并进行设置"></a>下载插件并进行设置</h1><p>然后需要下载一个名为JUnitGeneratorV2.0的插件：<br><img src="https://s2.ax1x.com/2019/01/18/k99sc4.png" alt="k99sc4.png"></p>
<p>然后对其进行设置：<br><img src="https://s2.ax1x.com/2019/01/18/k99yjJ.png" alt="k99yjJ.png"></p>
<p>输出路径可以更改为想要的路径</p>
<p><img src="https://s2.ax1x.com/2019/01/18/k99cu9.png" alt="k99cu9.png"></p>
<p>将图片中的<code>$data</code>改为<code>$today</code>是为了防止生成的测试类产生乱码。</p>
<h1 id="使用JUnit"><a href="#使用JUnit" class="headerlink" title="使用JUnit"></a>使用JUnit</h1><p>当想要为当前类添加测试代码，只需要在当前类中使用Alt+inset（或者导航栏中点击Code-Generator）快捷键，选择JUnit-JUnit4，就会自动生成当前类的测试类：<br><img src="https://s2.ax1x.com/2019/01/18/k992H1.png" alt="k992H1.png"></p>
<p>插件默认会测试所有方法，使用快捷键<code>Ctrl+Shift+T</code>可以选择性的测试部分方法，非常的方便：<br><img src="https://s2.ax1x.com/2019/01/18/k99WAx.png" alt="k99WAx.png"></p>
<p>在输出路径中就可以看到自动生成的测试类，含有需要测试的方法，接下来就可以编写代码对类进行测试啦 QAQ.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2018/12/28/Ubuntu17%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%85%8D%E7%BD%AEJDK/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/28/Ubuntu17%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%85%8D%E7%BD%AEJDK/" class="post-title-link" itemprop="url">Ubuntu17系统环境下配置JDK</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-28 14:59:00" itemprop="dateCreated datePublished" datetime="2018-12-28T14:59:00+08:00">2018-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:00" itemprop="dateModified" datetime="2021-02-23T21:00:00+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OperationSystem/" itemprop="url" rel="index"><span itemprop="name">OperationSystem</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/12/28/Ubuntu17%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%85%8D%E7%BD%AEJDK/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/12/28/Ubuntu17%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%85%8D%E7%BD%AEJDK/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="下载jdk文件"><a href="#下载jdk文件" class="headerlink" title="下载jdk文件"></a>下载jdk文件</h1><p>在oracle官网上下载JDK1.8 linux的安装包，地址如下：<br><a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/javase/downloads/index.html">JDK下载地址</a></p>
<h1 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h1><p>将下载好的.tar.gz文件解压到指定文件夹:<br><code>tar -zxvf jdk-8u191-linux-x64.tar.gz /usr/lib/jdk1.8</code><br>将其解压到文件夹/usr/lib/jdk1.8中。</p>
<blockquote>
<p>/usr/lib用于存放目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件的存放位置。这个目录功能类似/lib目录，理说，这里存放的文件应该是/bin目录下程序所需要的库文件的存放地，也不排除一些例外的情况。</p>
</blockquote>
<h1 id="bashrc文件和-etc-profile文件区别"><a href="#bashrc文件和-etc-profile文件区别" class="headerlink" title=".bashrc文件和/etc/profile文件区别"></a>.bashrc文件和/etc/profile文件区别</h1><p>在linux系统普通用户目录（cd/home/xxx）或root用户目录（cd /root）下，用指令ls -al可以看到4个隐藏文件，</p>
<ul>
<li>.bash_history 记录之前输入的命令</li>
<li>.bash_logout 当你退出时执行的命令</li>
<li>.profile 当你登入shell时执行</li>
<li>.bashrc 当你登入shell时执行</li>
</ul>
<p>请注意后两个的区别：<code>.profile</code>只在会话开始时被读取一次，而<code>.bashrc</code>则每次打开新的终端时，都要被读取。</p>
<p>这些文件是每一位用户对终端功能和属性设置，修改.bashrc可以改变环境变量PATH、别名alias和提示符。</p>
<p>除了可以修改用户目录下的.bashrc文件外，还可以修改如“/etc/profile”文件、“/etc/bashrc”文件及目录“/etc/profile.d”下的文件。但是修改/etc路径下的配置文件将会应用到整个系统，属于系统级的配置，而修改用户目录下的.bashrc则只是限制在用户应用上，属于用户级设置。两者在应用范围上有所区别，建议如需修改的话，修改用户目录下的.bashrc，既无需root权限，也不会影响其他用户。</p>
<h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><p>linux中需要在配置文件中修改环境变量PATH，有两个配置文件中写入，在.bashrc文件中写入或者/etc/profile文件中写入如下代码：</p>
<pre><code class="shell">export JAVA_HOME=/usr/lib/jdk1.8  #此路径为存放jdk的文件夹
export JRE_HOME=$&#123;JAVA_HOME&#125;/jre 
export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib
export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH
</code></pre>
<p>方法一：<br>修改用户目录下的.bashrc文件，在文件最后一行添加如上代码：<br><code>sudo vi ~/.bashrc</code><br>此方法只对当前用户有效。</p>
<p>方法二：<br>修改/etc/profile文件，在文件最后一行添加如上代码：<br><code>sudo vi /etc/profile</code><br>此方法对所有用户有效。</p>
<h1 id="使配置文件生效并进行测试"><a href="#使配置文件生效并进行测试" class="headerlink" title="使配置文件生效并进行测试"></a>使配置文件生效并进行测试</h1><blockquote>
<p>source filepath 语句会使当前shell读入路径为filepath的shell文件并依次执行文件中的所有语句，通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。例如，当我们修改了/etc/profile文件，并想让它立刻生效，而不用重新登录，就可以使用source命令，如source /etc/profile。</p>
</blockquote>
<p>使用<code>source /etc/profile</code>或者<code>source ~/.bashrc</code>使修改生效。<br>使用<code>java -version</code>来测试是否完成配置。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="熊乾坤"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">熊乾坤</p>
  <div class="site-description" itemprop="description">熊乾坤的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">127</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/super-aviator" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;super-aviator" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">熊乾坤</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'o6g891hxXze8WG1xu174Bxc4-MdYXbMMI',
      appKey     : 'HSOYHT8PzTeNo7stIuLIuYvO',
      placeholder: "快来评论吧~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
