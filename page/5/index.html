<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"super-aviator.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":10,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="熊乾坤的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="孤独飞行员">
<meta property="og:url" content="https://super-aviator.github.io/page/5/index.html">
<meta property="og:site_name" content="孤独飞行员">
<meta property="og:description" content="熊乾坤的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="熊乾坤">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://super-aviator.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>孤独飞行员</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">孤独飞行员</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/08/30/Spring%E4%B8%AD%E7%9A%84-RequestBody%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/30/Spring%E4%B8%AD%E7%9A%84-RequestBody%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">Spring中的@RequestBody注解与常规的HTTP方法的传值方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-30 10:31:00" itemprop="dateCreated datePublished" datetime="2019-08-30T10:31:00+08:00">2019-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:00" itemprop="dateModified" datetime="2021-02-23T21:00:00+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/08/30/Spring%E4%B8%AD%E7%9A%84-RequestBody%E6%B3%A8%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/08/30/Spring%E4%B8%AD%E7%9A%84-RequestBody%E6%B3%A8%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上周进行项目开发的时候，发现前端的含有文件的表单数据时后台接收报错，异常的大致意思是表单类型不支持，我也是有点蒙逼，以前也遇到过这种问题，加上@RequestBody就可以，所以这次我也加上了@RequestBody注解，结果还是报错，这时前端发消息过来，告诉我不能加@RequestBody,我去掉之后果然好了，好吧。一直没弄明白什么时候要加@RequestBody什么时候不要加，趁着这个迭代的任务很轻松，学习一下Spring中@RequestBody注解和后端如何接收常用的HTTP方法传过来的数据，结合PostMan对结果进行测试。</p>
<h1 id="RequestBody注解"><a href="#RequestBody注解" class="headerlink" title="@RequestBody注解"></a>@RequestBody注解</h1><blockquote>
<p>@RequestBody注解常用来处理POST请求，并且content-type不是默认的application/x-www-form-urlcoded编码的内容，比如说：application/json或者是application/xml等。一般情况下来说常用其来处理application/json类型。</p>
</blockquote>
<blockquote>
<p>@RequestMapping注解的方法的参数中包含了@RequestBody注解，那么Spring会首先查看请求中的Content-Type头部，然后根据Content-Type头部去查找合适的HttpMessageConverter        </p>
</blockquote>
<blockquote>
<p>例如，如果客户端发送的Spittle数据是JSON表述形式，那 么Content-Type头部信息可能就会是“application/json”。在 这种情况下，DispatcherServlet会查找能够将JSON转换为Java 对象的消息转换器。如果Jackson 2库在类路径中，那 么MappingJackson2HttpMessageConverter将会担此重任，将 JSON表述转换为Spittle，然后传递到saveSpittle()方法中。 这个方法还使用了@ResponseBody注解，因此方法返回的Spittle 对象将会转换为某种资源表述，发送给客户端。</p>
</blockquote>
<p>在《Spring 实战》中，表明了@RequestBody注解的含义和使用方式：<strong>用来解析请求体（可能是POST,PUT,DELETE,GET请求）中Content-Type为application/json类型的请求，利用消息转换器将其转换为对应的java对象</strong>（必须使用VO对象去接收），那么什么类型的消息能够加上@RequestBody，什么类型的消息不能加呢？</p>
<h2 id="表单类型"><a href="#表单类型" class="headerlink" title="表单类型"></a>表单类型</h2><blockquote>
<p>MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。Content-Type头部后面可以追加<code>;charset=UTF-8</code>指定编码格式,例如：<code>Content-Type:x-www-from-urlencoded;charset=UTF-8</code></p>
</blockquote>
<p>Content-Type字段表明了请求的请求体类型，可以是如下几种常见的类型：<br>常见媒体格式如下:</p>
<ul>
<li>text/html ： HTML格式</li>
<li>text/plain ：纯文本格式</li>
<li>text/xml ：  XML格式</li>
<li>image/gif ：gif图片格式</li>
<li>image/jpeg ：jpg图片格式</li>
<li>image/png：png图片格式</li>
<li>multipart/form-data：（体数据被编码为一条消息，页上的每个控件对应消息中的一个部分，这个一般文件上传时用）</li>
</ul>
<p>以application开头的媒体格式类型：</p>
<ul>
<li>application/xhtml+xml ：XHTML格式</li>
<li>application/xml     ： XML数据格式</li>
<li>application/atom+xml  ：Atom XML聚合格式</li>
<li>application/json    ： JSON数据格式</li>
<li>application/pdf       ：pdf格式</li>
<li>application/msword  ： Word文档格式</li>
<li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li>
<li>application/x-www-form-urlencoded ： 中默认的encType,form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</li>
</ul>
<p>下面是常见的表单提交的Content-Type的取值：</p>
<h3 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h3><ul>
<li><p>如果使用的是GET请求，浏览器用<code>x-www-form-urlencoded</code>的编码方式把form数据转换成一个字串（name1=value1&amp;name2=value2…），然后把这个字串append到url后面，用?分割，加载这个新的url。</p>
</li>
<li><p>如果使用的是POST请求，会采用类似GET的字符串拼接的方式，<strong>将拼接的key-value字段放到body里面，而非url的后面</strong>,所以POST请求的url长度是没有限制的，因为拼接的url请求参数都存放在body里面,如下</p>
<pre><code class="http">     POST  HTTP/1.1
  Host: 127.0.0.1:8000
  Content-Type: application/x-www-form-urlencoded
  Cache-Control: no-cache
  Postman-Token: e8c31d7a-fd52-cbf2-2741-07d73cb1101b

  keyword=panda&amp;author=zane
</code></pre>
<p><strong>注意</strong>：使用<code>application/x-www-form-urlencoded</code>编码方式的请求会对所有非ASCII的字符使用%HH的方式进行转换，所以一个非ASCII字符会由三个字符去表示，当非ASCII非常多时，会增加大约三倍的带宽，这无疑是一种浪费。</p>
<h3 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h3><p>如果没有type=file的控件，用默认的<code>application/x-www-form-urlencoded</code>就可以了。 但是如果有type=file的话，Content-Type就会升级使用<code>multipart/form-data</code>类型。浏览器会把整个表单以控件为单位分割，**并为每个部分加上Content-Disposition(form-data或者file),Content-Type(默认为text/plain),name(控件的name，即字段名)等信息，并加上分割符(boundary)**，例如：    </p>
<pre><code class="html">  POST / HTTP/1.1
  Host: 127.0.0.1:8000
  Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
  Cache-Control: no-cache
  Postman-Token: 090df52c-d103-279b-1479-50e6a7fef58b

  ------WebKitFormBoundary7MA4YWxkTrZu0gW
  Content-Disposition: form-data; name=&quot;keyword&quot;

  panda
  ------WebKitFormBoundary7MA4YWxkTrZu0gW
  Content-Disposition: form-data; name=&quot;author&quot;

  zane
  ------WebKitFormBoundary7MA4YWxkTrZu0gW
</code></pre>
</li>
</ul>
<p>上面的请求中，keyword键对应的值为panda,author键对应的值为zane。</p>
<p>  首先我们看请求头的 Content-Type 它除了正常的 multipart/form-data 外还多了一个 boundary ，这个 boundary 的意思和字面意思一样就是分界线，通过分界线将每个键值对用 boundary 分割开来以示区别,<strong>这个分界线是特殊选择出来的，以便该boundary不会出现在任何有效负载中</strong>。现在我们看请求体，我们注意到boundary 将键值对分割后的每一部分都有 Content-Disposition 字段，实际上该字段的值必须为 form-data 而且后面必须加上 name 指定这部分的键名，然后是一行空行，空行之后便是提交数据的内容。 之所以要弄的这么复杂是因为 multipart/form-data 要支持文件上传。</p>
<p>  <strong>注意</strong>：使用<code>multipart/form-data</code>编码方式的请求不会对非ASCII字符进行转码，所以也就不会有消耗，但是对于简短的字母数字值(与大多数web表单一样)，添加所有MIME头的开销将大大超过更有效的二进制编码所节省的开销。</p>
<h3 id="application-json"><a href="#application-json" class="headerlink" title="application/json"></a>application/json</h3><p>数据以纯文本形式(text/json/xml/html)进行编码，POST方法使用这种方式会把表单的键值对以一个JSON字符串的方式放到HTTP的body里面。例如如下的postman中的请求示例：<br>?<br><img src="/images/applicationjsonrequestdemo.png" alt="upload successful"></p>
<p><strong>注意</strong>：当非post请求的请求体中也含有JSON字符串时，依旧可以使用@RequestBody拿到请求体中的数据。</p>
<h2 id="Postman测试"><a href="#Postman测试" class="headerlink" title="Postman测试"></a>Postman测试</h2><p>下面使用Postman来测试一下什么时候要加@Requestbody，什么时候不用加@RequestBody注解：<br>首先是Controller中的代码，有个方法，一个使用了@RequestBody注解，一个没有使用：</p>
<pre><code class="java">@RestController
@RequestMapping(&quot;/requestBody&quot;)
@Slf4j
public class RequestBodyController &#123;
    @NoArgsConstructor
    @AllArgsConstructor
    @Getter
    @Setter
    private static class Request&#123;
        private String name;
        private Integer age;
        @JSONField(serialize = false,deserialize = false)
        private MultipartFile avatar;
    &#125;

    @PostMapping(&quot;/request&quot;)
    public HttpEntity&lt;Request&gt; generalRequest(Request request) &#123;
        log.info(&quot;generalRequest-&#123;&#125;&quot;,JSON.toJSONString(request));
        return new HttpEntity&lt;&gt;(request);
    &#125;

    @PostMapping(&quot;/requestBody&quot;)
    public HttpEntity&lt;Request&gt; generalRequestBody(@RequestBody Request request) &#123;
        log.info(&quot;generalRequest-&#123;&#125;&quot;,JSON.toJSONString(request));
        return new HttpEntity&lt;&gt;(request);
    &#125;
&#125;
</code></pre>
<p>当请求中的ContentType分别为一下三种类型时，结果如下：</p>
<table>
<thead>
<tr>
<th align="center">否加上注解\ContentType</th>
<th align="center">x-www-form-urlencoded</th>
<th align="center">form-data</th>
<th align="center">application/json</th>
</tr>
</thead>
<tbody><tr>
<td align="center">不加@RequestBody注解</td>
<td align="center">能接收</td>
<td align="center">能接收</td>
<td align="center">不能接收</td>
</tr>
<tr>
<td align="center">加上@RequestBody注解</td>
<td align="center">不能接收</td>
<td align="center">不能接收</td>
<td align="center">能接收</td>
</tr>
</tbody></table>
<h2 id="RequestBody使用总结"><a href="#RequestBody使用总结" class="headerlink" title="@RequestBody使用总结"></a>@RequestBody使用总结</h2><p>@RequestBody用于需要触发HttpMessageConverter的场景：</p>
<ul>
<li>当HTTP请求的Content-Type头部为application/json时，需要加上@RequestBody注解，并使用默认的<code>HttpMessageConverter</code>或者自定义的<code>HttpMessageConverter</code>对请求的body中的json字符串转换为java对象。</li>
<li>当Content-Type头部的值为application/x-www-form-urlencoded或者multipart/form-data时，表名此请求是一个常规的表单请求，不能使用@RequestBody注解。</li>
</ul>
<p><strong>注意</strong>：使用@RequestBody注解的参数必须使用VO对象的方式去接收，否则会接收不到参数</p>
<p><strong>参考地址:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b5efff0e51d45198469acea">Spring之RequestBody的使用姿势小结</a></li>
<li><a target="_blank" rel="noopener" href="https://www.0php.net/posts/HTML-%E8%A1%A8%E5%8D%95%E4%B9%8B%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5-enctype.html">HTML 表单之不得不知 ENCTYPE</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data">Stackoverflow上大神的回答</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/08/24/Untitled/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/24/Untitled/" class="post-title-link" itemprop="url">在云服务器上搭建Hexo之一顿百度加谷歌</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-24 15:46:00" itemprop="dateCreated datePublished" datetime="2019-08-24T15:46:00+08:00">2019-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 22:51:05" itemprop="dateModified" datetime="2021-04-06T22:51:05+08:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Daily/" itemprop="url" rel="index"><span itemprop="name">Daily</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/08/24/Untitled/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/08/24/Untitled/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天周六，没啥事干，看书也看不进去T_T，<del>华农兄弟：这样下去不行的</del>。刚好前几天跟风买了个阿里云1H2G1M的云服务器，一年114块，肉疼。。，想着把电脑里面的Hexo乱七八糟的都搬到云服务器上去，这样在公司也可以瞎鸡儿写点东西了，建站的话目前还不想弄，放到GitHub上既稳定，又省力。</p>
<p>现在使用的Hexo是便携版的，安装没有什么技术含量，一键安装，这次想试一试使用完整版的Hexo,如果失败了再用便携版；文字编辑使用的是知乎上搜到的<code>hexo-admin</code>插件，非常好用，也不用敲太多命令行，直接点击就可以发布，很方便，但是唯一的缺点就是不能在线编辑，所以在公司精力十足的时候想记录一点学到的东西，但是只能写到别的地方，回来再使用hexo发布，很不方便，同时回到家就想洗了睡，根本不想打开电脑，所以如果能够在公司和家里都能记录，想想都很开心。</p>
<p>因为<code>hexo-admin</code>会打开本地的4000端口，用浏览器访问<code>localhost:4000</code>就可以直接开始用，所以我目前的想法是把hexo部署到阿里云的主机上，安装上admin的插件，然后把服务器的4000端口打开，再安装一个nginx对外面的访问进行代理，这样在外网上输入云服务器的ip+4000端口就可以访问了，按道理是可行的，如果再设置一下hosts文件，那岂不是和家里使用一模一样了，所以想试一试。成功了就去楼下网吧玩几个小时放松一下嘤嘤嘤。</p>
<p>由于linux命令行只会一点皮毛的皮毛的皮毛的皮毛的皮毛的皮毛的皮毛的皮毛的皮毛的皮毛的皮毛（吃了没有文化的亏.jpg）,所以只能一边百度一边弄。开始了开始了。</p>
<h1 id="安装必须的乱七八糟的软件"><a href="#安装必须的乱七八糟的软件" class="headerlink" title="安装必须的乱七八糟的软件"></a>安装必须的乱七八糟的软件</h1><p>搭建Hexo需要以下东西，一个一个来。</p>
<ul>
<li>Git</li>
<li>NodeJs</li>
<li>Hexo</li>
</ul>
<p><strong>参考地址：</strong><br> <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42943548/article/details/90342319">让你的Hexo博客支持远程编辑！</a></p>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>首先凭印象敲，使用<code>yum install git</code>,过一会儿提示安装完成，使用<code>git --version</code> 查看git的版本为1.8.3.1，网上说版本太老了，所以要安装新版本的git，yum里面的版本太老了。</p>
<ol>
<li>使用<code>yum remove git</code>删除旧版本的git。</li>
<li>然后把最新版本的git下载到/usr/local/software文件夹下<code>tar -zxvf name</code>解压。</li>
<li>安装编译所需的组件<code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker</code>，这个过程会安装yum上的git,所以还需要删除旧版本的git。</li>
<li>使用<code>make prefix=/usr/local/git</code>执行编译，并制定编译之后的文件夹路径</li>
<li>使用<code>make prefix=/usr/local/git</code>安装git到指定文件夹</li>
<li>使用<code>git --version</code>查看是否安装成功，对于文章中的倒数第二步的设置环境变量我没有做，不晓得行不行。</li>
</ol>
<p><strong>参考地址：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/imyalost/p/8715688.html">CentOS安装git</a></li>
</ul>
<h2 id="安装NodeJS"><a href="#安装NodeJS" class="headerlink" title="安装NodeJS"></a>安装NodeJS</h2><p>我直接使用<code>yum install nodejs</code>yum安装nodejs，hexo要求nodejs必须6.9以后的版本，yum中的版本是6.17，满足要求就OK了。使用<code>node --version</code>查看当前安装的版本是否符合要求</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>这步就直接使用hexo文档上的说明进行安装：</p>
<pre><code class="bash">npm install -g hexo-cli
</code></pre>
<p>安装完成使用<code>hexo -version</code>查看版本</p>
<h2 id="安装hexo-admin插件"><a href="#安装hexo-admin插件" class="headerlink" title="安装hexo-admin插件"></a>安装hexo-admin插件</h2><p>在安装插件之前，需要初始化博客，步骤如下：</p>
<ol>
<li>cd进入你想要的文件夹下，例如：<code>cd /usr/local/hexo/</code></li>
<li>初始化博客<code>hexo init blog</code>这回创建一个blog文件夹</li>
<li>执行<code>cd blog</code>之后再执行<code>npm install</code></li>
<li>这里需要删除hexo默认的文章<code>rm source/_posts/hello-world.md</code>,然后执行<code>rm -rf themes/landscape</code>删除默认的主体</li>
</ol>
<p>初始化博客之后，就可以安装<code>hexo-admin</code>插件插件了，这个部分可以使用<a target="_blank" rel="noopener" href="https://jaredforsyth.com/hexo-admin/">hexo-admin官网</a>上的教程进行安装</p>
<pre><code class="bash">npm install --save hexo-admin
</code></pre>
<p>安装完成后，使用<code>hexo c</code>、<code>hexo s</code>、<code>hexo g</code>、<code>hexo d</code> 命令开始使用了。以前使用便携版时，命令行简化了server，直接使用<code>hexo -s</code>就可以使用。<br>因为以前的文章都在本地的电脑中，需要将source.post文件夹下的文件拷贝到云服务器上，配置文件和主题也可以考过去，省的重新配置麻烦。</p>
<p>注意，如果这个时候执行<code>hexo d</code>进行部署，会提示:    </p>
<pre><code class="bash">ERROR Deployer not found: git
</code></pre>
<p>按照网上搜索的，首先需要安装一个插件：    </p>
<pre><code class="bash">npm install --save hexo-deployer-git
</code></pre>
<p>然后使用<code>hexo d</code>命令会提示需要设置git邮箱和用户名，所以按照提示的命令，对git邮箱和名字进行设置：        </p>
<pre><code class="bash">git config --global user.email &quot;邮箱&quot;
git config --global user.name &quot;名字&quot;
</code></pre>
<p>然后就可以使用<code>hexo d</code>进行部署了</p>
<p>然而在使用hexo-admin插件总的Deploy功能部署时，会提示：</p>
<pre><code class="bash">Error: Config value &quot;admin.deployCommand&quot; not found
</code></pre>
<p>需要创建一个脚本，然后点击发布按钮时，会执行这个脚本，步骤如下：</p>
<ol>
<li><p>在_config.yml里面填写好deployCommand的存储路径之后，在该路径下生成脚本；</p>
<pre><code class="bash">touch deploy.sh;
vim deploy.sh;
</code></pre>
</li>
<li><p>输入以下内容</p>
<pre><code class="bash">#!/usr/bin/env sh
hexo g
hexo d
</code></pre>
</li>
<li><p>保存退出，并赋予执行权限：</p>
<pre><code class="bash">chmod +x deploy.sh
</code></pre>
</li>
</ol>
<p>修改配置文件,在hexo的配置文件_config.yml文件中的admin配置下面加入下面的配置，指定脚本的位置：</p>
<pre><code class="yml">admin:
  deployCommand: &#39;./hexo-publish.sh&#39;
</code></pre>
<p>但是这时候如果使用hexo-admin自带的Deploy按钮进行部署，会发现依旧是部署不成功的，这时，需要配置一下云服务器上的git的SSH，然后需要在hexo的配置文件_config.yml文件中，使用SSH的仓库地址而非https的，具体步骤如下：</p>
<ol>
<li><p>查看是否已经有了ssh密钥：cd ~/.ssh<br>如果没有密钥则不会有此文件夹，有则备份删除</p>
</li>
<li><p>生成密钥：</p>
<pre><code class="git">ssh-keygen -t rsa -C &quot;gudujianjsk@gmail.com&quot;
</code></pre>
<p>按3个回车，密码为空这里一般不使用密钥。<br>最后得到了两个文件：id_rsa和id_rsa.pub</p>
</li>
<li><p>在github上添加ssh密钥，这要添加的是“id_rsa.pub”里面的公钥。打开<code>http://github.com</code>，登陆。</p>
</li>
<li><p>进入github设置页面，添加新的key。<br><img src="/images/githubAddSSH.png" alt="upload successful"></p>
</li>
<li><p>修改hexo的配置文件_config.yml，将其中的repo仓库地址更换为SSH的地址，而非HTTPS的地址：<br><img src="/images/deployDir.png" alt="upload successful"></p>
</li>
</ol>
<p>上面的步骤中第五步非常重要，否则使用Deploy功能时依旧会报错:<code>could not read Password for...</code>,必须使用SSH类型的仓库地址，这样的话hexo d命令也不需要输入密码了。很省力的。    </p>
<p><strong>参考地址：</strong>        </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zxlovenet/p/4571850.html">为你的git添加SSH</a></li>
</ul>
<p>弄完上面的步骤之后，就可以进行编辑和发布了，日常的功能算式满足了。开心，部署的时候会提示下面的错误，但是不用管，这是nodejs版本的问题：</p>
<pre><code class="txt">WARN  ===============================================================
WARN  ========================= ATTENTION! ==========================
WARN  ===============================================================
WARN   NexT repository is moving here: https://github.com/theme-next 
WARN  ===============================================================
WARN   It&#39;s rebase to v6.0.0 and future maintenance will resume there
WARN  ===============================================================
fatal: could not read Password for &#39;https://super-aviator@github.com&#39;: No such device or address
FATAL Something&#39;s wrong. you can find the solution here: https://hexo.io/docs/troubleshooting.html
Error: Spawn failed
    at ChildProcess.&lt;anonymous&gt; (/usr/local/hexo/blog/node_modules/hexo-util/lib/spawn.js:52:19)
    at emitTwo (events.js:106:13)
    at ChildProcess.emit (events.js:191:7)
    at Process.ChildProcess._handle.onexit (internal/child_process.js:219:12)
</code></pre>
<p>如果搜索功能不能用的话，需要重新安装搜索的插件：</p>
<pre><code class="bash">npm install hexo-generator-searchdb --save
</code></pre>
<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>安装nginx也可以使用yum中的bginx,使用<code>yum install -y nginx</code> 或者<code>yum install nginx</code>安装ngingx，前者与后者的区别是不用手动输入y。。。</p>
<p>安装之后的nginx的默认目录为：</p>
<ul>
<li>Nginx配置路径：/etc/nginx/</li>
<li>PID目录：/var/run/nginx.pid</li>
<li>错误日志：/var/log/nginx/error.log</li>
<li>访问日志：/var/log/nginx/access.log</li>
<li>默认站点目录：/usr/share/nginx/html</li>
</ul>
<p>最重要的是配置文件的目录为<code>/etc/nginx/nginx.conf</code>,默认端口为80</p>
<ul>
<li>可以使用<code>netstat -ntulp |grep 80</code>查看80端口下是否有进程占用</li>
<li>可以使用<code>ps -ef|grep nginx</code>查看进程的进程号</li>
<li>使用<code>kill -QUIT 2072</code>停止进程号的进程</li>
<li>使用<code>nginx</code>启动nginx</li>
<li>使用<code>nginx -t</code>检查配置文件语法</li>
<li>使用<code>nginx -s reload</code>重启nginx </li>
</ul>
<p><strong>参考地址：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://my.oschina.net/andyfeng/blog/1634805">CentOS下安装nginx</a>        </li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35888875/article/details/80937731">CentOS7下的nginx安装</a></li>
</ul>
<h2 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h2><p>到这一步，我已经完成了大部分的安装工作，接下来就需要配置nginx了，因为hexo的命令<code>hexo g</code>会在public文件夹下面生成所有网页的.html文件，所以需要把nginx的root目录指向public文件夹，根目录/设置为index.html，这样当浏览器访问到ip的80端口时，就可以直接进入index.html主页。</p>
<p>修改<code>etc/nginx/nginx.conf</code>文件，在80端口配置一下：</p>
<pre><code class="nginx">server &#123;
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  xqk;
        root         /usr/local/hexo/blog/public;

        # Load configuration files for the default server block.
        include /etc/nginx/default.d/*.conf;

        location / &#123;
             index index.html index.htm;
        &#125;
&#125;
</code></pre>
<p>在这之前，需要开启云服务器的端口80和4000，开启的时候，值得注意的是，<strong>授权对象里面，如果填写0.0.0.0/0则表示允许所有人访问。</strong></p>
<p>按照上面的操作之后，如果在浏览器直接数据ip地址，就可以访问到hexo -g生成的文章了。</p>
<p>但是需要注意的是，这个生成的文章不是动态的，在admin页面编辑的文章在这里是不能动态改变的，还是得需要到4000端口去访问，是不是瞬间感觉有点鸡肋了呢。。。</p>
<h2 id="升级nodejs和hexo的版本"><a href="#升级nodejs和hexo的版本" class="headerlink" title="升级nodejs和hexo的版本"></a>升级nodejs和hexo的版本</h2><p>在hexo-admin的说明文档中，我发现hexo-admin是支持直接粘贴图片的，沃德天，那么帅，这不正是我一直想要的功能吗？结果在新搭建的hexo中使用hexo-admin插件编辑文章的时候并不能粘贴图片，what？？？，<del>长得丑就不能粘贴了吗？</del></p>
<p>一顿百度加谷歌之后，还是百思不得姐啊，但是我一直怀疑是hexo版本太低的原因，第三天之后，也就是2019-8-27，我升级了一下hexo的版本，发现竟然可以粘贴图片了。耶耶耶。</p>
<p>首先升级nodejs的版本，需要使用n模块去升级，至于n模块是什么我也不知道，我也不敢问。。。</p>
<ol>
<li>使用下面的命令安装n模块<pre><code>npm install-g n
</code></pre>
</li>
<li>升级node.js到最新稳定版<pre><code class="bash">n stable
</code></pre>
npm常用地址：</li>
</ol>
<pre><code class="bash">
npm -v          #显示版本，检查npm 是否正确安装。
 
npm install express   #安装express模块
 
npm install -g express  #全局安装express模块
 
npm list         #列出已安装模块
 
npm show express     #显示模块详情
 
npm update        #升级当前目录下的项目的所有模块
 
npm update express    #升级当前目录下的项目的指定模块
 
npm update -g express  #升级全局安装的express模块
 
npm uninstall express  #删除指定的模块
</code></pre>
<p><strong>参考地址：</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/adeyi/article/details/51076274">升级nodejs</a></p>
<p>当前的hexo版本可使用<code>hexo --version</code> 去查看：<br><img src="/images/hexoVersion.png" alt="upload successful"><br>现在的版本是2.0.0,确实是有点太低了，又一顿百度加谷歌之后，我学会了升级hexo，步骤如下：</p>
<ol>
<li>cd进入你的博客目录下，例如：<code>cd /usr/local/hexo/blog</code></li>
<li>执行命令<code>npm update</code><br>过一段时候之后，你在该目录下执行hexo –version就会发现hexo的版本已经更新了。</li>
</ol>
<p>回到hexo-admin中，体验一下markdown中复制粘贴图片所带来的乐趣吧。如果粘贴图片发现不能正常显示的话，尝试点击一下这个按钮:<br><img src="/images/showImage.png" alt="upload successful">然后再切换回来编辑页面，图片就可以正常显示啦。</p>
<h2 id="后台运行hexo命令"><a href="#后台运行hexo命令" class="headerlink" title="后台运行hexo命令"></a>后台运行hexo命令</h2><p>因为目前是在远程终端中执行的hexo -s命令，所以当终端断开的时候命令也就终止执行了，那么就需要将命令放在后台执行，这样就可以将hexo的命令脱离终端来运行了，网查又又是一顿查，发现可以使用nohup命令来实现，具体操作的步骤如下：        </p>
<p>nohup的使用方式是<code>nohup [command] &amp;</code>，末尾的&amp;也可以不加，加上&amp;表示后台执行。<br>然后命令就会脱离终端自己去撒丫子运行，这时候如果重新登录终端，会发现命令依旧在执行。例如，在云服务器中执行如下命令（<strong>别忘了cd进入博客文件夹内部执行</strong>）：</p>
<pre><code class="bash">nohup hexo s &amp;
</code></pre>
<p>然后退出终端再次登录终端，<strong>注意</strong>，退出终端需要使用exit命令的方式去退出，否则nohup不能在后台运行。<br>重新登录终端后，使用</p>
<pre><code class="bash">ps aux |grep hexo
</code></pre>
<p>会发现hexo进程在后台执行：<br><img src="/images/nohupBackgroup.png" alt="upload successful"></p>
<p>使用下面的命令提取hexo进程的pid：</p>
<pre><code class="bash">ps -aux|grep hexo| grep -v grep | awk &#39;&#123;print $2&#125;&#39;
</code></pre>
<p>得到hexo进程的pid之后，如果想要终止该进程，可以使用下面的命令去终止掉该PID对应的进程:</p>
<pre><code class="bash">kill -9 PID
</code></pre>
<p>好了，启动和终止都学会了，可以满足最基本的需求了嘤嘤嘤。</p>
<p><strong>参考地址：</strong><br><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/704932">nohup 命令解析</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>零零散散弄了三四五六天终于算是完成了，以后也可以在公司也能记东西啦，美滋滋。</p>
<p>唯一遗憾的是当初买云服务器的时候没有选择<code>轻量应用服务器</code>,选择的是<code>ESC</code>，但是<code>ESC</code>带宽只有1M，所以加载文章列表的时候太慢了，下载速度只有128kb/s，8M大小的文章列表要等一分钟左右才能全部加载完毕。。。<code>轻量应用服务器</code>有5M的峰值带宽，加载的时候会快很多。有点后悔啊，失算失算。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/07/23/ySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/23/ySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">MySQL常用的数据类型与表设计要点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-23 22:12:00" itemprop="dateCreated datePublished" datetime="2019-07-23T22:12:00+08:00">2019-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:06" itemprop="dateModified" datetime="2021-02-23T21:00:06+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Database/" itemprop="url" rel="index"><span itemprop="name">Database</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/07/23/ySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/07/23/ySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>写这篇东西的起因是今天在公司的接口评审会时，组里的成员提了一个问，她看见组里开发人员设计的表中，有的主键使用的数据类型是INT(11)，而有的使用的是INT(15),有的使用的是BIGINT(16)啥的，所以她问可不可能存在数值溢出的情况，这是我想起来以前看的一篇博客，说括号里的数字并不是代表能够存储的范围，而是为了填充零，所以我和她说表示的数据范围是不变的，都是INT都是四字节，但是组里的大佬们一致认为INT（11）表示的是能够存储的最大数字位数为11位，能够满足业务需求，在大佬们的一再强调下我他喵的动摇了。。。开始自闭。</p>
<p>所以只知识不能是一知半解滴，so，结合《深入浅出MySQL》这本书，来了解一下MySQL的数据类型吧，同时因为最近在写的接口需要自己设计表结构，所以结合前几天看的<code>孤独烟</code>的关于表设计要点的博客，总结一下设计表的一些要点。</p>
<h1 id="MySQL常见的数据类型"><a href="#MySQL常见的数据类型" class="headerlink" title="MySQL常见的数据类型"></a>MySQL常见的数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>MySQL中的整型包括TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT。他们各自表示的范围如下:<br><img src="https://s2.ax1x.com/2019/07/28/eQONan.png" alt="eQONan.png"><br>需要注意的是，<strong>整型也可以后面加上数据，例如int(10)，表示存储的数值小于多少10位时，在数值的左侧使用零填充，需要配合ZEROFILL和UNSIGNED关键字使用(ZEROFILL域自动是UNSIGNED的)，而不是表示能存储多少位的数字。</strong></p>
<h2 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h2><p>MySQL中的小数类型包括浮点数和定点数，浮点数包括FLOAT（单精度浮点数）,DOUBLE（双精度浮点数），定点数包括DECIMAL(也叫作NUMERIC),他们对应的长度如下：<br><img src="https://s2.ax1x.com/2019/07/28/el8Z9A.png" alt="el8Z9A.png"><br>浮点数和定点数都可以使用非标准用法：<code>[FLOAT|DOUBLE|DECIMAL]（M,D）</code>的方式使用，M称为<strong>精度</strong>，D称为<strong>标度</strong>，表示的是可以存储M为数字，其中包括D位小数，所以在创建小数类型的字段时需要保证M&gt;=D（当M==D时，只能存储D位小数，数值大小不能大于1），值得注意的是，不使用精度和标度时，FLOAT和DOUBLE按存储的位数进行保存，而DECIMAL默认整数为10位，小数为0位，即（10,0）,同时非标准用法可移植性差，在需要迁移的数据库中不应该使用，当存入的数的小数部分的位数多于指定的标度D时，数据库会对数据进行自动四舍五入。</p>
<p><strong>FLOAT和DOUBLE由于计算机存储方式的原因，精度会有损失，而DECIMAL不会，所以在存储货币等精度要求高的数据时需要使用DECIMAL类型</strong></p>
<h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><p>MySQL中有以下四种时间类型，使用时需要根据业务区决定：<br><img src="https://s2.ax1x.com/2019/07/28/el25Of.png" alt="el25Of.png"></p>
<p>当插入的时间超出给定的范围时，插入的数据会变成零值。</p>
<p>其中，值得注意的是TIMESTAMP类型会跟着数据库的时区进行变化，所以不同时区多对应的TIMESTAMP类型的数据是不一样的。还需要注意的是，一张表中，最多可以有一列数据可以为CURRENT_TIMESTAMP类型，即如果该列插入null值，则数据库会自动将其设置为当前时间，<strong>注意，每个数据库最多只能有一列拥有CURRENT_TIMESTAMP属性。</strong></p>
<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><h2 id="JSON类型"><a href="#JSON类型" class="headerlink" title="JSON类型"></a>JSON类型</h2><p>Mysql5.7中新增了JSON数据格式，专门用于保存JSON字符串，结合<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/json.html">官方文档</a>，来看一下这种数据格式相对于TEXT有什么优势以及几个常用的用于处理JSON字符串的JSON函数吧：</p>
<p>上面的文字表名JSON格式存储的大小和LONGBOB、LONGTEXT格式的大小差不多，同时长度的最大保存大小为系统变量max_allowed_packet的值，当在内存操作时，可能会大于这个值。同时，<strong>JSON格式的数据不能是NOT-NULL的，经过我的测试证实了这一点，即JSON格式的数据默认是NULL的。</strong>，MySQL内部使用utf8mb4字符集和utf8mb4_bin排序规则处理JSON上下文中使用的字符串。 其他字符集中的字符串将根据需要转换为utf8mb4。（对于ascii或utf8字符集中的字符串，不需要转换，因为ascii和utf8是utf8mb4的子集。）</p>
<p><strong>注意：</strong>当插入的JSON对象字符串的键重复时，只会保留最后一个该键的键值对，例如：</p>
<pre><code class="sql">CREATE TABLE t1 (c1 JSON);

INSERT INTO t1 VALUES(&#39;&#123;&quot;x&quot;: 17, &quot;x&quot;: &quot;red&quot;&#125;&#39;),(&#39;&#123;&quot;x&quot;: 17, &quot;x&quot;: &quot;red&quot;, &quot;x&quot;: [3, 5, 7]&#125;&#39;);

SELECT c1 FROM t1;
&gt;+-----------+
 | c1        |
 +-----------+
 | &#123;&quot;x&quot;: 17&#125; |
 | &#123;&quot;x&quot;: 17&#125; |
 +-----------+
</code></pre>
<h3 id="Mysql中常用的JSON函数"><a href="#Mysql中常用的JSON函数" class="headerlink" title="Mysql中常用的JSON函数"></a>Mysql中常用的JSON函数</h3><ul>
<li><p>JSON_VALID<br>JSON_VALID用于判断参数中的JSON字符串是否是合法的，如果合法返回1，如果非法，返回0，如果参数为空，则报错。</p>
<pre><code class="sql">SELECT JSON_VALID(&#39;[&quot;KEY&quot;:1]&#39;);
&gt; 1

SELECT JSON_VALID(&#39;[&quot;KEY&quot;:1&#39;);
&gt; 0
</code></pre>
</li>
</ul>
<p>SELECT JSON_VALID();</p>
<blockquote>
<p>error</p>
</blockquote>
<pre><code>
- JSON_TYPE
JSON_TYPE()函数返回参数中JSON字符串的类型，如果参数为空或者不是JSON类型的字符串，则报错：
```sql
SELECT JSON_TYPE(&quot;[1,2,3]&quot;);
&gt; ARRRAY

SELECT JSON_TYPE(&#39;&#123;&quot;k1&quot;:23&#125;&#39;);
&gt; OBJECT

SELECT JSON_TYPE();
&gt; Error Code: 1582. Incorrect parameter count in the call to native function &#39;JSON_TYPE&#39;    0.000 sec

SELECT JSON_TYPE(&quot;[1,2,3]&quot;)=&#39;ARRAY&#39;;
&gt; 1
</code></pre>
<ul>
<li>JSON_ARRAY<br>JSON_ARRAY会返回包含所有参数的JSON数组字符串，当参数为空时返回空JSON数组，当参数不为JSON字符串格式时报错。<pre><code class="sql">SELECT JSON_ARRAY(&#39;A&#39;,23,45.3);
&gt; [&quot;A&quot;, 23, 45.3]
</code></pre>
</li>
</ul>
<p>SELECT JSON_ARRAY();</p>
<blockquote>
<p>[]</p>
</blockquote>
<pre><code>
- JSON_OBJECT
JSON_OBJECT函数和JSON_ARRAY函数类似，返回参数对构成的JSON对象，**JSON要求键必须是字符串类型。**
```sql
SELECT JSON_OBJECT(&#39;key1&#39;,1,&#39;key2&#39;,&#39;hello&#39;);
&gt; &#123;&quot;key1&quot;: 1, &quot;key2&quot;: &quot;hello&quot;&#125;

SELECT JSON_OBJECT();
&gt; &#123;&#125;
</code></pre>
<ul>
<li>JSON_MERGE<br>JSON_MERGE函数返回两个或多个JSON字符串拼接之后的字符串,当参数都是JSON对象时，拼接之后结果的JSON_TYPE为OBJECT,当参数含有JSON数组时，返回结果的JSON_TYPE为JSON数组。<strong>当拼接的JSON对象中包含有相同的键时，该键对应的值会以数组的形式保存。</strong>，<strong>当拼接的参数是单个数值而非JSON字符串或者单个字母时，该函数的结果相当于JSON_ARRAY。首先会将单个的数字用[]包围，然后对其进行合并</strong>    <pre><code class="sql">SELECT JSON_MERGE(&#39;&#123;&quot;key1&quot;:1,&quot;key2&quot;:&quot;hello&quot;&#125;&#39;,&#39;[1,2,3]&#39;);
&gt; [&#123;&quot;key1&quot;: 1, &quot;key2&quot;: &quot;hello&quot;&#125;, 1, 2, 3]
</code></pre>
</li>
</ul>
<p>SELECT JSON_MERGE(‘{“key1”:1,”key2”:”hello”}’,’{“key3”:123}’);</p>
<blockquote>
<p>{“key1”: 1, “key2”: “hello”, “key3”: 123}</p>
</blockquote>
<p>SELECT JSON_MERGE(‘{“a”:1}’,’{“a”:2}’,’[“A”]’);</p>
<blockquote>
<p>[{“a”: [1, 2]}, “A”]</p>
</blockquote>
<pre><code>
所有的JSON函数的返回结果都可以使用变量进行保存，方便以后使用，例如：
```sql
SET @J = JSON_MERGE(&#39;1&#39;,&#39;2&#39;);
SELECT @J;
&gt; [1, 2]
</code></pre>
<h1 id="MySQL表设计的要点"><a href="#MySQL表设计的要点" class="headerlink" title="MySQL表设计的要点"></a>MySQL表设计的要点</h1><p>日常的开发过程中需要自己设计表，但是自己太菜了，设计的时候毫不隐晦的说，都是瞎鸡儿设计的。。。（如果组长看到了，会不会过来捶我，哈哈哈）；今天下班比较早，根据知乎上的文章，学习一下MySQL表的设计要点，后面如果有新的知识点继续补充。</p>
<h2 id="问题1-为什么一定要设一个主键？"><a href="#问题1-为什么一定要设一个主键？" class="headerlink" title="问题1:为什么一定要设一个主键？"></a>问题1:为什么一定要设一个主键？</h2><p><strong>回答:</strong><br>因为你不设主键的情况下，innodb也会帮你生成一个隐藏列，作为自增主键。所以啦，反正都要生成一个主键，那你还不如自己指定一个主键，在有些情况下，就能显式的用上主键索引，提高查询效率！</p>
<h2 id="问题2-主键是用自增还是UUID"><a href="#问题2-主键是用自增还是UUID" class="headerlink" title="问题2:主键是用自增还是UUID?"></a>问题2:主键是用自增还是UUID?</h2><p><strong>回答:</strong><br>肯定答自增啊。innodb 中的主键是聚簇索引。如果主键是自增的，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果不是自增主键，那么可能会在中间插入，就会引发页的分裂，产生很多表碎片！。</p>
<p>上面那句话看不懂没事，大白话一句就是:用自增插入性能好！<br>另外，附一个测试表给你们，表名带uuid的就是用uuid作为主键。大家看一下就知道性能差距了:<br><img src="/images/uuid.png" alt="upload successful"><br>如上图所示，当主键是UUID的时候，插入时间更长，而且占用空间更大！<br>额，大家千万不要忘了，当你回答自增主键后，想一下<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwMDgzMjc3NA==&mid=2247484464&idx=1&sn=f783fc5f7fe3d7714247c3c21d0a93f6&chksm=96f66659a181ef4fa02303b4974031b3f40bc1bdd76bad31a60fbaa54f2e63e62fcede88e4cd&token=1510096404&lang=zh_CN#rd">自增主键用完该怎么办？</a>        </p>
<p>ps：这个问题，你要是能把UUID讲出合理的理由也行。</p>
<h2 id="问题3-主键为什么不推荐有业务含义"><a href="#问题3-主键为什么不推荐有业务含义" class="headerlink" title="问题3:主键为什么不推荐有业务含义?"></a>问题3:主键为什么不推荐有业务含义?</h2><p><strong>回答:</strong><br>有如下两个原因<br>(1)因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。主键一旦发生变更，该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。<br>(2)带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面插入数据的主键一定比前面的数据大。如果出现了，后面插入数据的主键比前面的小，就有可能引发页分裂，产生空间碎片。</p>
<h2 id="问题4-表示枚举的字段为什么不用enum类型？"><a href="#问题4-表示枚举的字段为什么不用enum类型？" class="headerlink" title="问题4:表示枚举的字段为什么不用enum类型？"></a>问题4:表示枚举的字段为什么不用enum类型？</h2><p>回答:在工作中表示枚举的字段，一般用tinyint类型。</p>
<p>那为什么不用enum类型呢？下面两个原因</p>
<ol>
<li>ENUM类型的ORDER BY操作效率低，需要额外操作</li>
<li>语法中，查询枚举值应该是字符串类型，所以需要格外注意</li>
</ol>
<h2 id="问题5-货币字段用什么类型"><a href="#问题5-货币字段用什么类型" class="headerlink" title="问题5:货币字段用什么类型?"></a>问题5:货币字段用什么类型?</h2><p>回答:如果货币单位是分，可以用Int类型。如果坚持用元，用Decimal。</p>
<p>千万不要答float和double，因为float和double是以二进制存储的，所以有一定的误差。 打个比方，你建一个列如下</p>
<pre><code class="sql">CREATE TABLE `t` (
  `price` float(10,2) DEFAULT NULL,
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre>
<p>然后insert给price列一个数据为1234567.23，你会发现显示出来的数据变为1234567.25，精度失准！</p>
<h2 id="问题6-时间字段用什么类型"><a href="#问题6-时间字段用什么类型" class="headerlink" title="问题6:时间字段用什么类型?"></a>问题6:时间字段用什么类型?</h2><p>回答:此题无固定答案，应结合自己项目背景来答！把理由讲清楚就行！</p>
<ol>
<li><p>varchar，如果用varchar类型来存时间，优点在于显示直观。但是坑的地方也是挺多的。比如，插入的数据没有校验，你可能某天就发现一条数据为2013111的数据，请问这是代表2013年1月11日，还是2013年11月1日？ 其次，做时间比较运算，你需要用STR_TO_DATE等函数将其转化为时间类型，你会发现这么写是无法命中索引的。数据量一大，是个坑！</p>
</li>
<li><p>timestamp，该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。2038年以后的时间，是无法用timestamp类型存储的。 但是它有一个优势，timestamp类型是带有时区信息的。一旦你系统中的时区发生改变，例如你修改了时区</p>
<pre><code class="sql">SET TIME_ZONE = &quot;america/new_york&quot;;
</code></pre>
<p> 你会发现，项目中的该字段的值自己会发生变更。这个特性用来做一些国际化大项目，跨时区的应用时，特别注意！</p>
</li>
<li><p>datetime，datetime储存占用8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显然，存储时间范围更大。但是它坑的地方在于，他存储的是时间绝对值，不带有时区信息。如果你改变数据库的时区，该项的值不会自己发生变更！</p>
</li>
<li><p>bigint，也是8个字节，自己维护一个时间戳，表示范围比timestamp大多了，就是要自己维护，不大方便。</p>
</li>
</ol>
<h2 id="问题7-为什么不直接存储图片、音频、视频等大容量内容"><a href="#问题7-为什么不直接存储图片、音频、视频等大容量内容" class="headerlink" title="问题7:为什么不直接存储图片、音频、视频等大容量内容?"></a>问题7:为什么不直接存储图片、音频、视频等大容量内容?</h2><p>回答:我们在实际应用中，都是用HDFS来存储文件。然后mysql中，只存文件的存放路径。mysql中有两个字段类型被用来设计存放大容量文件，也就是text和blob类型。但是，我们在生产中，基本不用这两个类型！</p>
<p>主要原因有如下两点</p>
<ol>
<li><p>Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。导致查询效率缓慢</p>
</li>
<li><p>binlog内容太多。因为你数据内容比较大，就会造成binlog内容比较多。大家也知道，主从同步是靠binlog进行同步，binlog太大了，就会导致主从同步效率问题！</p>
</li>
</ol>
<p>因此，不推荐使用text和blob类型！</p>
<h2 id="问题8-字段为什么要定义为NOT-NULL"><a href="#问题8-字段为什么要定义为NOT-NULL" class="headerlink" title="问题8:字段为什么要定义为NOT NULL?"></a>问题8:字段为什么要定义为NOT NULL?</h2><p>回答:OK，这问题从两个角度来答</p>
<p>(1)索引性能不好</p>
<blockquote>
<p>Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。 —— 出自《高性能mysql第二版》</p>
</blockquote>
<p>(2)查询会出现一些不可预料的结果 这里举一个例子，大家就懂了。假设，表结构如下</p>
<pre><code class="sql">create table table_2 (
     `id` INT (11) NOT NULL,
    name varchar(20) NULL
)
</code></pre>
<p>表数据是这样的<br><img src="/images/demo1.png" alt="upload successful"><br>你执行语句<code>select count(name) from table_2;</code><br>你会发现结果为2，但是实际上是有四条数据的！</p>
<p>类似的查询问题，其实有很多，不一一列举。 记住，因为null列的存在，会出现很多出人意料的结果，从而浪费开发时间去排查Bug.</p>
<h1 id="COUNT-1-、COUNT-、COUNT-FILE-的区别"><a href="#COUNT-1-、COUNT-、COUNT-FILE-的区别" class="headerlink" title="COUNT(1)、COUNT(*)、COUNT(FILE)的区别"></a>COUNT(1)、COUNT(*)、COUNT(FILE)的区别</h1><p>COUNT(1)与COUNT(*)的执行效果、性能是一样的，会统计数据库表中所有数据的函数（<strong>包括NULL的情况</strong>），而COUNT(FILE)则只会统计该字段的非NULL的数据的行数，执行效率上也会比前两者慢很多倍。</p>
<p>参考地址：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/73260510">MySQL表设计要点</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/07/08/%E6%9C%AC%E5%9C%B0Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8ESpringBoot%E4%B8%ADJedis%E9%9B%86%E7%BE%A4%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/08/%E6%9C%AC%E5%9C%B0Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8ESpringBoot%E4%B8%ADJedis%E9%9B%86%E7%BE%A4%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">本地Redis集群的搭建与SpringBoot中JedisCluster客户端的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-08 22:30:00" itemprop="dateCreated datePublished" datetime="2019-07-08T22:30:00+08:00">2019-07-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:04" itemprop="dateModified" datetime="2021-02-23T21:00:04+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Database/" itemprop="url" rel="index"><span itemprop="name">Database</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/07/08/%E6%9C%AC%E5%9C%B0Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8ESpringBoot%E4%B8%ADJedis%E9%9B%86%E7%BE%A4%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/07/08/%E6%9C%AC%E5%9C%B0Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8ESpringBoot%E4%B8%ADJedis%E9%9B%86%E7%BE%A4%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近在学习《Redis开发与运维》这本书，没有很仔细的看，主要讲解的运维，也包含有开发的部分，重点看了开发的部分，感觉这本书写的是真的好，整本书没有一点废话（Thinking In Java退出群聊QAQ ），全部是干货，昨天跟着书本在电脑上搭建了一个Redis集群，公司的Redis也是集群的方式，所以学习一下集群中的Redis和单机的区别，同时熟悉一下Redis集群的搭建的步骤和SpringBoot中对Redis Cluster的整合，不过我是在Windows下搭建的，命令都是一样的，没什么区别。</p>
<h1 id="Redis集群搭建的步骤和槽的概念"><a href="#Redis集群搭建的步骤和槽的概念" class="headerlink" title="Redis集群搭建的步骤和槽的概念"></a>Redis集群搭建的步骤和槽的概念</h1><p>Redis集群搭建主要分为一下几个步骤：</p>
<ol>
<li>准备节点(启动Redis服务)</li>
<li>节点握手</li>
<li>分配槽</li>
<li>为主节点分配从结点</li>
</ol>
<p>在开始搭建之前复习一下Redis的槽的知识：</p>
<blockquote>
<p>Redis Cluser采用虚拟槽分区，所有的键根据哈希函数映射到0~16383整<br>数槽内，计算公式：slot=CRC16（key）&amp;16383。每一个节点负责维护一部 分槽以及槽所映射的键值数据，如图10-5所示。</p>
</blockquote>
<h1 id="Redis集群的限制"><a href="#Redis集群的限制" class="headerlink" title="Redis集群的限制"></a>Redis集群的限制</h1><p>需要注意的是，集群的Redis和单节点的Redis相比，有很多的局限：</p>
<ul>
<li><p>key批量操作支持有限。如mset、mget，目前只支持具有相同slot值的key执行批量操作。对于映射为不同slot值的key由于执行mget、mget等操可 能存在于多个节点上因此不被支持。</p>
</li>
<li><p>key事务操作支持有限。同理只支持多key在同一节点上的事务操作，当多个key分布在不同的节点上时无法使用事务功能。 </p>
</li>
<li><p>key作为数据分区的最小粒度，因此不能将一个大的键值对象如hash、list等映射到不同的节点。 </p>
</li>
<li><p>不支持多数据库空间。单机下的Redis可以支持16个数据库，集群模式下只能使用一个数据库空间，即db0。</p>
</li>
<li><p>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</p>
</li>
</ul>
<h1 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h1><p>Redis集群一般由多个节点组成，节点数量至少为6个才能保证组成完整<br>高可用的集群。在windows下将redis文件夹拷贝6份，如图所示：<br><img src="https://s2.ax1x.com/2019/07/08/ZsYKKO.png" alt="ZsYKKO.png"></p>
<h2 id="运行服务"><a href="#运行服务" class="headerlink" title="运行服务"></a>运行服务</h2><p>然后为每个redis服务，都要使用如下的配置，根据端口号的不同进行区分。每个节点需要开启配置cluster-enabled yes，让Redis运行在集群模式下。建议为集群内所有节点统一目录，一般划分三个目录：conf、 data、log，分别存放配置、数据和日志相关文件。把6个节点配置统一放在 conf目录下，集群相关配置如下：</p>
<pre><code class="yml">#节点端口 
port 7000 
# 开启集群模式 
cluster-enabled yes 
# 节点超时时间，单位毫秒 
cluster-node-timeout 15000 
# 集群内部配置文件 
cluster-config-file &quot;nodes-7000.conf&quot;
</code></pre>
<p>然后使用下面的命令开启Redis服务：</p>
<pre><code class="yml">redis-server conf/redis-&#123;port&#125;.conf # port为该端口对应的配置文件
</code></pre>
<p>集群中每一个节点都有一个配置文件，保存了集群信息，集群配置文件由服务自动生成，不需要手动去修改，以免出现错误。</p>
<h2 id="节点间握手"><a href="#节点间握手" class="headerlink" title="节点间握手"></a>节点间握手</h2><p>现在开启了六个Redis服务，但是他们是彼此分离的，还没有组合成一个集群，所以需要使用命令让他们握手，形成一个能够互相感知的集群。</p>
<p>登录某一个结点，然后分别使用下面的命令去和每一个节点握手：</p>
<pre><code class="yml">cluster meet&#123;ip&#125;&#123;port&#125;
</code></pre>
<p>也可以使用Redis Shell命令去执行，例如</p>
<pre><code class="yml">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1:7001
redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1:7002
...
</code></pre>
<p>需要注意的是，只需要在一个结点上执行握手命令，握手信息会在集群中自动传播。这样其他节点会自动发现新节点并发起握手流程。最后执行<code>cluster nodes</code>命令确认6个节点都彼此感知并组成集群。</p>
<p>可以使用<code>cluster nodes</code>查看集群结点的状态：</p>
<pre><code class="yml">089f76372aa3f9373f72850ebb5909c978665c3b 127.0.0.1:7001 master - 0 1562679329399 1 connected 5462-10922    
605773c926b468fb079cfacf021bdeea2ecc1747 127.0.0.1:7002 myself,master - 0 0 5 connected 10923-16383    
c8f0ae93b339311acb74807bdaead7cbf6eb5738 127.0.0.1:7004 slave 089f76372aa3f9373f72850ebb5909c978665c3b 0 1562679330363 1 connected    
551693dbe8904405e925ec1fab859051597905d4 127.0.0.1:7003 slave 53613c8c8c7e0f060de44a36c94e0abf35d8cee0 0 1562679329297 3 connected    
c8317c12ddb83e22c3b0244d21e1ea53c7a56e00 127.0.0.1:7005 slave 605773c926b468fb079cfacf021bdeea2ecc1747 0 1562679327174 5 connected    
53613c8c8c7e0f060de44a36c94e0abf35d8cee0 127.0.0.1:7000 master - 0 1562679331423 2 connected 0-5461    
</code></pre>
<p>上面是槽点分配完成的结点。<br>可以使用<code>cluster info</code>查看集群状态：</p>
<pre><code class="yml">cluster_state:down
cluster_slots_assigned:o
cluster_slots_ok:0
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:3
cluster_current_epoch:5
cluster_my_epoch:5
cluster_stats_messages_sent:82521
cluster_stats_messages_received:82273
</code></pre>
<p>从中可以看出集群中共有六个节点，并已近互相感知了对方的存在。此时集群状态为down,表示不可用。</p>
<h2 id="分配槽点"><a href="#分配槽点" class="headerlink" title="分配槽点"></a>分配槽点</h2><p>Redis集群中，数据保存的位置是通过key的映射的槽点来决定的，Redis集群把所有的数据映射到16384个槽中（0-16383）。每个key会映射为一个固定的槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。通过 <code>cluster addslots</code>命令为节点分配槽。这里利用bash特性批量设置槽（slots）， 命令如下：</p>
<pre><code class="yml">redis-cli -h 127.0.0.1 -p 6379 cluster addslots &#123;0...5461&#125;     
redis-cli -h 127.0.0.1 -p 6380 cluster addslots &#123;5462...10922&#125;     
redis-cli -h 127.0.0.1 -p 6381 cluster addslots &#123;10923...16383&#125;
</code></pre>
<p>不过windows下不支持节点批量操作，只能手动去添加，可以手动写一个脚本去自动添加结点，windows平台下，可以新建一个bat脚本，然后复制如下代码（<strong>脚本是网上照着别人的100求和的脚本改的，执行的慢的很。。。</strong>）：</p>
<ul>
<li>7000节点 addslots.bat</li>
</ul>
<pre><code class="bat">@echo off
setlocal ENABLEDELAYEDEXPANSION
for /l %%i in (0,1,5461) do (
    redis-cli -h 127.0.0.1 -p 7000 cluster addslots %%i
    REM echo %%i
)
pause
</code></pre>
<ul>
<li>7001节点 addslots.bat</li>
</ul>
<pre><code class="bat">@echo off
setlocal ENABLEDELAYEDEXPANSION
for /l %%i in (5462,1,10922) do (
    redis-cli -h 127.0.0.1 -p 7001 cluster addslots %%i
    REM echo %%i
)
pause
</code></pre>
<ul>
<li>7002结点 addslots.bat</li>
</ul>
<pre><code class="bat">@echo off
setlocal ENABLEDELAYEDEXPANSION
for /l %%i in (10923,1,16383) do (
    redis-cli -h 127.0.0.1 -p 7002 cluster addslots %%i
    REM echo %%i
)
pause
</code></pre>
<p>在等待脚本执行完成之后，所有的槽点都均匀的分配给了三个主节点，集群的状态也从不可用变为可用状态，可以使用<code>cluster info</code>查看集群状态，使用<code>cluster nodes</code>查看槽点的分配。</p>
<h2 id="设置从结点"><a href="#设置从结点" class="headerlink" title="设置从结点"></a>设置从结点</h2><p>首次启动的节点和被分配槽的 节点都是主节点，从节点负责复制主节点槽信息和相关的数据。使用cluster replicate {nodeId}命令让一个节点成为从节点。其中命令执行必须在对应的 从节点上执行，nodeId是要复制主节点的节点ID，命令如下：</p>
<pre><code class="yml">127.0.0.1:7003&gt;cluster replicate cfb28ef1deee4e0fa78da86abe5d24566744411e OK 
127.0.0.1:7004&gt;cluster replicate 8e41673d59c9568aa9d29fb174ce733345b3e8f1 OK 
127.0.0.1:7005&gt;cluster replicate 40b8d09d44294d2e23c7c768efc8fcd153446746 OK
</code></pre>
<p>同样也可以编写脚本添加从结点，例如如下代码将7003节点设置为7000的从结点：</p>
<ul>
<li>7003 replicate.bat</li>
</ul>
<pre><code class="yml">@echo off
setlocal ENABLEDELAYEDEXPANSION

redis-cli -h 127.0.0.1 -p 7003 cluster replicate 53613c8c8c7e0f060de44a36c94e0abf35d8cee0

pause
</code></pre>
<p>目前为止，我们依照Redis协议手动建立一个集群。它由6个节点构成，3个主节点负责处理槽和相关数据，3个从节点负责故障转移。Redis官方推荐使用Ruby的工具Redis-trib.rb来搭建Redis集群，不过这就是运维的事情了。（我主要还是嫌安装Ruby啥的太麻烦了QAQ，懒得弄。）</p>
<h1 id="SpringBoot中JedisCluster客户端的使用"><a href="#SpringBoot中JedisCluster客户端的使用" class="headerlink" title="SpringBoot中JedisCluster客户端的使用"></a>SpringBoot中JedisCluster客户端的使用</h1><p>SpringBoot中，可以会用Spring-Data-Redis对Redis进行操作，所有的Redis操作都被封装在Template模板中。</p>
<p>在application.yml配置文件中，需要指定集群的各个节点的IP、端口号。并且需要指定redis第一次连接到的结点信息。在yml中，配置如下：</p>
<pre><code class="yml">spring:
  redis:
    host: 127.0.0.1
    database: 0
    ssl: false
    port: 7000
    cluster:
      # redis集群的ip和端口
      nodes: 127.0.0.1:7000,127.0.0.1:7001,127.0.0.1:7002,
               127.0.0.1:7003,127.0.0.1:7004,127.0.0.1:7005
      max-redirects: 1 #集群最大跳转次数
    jedis:
      pool:
        max-active: 8 #线程池中最大线程数
        min-idle: 2 #最大空闲线程数
    timeout: 5000ms #连接超时时间
</code></pre>
<p>在集群模式下，Redis接收任何键相关命令时首先计算键对应的槽，再根据槽找出所对应的节点，如果节点是自身，则处理键命令；否则回复 MOVED重定向错误，通知客户端请求正确的节点。这个过程称为MOVED重 定向</p>
<p>redis-cli可以使用-c参数自动帮我们连接到正确的节点执行命令，这个过程是在redis-cli内部维护，实质上是client端接到MOVED信息之后再次发起请求，并不在 Redis节点中完成请求转发</p>
<pre><code class="yml">redis-cli -h 127.0.0.1 -p 7000 -c
</code></pre>
<p>redis客户端执行命令的方式如下：</p>
<ol>
<li>计算slot并根据slots缓存获取目标节点连接，发送命令。         </li>
<li>如果出现连接错误，使用随机连接重新执行键命令，每次命令重试<br>对redi-rections参数减1。    </li>
<li>捕获到MOVED重定向错误，使用cluster slots命令更新slots缓存<br>（renewSlotCache方法）。 </li>
<li>重复执行1）~3）步，直到命令执行成功，或者当redirections&lt;=0时<br>抛出Jedis ClusterMaxRedirectionsException异常。</li>
</ol>
<p>上面的配置中，max-redirects指定了集群中的最大跳转次数，如果查找键时跳转的次数超过阈值，就会抛出异常。</p>
<p>SpringDataRedis封装了Redis的操作，所有操作通过RedisTemplate提供相同的模板,使用方式为：</p>
<pre><code class="java">@Autowired
private RedisTemplate&lt;String,String&gt; StringRedisTemplate;
</code></pre>
<p>对于String类型的键和值，RedisTemplat提供了StringRedisTemplate可以直接注入使用。</p>
<pre><code class="java">@Autowired
private StringRedisTemplate stringRedisTemplate;
</code></pre>
<p>对于所有的非String类型，不能直接使用上面的方式，直接注入指定泛型类型的RedisTemplate，而需要使用下面的方式，配置特定类型的RedisTemplate的键和值的序列化器，才能够注入并使用：</p>
<pre><code class="java">    /**
     * 特定类型的RedisTemplate需要自己创建相应的bean才行。
     *
     * @param redisConnectionFactory redis连接池
     * @return 指定泛型类型的RedisTemplate
     */
    @Bean
    public RedisTemplate&lt;String, User&gt; getRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;
        RedisTemplate&lt;String, User&gt; redisTemplate = new RedisTemplate&lt;&gt;();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        //设置key的序列化器，非常重要
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        //设置value的序列化器
        redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(User.class));
        return redisTemplate;
    &#125;
</code></pre>
<p><strong>值得注意的是，如果不指定键的序列化器，可能会导致redis中存入的键因为编码的方式不同，在RedisTemplate中存入的键，使用命令行的方式查找失败。</strong></p>
<p>上面的值的序列化器有多种选择，最常规的是序列化为JSON字符串进行保存。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/06/22/Spring-Data-JPA%E4%B8%AD%E7%9A%84%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%8C%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/22/Spring-Data-JPA%E4%B8%AD%E7%9A%84%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%8C%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2/" class="post-title-link" itemprop="url">Spring Data JPA中的一对一，一对多，多对多查询</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-22 19:10:00" itemprop="dateCreated datePublished" datetime="2019-06-22T19:10:00+08:00">2019-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 20:59:58" itemprop="dateModified" datetime="2021-02-23T20:59:58+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/06/22/Spring-Data-JPA%E4%B8%AD%E7%9A%84%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%8C%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/06/22/Spring-Data-JPA%E4%B8%AD%E7%9A%84%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%8C%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这几天学习一下Spring Data JPA中的一对一、一对多、多对多映射。这些映射还分单向关联和双向关联，在双向关联时还需要考虑对象序列化为JSON字符串时的死循环问题。</p>
<h1 id="单向关联和双向关联"><a href="#单向关联和双向关联" class="headerlink" title="单向关联和双向关联"></a>单向关联和双向关联</h1><ul>
<li><p><strong>单向关联</strong>  单向关联指的是实体类A中有一个实体类B变量，但是实体类B中没有实体类A变量，即为单向关联。</p>
</li>
<li><p><strong>双向关联</strong>  双向关联指的是实体类A中有一个实体类B变量，而实体类B中也含有一个实体类A变量，即为双向关联。</p>
</li>
</ul>
<p><strong>值得注意的是：Spring Data JPA中属性的集合需要使用Set来保存，如果使用List会抛出异常。</strong></p>
<h1 id="双向关联中序列化的死循环问题"><a href="#双向关联中序列化的死循环问题" class="headerlink" title="双向关联中序列化的死循环问题"></a>双向关联中序列化的死循环问题</h1><p>在双向关联时，可能会存在对象序列化成JSON字符创时的死循环问题，因为A中包含B，B中也包含A，序列化A中的B时，因为B也含有A，A又含有B，所以会死循环。</p>
<blockquote>
</blockquote>
<p>特南克斯<br>首先你要理解这是双向关联，双向关联中你如果从数据库里面查询一个User对象，那么User对象里面有Role，Role里面又有User对象，那么你用syso输出User对象，如果toString方法里面包含有输出User.roles的话，那么是必然会造成死循环的。如果你用sping mvc等框架将后台数据返回给前台也是同理，也会造成返回的JSON数据死循环</p>
<p>使用Jackson时，可以使用@JsonIgnoreProperties注解来解决：</p>
<pre><code class="java"> @JsonIgnoreProperties(value = &#123; &quot;users&quot; &#125;)
    @ManyToMany(cascade = CascadeType.ALL,fetch = FetchType.LAZY)
    @JoinTable(
            name = &quot;TEACHER_USER_RELATION&quot;,
            joinColumns = 
            @JoinColumn(name = &quot;UserId&quot;,referencedColumnName = &quot;id&quot;),
            inverseJoinColumns = 
            @JoinColumn(name = &quot;TeacherId&quot;,referencedColumnName = &quot;id&quot;)
    )
    private Set&lt;Teacher&gt; teachers;
</code></pre>
<p>@JsonIgnoreProperties(value = { “users” })注解排除了Teacher中的User字段，从而避免了死循环问题。</p>
<h1 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h1><p>一对一映射需要@OneToOne注解和@JoinColumn注解配合使用，为了创建测试数据，首先定义一个User实体类，然后定义一个UserDetail实体类，其中User与UserDetail的关系是一对一的关系，即一个User对应一个UserDetail，一个UserDetail对应一个User。具体代码如下：</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;USER&quot;)
public class User &#123;

        ...

    /**
     * 一对一
     */
    @JoinColumn(name = &quot;id&quot;,referencedColumnName = &quot;id&quot;)
    @OneToOne(cascade = &#123;CascadeType.ALL&#125;,fetch = FetchType.LAZY)    
    private UserDetail userDetail;
&#125;
</code></pre>
<p>在被关联的UserDetail代码如下：</p>
<pre><code class="java">@Entity
@Data
@Table(name = &quot;USER_DETAIL&quot;)
public class UserDetail &#123;
    @Id
    @GeneratedValue
    @Column(name = &quot;ID&quot;)
    private Long id;

    @Column(name = &quot;CREDIT&quot;)
    private Float credit;

    @Column(name = &quot;ENROLLMENT_DATE&quot;)
    private Date enrollmentDate;

    @Column(name = &quot;USER_ID&quot;)
    private Long userId;
&#125;
</code></pre>
<p>UserDetail中没有User类型成员变量，所以User与UserDetail的关联是单向关联，如果UserDetail中也含有一个User类型的变量，则为双向关联；（单向和双向关联只与是否包含对象有关，和是否使用注解无关。）</p>
<p>同时需要在User类型的变量名中增加@OneToOne(mappedBy=”userDetail”)注解，表示两者的关系由User实体去维护，如果配置了Cascade，对User的操作也会影响到UserDetail实体。</p>
<p>上面代码中的@OneToOne注解中，可以定义级联操作，包括级联新建、级联删除、级联更新、级联刷新。</p>
<p><strong>@JoinColumn注解中的name元素为被关联对象的id，即UserDetail类的id，而referencedColumnName则为关联对象的id,即@JoinColumn所在实体类的id。</strong></p>
<h1 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h1><p>一对多需要使用@JoinColumn注解和@OneToMany配置使用，如果是双向关联，则还需要在被关联的实体类的成员变量中使用@ManyToOne。</p>
<p>为了创建测试环境，需要新建一个UserFriend实体类，一个User可以有一个或多个UserFriend。</p>
<p>User实体类中需要包含一个集合类型的UserFriend成员变量：</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;USER&quot;)
public class User &#123;
    
    ...
    
     /**
     * 一对多
     */
    @OneToMany(cascade = &#123;CascadeType.ALL&#125;,fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;userId&quot;,referencedColumnName = &quot;id&quot;)
    private Set&lt;UserFriend&gt; userFriends;
&#125;
</code></pre>
<p>@OneToMany注解和@JoinColumn注解需要配合使用，@OneToMany注解中同样可以指定级联操作和加载类型。</p>
<p><strong>@JoinColumn注解中，name元素为被被关联实体类中的id，而referencedColumnName元素为关联实体类中的id,即@JoinColumn所在实体类的id。</strong></p>
<p>UserFriend实体类代码如下：</p>
<pre><code class="java">@Entity
@Data
@Table(name = &quot;USER_FRIEND&quot;)
public class UserFriend &#123;
    @Id
    @GeneratedValue
    @Column(name = &quot;ID&quot;)
    private Long id;

    private Long userId;

    @Column(name = &quot;FRIEND_ID&quot;)
    private Long friendId;
&#125;
</code></pre>
<p>由于使用的是单向关联，UserFriend实体类没有对应的User成员变量，所以是单向关联，如果需要指定关系的维护方，需要在使用没有@JoinColumn的实体类上使用注解@OneToMany(mappedBy)。</p>
<h1 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h1><p>多对多和一对一、一对多不同，需要引入两者之间的关系表，关系表负责维护两者之间的关系，起到至关重要的作用，Spring Data JPA中，需要使用@ManyToMany注解和@JoinTable注解配合使用。</p>
<p>为了创建多对多的测试环境，需要创建一个Teacher实体类：</p>
<pre><code class="java">@Entity
@Data
@Table(name = &quot;TEACHER&quot;)
public class Teacher &#123;

    @Id
    @GeneratedValue
    @Column(name = &quot;ID&quot;)
    private Long id;

    @Column(name = &quot;NAME&quot;)
    private String name;

    @ManyToMany(mappedBy = &quot;teachers&quot;)
    private List&lt;User&gt; users;
&#125;
</code></pre>
<p>Teacher中，由于也包含User的集合，所以Teacher与User是双向关联，在Teacher中使用@ManyToMany(mappedBy)注解申明User类为双方关系的维护方，即删除User也会删除关联的Teacher和关系表中的数据，但删除Teacher不会删除User表中的数据。</p>
<p>User类中，需要加入@JoinTable和@ManyToMany注解：</p>
<pre><code class="java">public class User&#123;
    ...

    /**
     * 多对多
     */
    @JsonIgnoreProperties(value = &#123; &quot;users&quot; &#125;)
    @ManyToMany(cascade = CascadeType.ALL,fetch = FetchType.LAZY)
    @JoinTable(
            name = &quot;TEACHER_USER_RELATION&quot;,
            joinColumns = 
            @JoinColumn(name = &quot;UserId&quot;,referencedColumnName = &quot;id&quot;),
            inverseJoinColumns = 
            @JoinColumn(name = &quot;TeacherId&quot;,referencedColumnName = &quot;id&quot;)
    )
    private Set&lt;Teacher&gt; teachers;
&#125;
</code></pre>
<p><strong>@JoinTable中的name需要填写中间关系表的表明</strong></p>
<p>joinColumns中的name和inverseJoinColumns中的name需要填关系表TEACHER_USER_RELATION的实体的字段名<br>如果关系表TEACHER_USER_RELATION的实体中的字段使用了@Column(name)，那么需要填写注解中指定的名字，即表字段名。<br>referencedColumnName填写的是本实体类中的关联的字段。</p>
<h1 id="使用-OrderBy进行排序"><a href="#使用-OrderBy进行排序" class="headerlink" title="使用@OrderBy进行排序"></a>使用@OrderBy进行排序</h1><p>在一对多或者多对多映射中，如果想要对得到的集合进行排序，可以使用@OrderBy注解，@OrderBy中只需要指定想要排序的字段以及排序的方向即可：</p>
<pre><code class="java">    /**
     * 一对多
     */
    @OneToMany(cascade = &#123;CascadeType.ALL&#125;,fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;userId&quot;,referencedColumnName = &quot;id&quot;)
    @OrderBy(&quot;friend_id DESC&quot;)
    private Set&lt;UserFriend&gt; userFriends;
</code></pre>
<p>上面的代码中，Set中的UserFriend会使用Friend进行倒序排序。</p>
<p>值得注意的是，即使用Set集合也可以保证有序性，在Hibernate内部使用了自定义集合PersistentSet，此集合是有序集合。</p>
<h1 id="mappedBy元素说明"><a href="#mappedBy元素说明" class="headerlink" title="mappedBy元素说明"></a>mappedBy元素说明</h1><p>@OneToOne、@OneToMany、@ManyToMany中可以使用mappedBy元素定义被关联着和关联着的关系由谁去维护，即关系的操纵权在那一方，同时<strong>mappedBy不能和@JoinTable、@JoinColumn注解同时存使用</strong>。</p>
<h1 id="使用-EntityGraph和-NamedEntityGraph解决N-1问题"><a href="#使用-EntityGraph和-NamedEntityGraph解决N-1问题" class="headerlink" title="使用@EntityGraph和@NamedEntityGraph解决N+1问题"></a>使用@EntityGraph和@NamedEntityGraph解决N+1问题</h1><p>在常规的多对多和一对多查询时，会面临N+1问题：<br>N+1问题指的是，如果一个User对应N个Friend，在查询某id的User时，会首先执行一条SQL语句查询该User，然后会执行N条SQL语句查询该User对应的N个Friend,过程中一共使用了N+1条语句，效率会非常低下，正确的做法是使用内连接和外链接，只需要一条语句。</p>
<p>Spring Data JPA中针对N+1问题有相应的优化，使用@EntityGraph和@NamedEntityGraph就可以解决N+1问题。</p>
<p>首先需要在User实体类上使用@NamedEntityGraph注解：</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;USER&quot;)
@NamedEntityGraph(
        name = &quot;UserEntity&quot;,
        attributeNodes = &#123;
                @NamedAttributeNode(&quot;userDetail&quot;),
                @NamedAttributeNode(&quot;userFriends&quot;),
                @NamedAttributeNode(&quot;teachers&quot;),
        &#125;
)
public class User &#123;
...
&#125;
</code></pre>
<p>上面代码中，name可以随便定义，在@EntityGraph中会对其进行引用，@NamedAttributeNode中的value元素即为需要解决N+1问题的字段。</p>
<p>在Repository中，对需要解决N+1问题的方法上使用的@EntityGraph注解就可以了：</p>
<pre><code class="java">public interface UserJpaRepository&lt;T&gt; extends JpaRepository&lt;User,Long&gt; &#123;
   @EntityGraph(&quot;UserEntity&quot;)
   List&lt;User&gt; findByNameContaining(String name);
&#125;
</code></pre>
<p>注解中的value是@NamedEntityGraph定义的name。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/06/20/Spring-Data-JPA%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/20/Spring-Data-JPA%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Spring Data JPA进阶学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-20 12:14:00" itemprop="dateCreated datePublished" datetime="2019-06-20T12:14:00+08:00">2019-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-10 13:21:30" itemprop="dateModified" datetime="2021-03-10T13:21:30+08:00">2021-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/06/20/Spring-Data-JPA%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/06/20/Spring-Data-JPA%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这几天静下心来深入学习一下Spring Data Jpa的深入知识，参考书籍为《Spring Data JPA从入门到精通》，感觉作者写的很乱，不过收获应该还是很多的。</p>
<h1 id="Repository中方法的关键字"><a href="#Repository中方法的关键字" class="headerlink" title="Repository中方法的关键字"></a>Repository中方法的关键字</h1><p>Repository中的方法有很多关键字可以使用，在阅读书的时候发现了很多以前没有使用到并且没有注意到的细节问题：<br><img src="https://resource-1259322763.cos.ap-guangzhou.myqcloud.com/hexo-client/2021/03/10/4a80612f-efe1-4204-ad88-0b656d82338f.png" alt="VjOABt.png"></p>
<ul>
<li>小于使用LessThan关键字，大于使用GreaterThan关键字</li>
<li>小于等于使用LessThanEqual关键字，大于等于使用GreaterThanEqual关键字</li>
<li>时间的比较需要使用After和Before</li>
<li>like关键字不会在参数前后加上%,StartingWith关键字会在参数前加%，EndingWith关键字会在参数后加%，而Containing关键字会在参数前后都加上%，一般用于模糊查询。</li>
<li>In关键字的参数是Collection接口</li>
<li>对于忽略大小写的比较，可以使用IgnoreCase关键字</li>
</ul>
<h1 id="数据的分页和排序"><a href="#数据的分页和排序" class="headerlink" title="数据的分页和排序"></a>数据的分页和排序</h1><p>查询数据时如果想要对数据进行分页，只需要在查询方法中加入Pagable对象，并返回Page或者Slice对象即可，调用时，参数使用PageRequest，并在构造函数中传入起始页以及每页显示的项目数即可。如果想要对分页的数据进行排序，可以在PageRequest构造器中传入Sort对象即可。</p>
<h1 id="GeneratedValue的四种主键生成策略"><a href="#GeneratedValue的四种主键生成策略" class="headerlink" title="GeneratedValue的四种主键生成策略"></a>GeneratedValue的四种主键生成策略</h1><p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/hongchengshise/p/10612301.html">GenerationType四中类型</a></p>
<p>JPA提供的四种标准用法为TABLE,SEQUENCE,IDENTITY,AUTO.</p>
<ul>
<li>TABLE：使用一个特定的数据库表格来保存主键。</li>
<li>SEQUENCE：根据底层数据库的序列来生成主键，条件是数据库支持序列。</li>
<li>IDENTITY：主键由数据库自动生成（主要是自动增长型）</li>
<li>AUTO：主键由程序控制。</li>
</ul>
<h2 id="GenerationType-TABLE"><a href="#GenerationType-TABLE" class="headerlink" title="GenerationType.TABLE"></a>GenerationType.TABLE</h2><p>使用一个特定的数据库表格来保存主键,持久化引擎通过关系数据库的一张特定的表格来生成主键,这种策略的好处就是不依赖于外部环境和数据库的具体实现,在不同数据库间可以很容易的进行移植,但由于其不能充分利用数据库的特性,所以不会优先使用。该策略一般与另外一个注解一起使用@TableGenerator,@TableGenerator注解指定了生成主键的表(可以在实体类上指定也可以在主键字段或属性上指定),然后JPA将会根据注解内容自动生成一张表作为序列表(或使用现有的序列表)。如果不指定序列表,则会生成一张默认的序列表,表中的列名也是自动生成,数据库上会生成一张名为sequence的表(SEQ_NAME,SEQ_COUNT)。序列表一般只包含两个字段:第一个字段是该生成策略的名称,第二个字段是该关系表的最大序号,它会随着数据的插入逐渐累加。</p>
<pre><code class="java">@Id
    @Column(name=&quot;id&quot;)
    @GeneratedValue(strategy=GenerationType.TABLE,generator=&quot;table_gen&quot;)
    @TableGenerator(
            name = &quot;table_gen&quot;,  
            table=&quot;fendo_generator&quot;,  
            pkColumnName=&quot;seq_name&quot;,     //指定主键的名字
            pkColumnValue=&quot;fendos&quot;,      //指定下次插入主键时使用默认的值
            valueColumnName=&quot;seq_id&quot;,    //该主键当前所生成的值，它的值将会随着每次创建累加
            initialValue = 1,            //初始化值
            allocationSize=1             //累加值
            )
    public Integer getUid() &#123;
        return uid;
    &#125;
</code></pre>
<h2 id="GenerationType-SEQUENCE"><a href="#GenerationType-SEQUENCE" class="headerlink" title="GenerationType.SEQUENCE"></a>GenerationType.SEQUENCE</h2><p>在某些数据库中,不支持主键自增长,比如Oracle,其提供了一种叫做”序列(sequence)”的机制生成主键。此时,GenerationType.SEQUENCE就可以作为主键生成策略。该策略的不足之处正好与TABLE相反,由于只有部分数据库(Oracle,PostgreSQL,DB2)支持序列对象,MYsql不支持序列,所以该策略一般不应用于其他数据库。类似的,该策略一般与另外一个注解一起使用@SequenceGenerator,@SequenceGenerator注解指定了生成主键的序列.然后JPA会根据注解内容创建一个序列(或使用一个现有的序列)。如果不指定序列,则会自动生成一个序列SEQ_GEN_SEQUENCE。</p>
<pre><code>@Id  
@GeneratedValue(strategy = GenerationType.SEQUENCE,generator=&quot;fendo_seq&quot;)  
@SequenceGenerator(name=&quot;fendo_seq&quot;, sequenceName=&quot;seq_name&quot;)
</code></pre>
<h2 id="GenerationType-IDENTITY"><a href="#GenerationType-IDENTITY" class="headerlink" title="GenerationType.IDENTITY"></a>GenerationType.IDENTITY</h2><p>此种主键生成策略就是通常所说的主键自增长,数据库在插入数据时,会自动给主键赋值,比如MySQL可以在创建表时声明”auto_increment” 来指定主键自增长。该策略在大部分数据库中都提供了支持(指定方法或关键字可能不同),但还是有少数数据库不支持,所以可移植性略差。使用自增长主键生成策略是只需要声明strategy = GenerationType.IDENTITY即可。</p>
<pre><code class="java">@Id  
@GeneratedValue(strategy = GenerationType.IDENTITY)
</code></pre>
<h2 id="GenerationType-AUTO"><a href="#GenerationType-AUTO" class="headerlink" title="GenerationType.AUTO"></a>GenerationType.AUTO</h2><p>把主键生成策略交给持久化引擎(persistence engine),持久化引擎会根据数据库在以上三种主键生成策略中选择其中一种。此种主键生成策略比较常用,由于JPA默认的生成策略就是GenerationType.AUTO,所以使用此种策略时.可以显式的指定@GeneratedValue(strategy = GenerationType.AUTO)也可以直接@GeneratedValue。</p>
<pre><code class="java">@Id  
@GeneratedValue(strategy = GenerationType.AUTO)
</code></pre>
<h2 id="各种数据库支持的类型"><a href="#各种数据库支持的类型" class="headerlink" title="各种数据库支持的类型"></a>各种数据库支持的类型</h2><p><img src="https://s2.ax1x.com/2019/06/20/VvNLYd.png" alt="各种数据库支持的类型"></p>
<h1 id="使用Projections查询部分字段"><a href="#使用Projections查询部分字段" class="headerlink" title="使用Projections查询部分字段"></a>使用Projections查询部分字段</h1><p>在写代码时常常有这样的业务逻辑，就是仅仅查询实体类的部分字段，而忽略其他的字段，比如查询用户，不包括用户的密码等敏感信息。</p>
<p>Spring Data JPA对Projections有很好的支持，使用方式如下：<br>对于如下的实体类：</p>
<pre><code class="java">@Data
@Entity
public class User &#123;
    @Id
    @GeneratedValue
    private Long id;
    private String name;
    private String email;
    private String address;
&#125;
</code></pre>
<p>如果只想查询用户的name和email字段，首先需要定义一个接口，包含想要查询的字段的<strong>getter方法</strong>：</p>
<pre><code class="java">/**
 * @author Aviator
 */
@ToString
public interface User &#123;
    String getName();
    String getEmail();
&#125;
</code></pre>
<p>然后在Repository中，编写查询方法，方法返回的集合中包含该接口：</p>
<pre><code class="java">public interface UserJpaRepository extends Repository&lt;User,Long&gt; &#123;
    /**
     * 查询所有name的用户
     * @param name 字符串类型
     * @return projection，查询特定字段的值,集合中的User为编写的接口。
     */
    List&lt;User&gt; findUserByName(String name);
&#125;
</code></pre>
<p>这样就可以查询User实体类的name和email字段了：</p>
<pre><code class="java">@RestController
public class UserController &#123;

    @Autowired
    UserJpaRepository userRepository;

    @GetMapping(&quot;/user&quot;)
    public List&lt;UserDTO&gt; getAllUser()&#123;
        return userRepository.findUserByName(&quot;熊乾坤&quot;);
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<pre><code class="json">[&#123;&quot;name&quot;:&quot;熊乾坤&quot;,&quot;email&quot;:&quot;2372389705@qq.com&quot;&#125;,&#123;&quot;name&quot;:&quot;熊乾坤&quot;,&quot;email&quot;:&quot;2372389705@qq.com&quot;&#125;]
</code></pre>
<p>除了使用接口的方式，JPA中也可以使用DTO类来实现Projections:</p>
<pre><code class="java">@Getter
@ToString
public class UserDTO &#123;
    /**
     * 使用Projection时，字段必须为final修饰
     */
    private final String name, email;

    public UserDTO(String name, String email) &#123;
        this.name = name;
        this.email = email;
    &#125;
&#125;
</code></pre>
<p><strong>值得注意的是：如果使用DTO类的方式，类中的字段必须使用final修饰，否则会抛出没有转换器的异常，要注意一下。</strong></p>
<h1 id="使用动态Projections"><a href="#使用动态Projections" class="headerlink" title="使用动态Projections"></a>使用动态Projections</h1><p>上面学习的Projections也支持动态的操作，在Repository定义的方法中，使用泛型，就可以达到动态的映射，可以根据判定条件查询实体类的某些字段：</p>
<pre><code class="java">public interface UserJpaRepository&lt;T&gt; extends Repository&lt;User,Long&gt; &#123;
    /**
     * 使用模糊查询
     * @param name 字符串类型
     * @param tClass 类型信息
     * @return 用户列表
     */
    List&lt;T&gt; findUserByName(String name,Class&lt;T&gt; tClass);
&#125;
</code></pre>
<p>此时，如果想查询User的所有字段，则调用findUserByName方法时只需要指定tClass参数为User.class,如果只需要查询User的部分参数，则tClass参数传入UserDTO.class即可。</p>
<h1 id="合理使用-Modifying注解"><a href="#合理使用-Modifying注解" class="headerlink" title="合理使用@Modifying注解"></a>合理使用@Modifying注解</h1><p>在使用Spring Data JPA对数据库中的数据进行修改或者删除操作时，在使用@Query注解的同时，也需要使用到@Modifying注解，但是单独使用@Modifying注解时可能会因为缓存而导致一些问题。</p>
<p>JPA 的 Repository 提供一种非常易用的机制用于 ORM 方式处理数据，但是如果需要一次性更新一批数据的部分字段，构造所有实体并逐个修改字段再存回数据库就显得有些臃肿。在 JPA 中提供了 @Query 注解用于使用 JPQL 执行数据库操作，如果数据库操作是修改数据而非查询数据，则需要再额外使用 @Modifying 注解提示 JPA 该操作是修改操作。</p>
<p>当进行 find 操作时，JPA 在 EntityManager 中缓存了 find 生成的对象，当再次 find 时会直接返回该对象。于是可能会出现下面这种情况 ,用@Query 定义一个修改状态的方法</p>
<pre><code class="java">public interface EntityRepository extends JpaRepository&lt;Entity, Integer&gt; &#123;

    @Modifying
    @Query(&quot;update Entity set status = &#39;IGNORED&#39; where id = ?1&quot;)
    int updateStatus(int id);

&#125;
</code></pre>
<p>先读取一个对象，再修改对象状态，再次读取对象</p>
<pre><code class="java">Optional&lt;Entity&gt; entityBefore = repository.findById(1);

repository.updateStatus(1);

Optional&lt;Entity&gt; entityAfter = repository.findById(1);
</code></pre>
<p>结果会发现 entityBefore 和 entityAfter 中的 Entity 对象 id 是相同的，中间对状态的修改并没有体现出来！当然，其原因也很明确，**@Query 跟 find 和 save 系列方法是两套不同的体系**，@Query 引起的数据库变更 EntityManager 并不能发现，更进一步说，使用其它工具或者其它框架修改数据库中的数据，也不能及时反应到 JPA 的 find 系列方法上来。</p>
<p>当然，只要有缓存机制就一定不可避免存在此类问题，这仅是个取舍问题而不要认为是 BUG。如果要解决 find 得到的值不是数据库中最新值的问题可以有几种方式，避免使用 @Query 是一种方式，在需要时显式清理 EntityManager 的缓存也是一种方式。Spring Data JPA 提供了另外一种方式则是 @Modifying(clearAutomatically = true)，@Modifying 的 clearAutomatically 属性为 true 时，执行完 modifying query 之后就会清理缓存，从而在下次 find 时就可以读取到数据库中的最新值。</p>
<p>自动清理之后还会带来一个新的问题，clear 操作清理的缓存中，还包括提交后未 flush 的数据，例如调用 save 而不是 saveAndFlush 就有可能不会立即将修改内容更新到数据库中，在 save 之后 flush 之前调用 @Modifying(clearAutomatically = true) 修饰的方法就有可能导致修改丢失。如果再要解决这个问题，还可以再加上另外一个属性 @Modifying(clearAutomatically = true, flushAutomatically = true)，**@Modifying 的 flushAutomatically 属性为 true 时，执行 modifying query 之前会先调用 flush 操作，从而避免数据丢失问题。**</p>
<p>在实际运行中，clear 和 flush 操作都可能需要消耗一定的时间，要根据系统实际情况可以选择使用其中的一个或两个属性，以保证系统的正确性。</p>
<p>参考: flushAutomatically 属性是在 <a target="_blank" rel="noopener" href="https://jira.spring.io/browse/DATAJPA-806">https://jira.spring.io/browse/DATAJPA-806</a> 提出并被采纳的。</p>
<p><strong>参考地址：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://my.oschina.net/u/1762727/blog/2960653">@Modifying注解详解</a></li>
</ul>
<h1 id="Entity中常用的注解"><a href="#Entity中常用的注解" class="headerlink" title="Entity中常用的注解"></a>Entity中常用的注解</h1><p>实体类中有很多可以使用的注解，下面是常用的一些注解：</p>
<h2 id="Basic-fetch-FetchType-optional-true"><a href="#Basic-fetch-FetchType-optional-true" class="headerlink" title="@Basic(fetch=FetchType,optional=true)"></a>@Basic(fetch=FetchType,optional=true)</h2><p>　　@Basic表示一个简单的属性到数据库表的字段的映射,对于没有任何标注的getXxxx()方法,默认 即为 @Basic</p>
<p>　　fetch: 表示该属性的读取策略,有EAGER和LAZY两种,分别表示主支抓取和延迟加载,默认为EAGER.</p>
<ul>
<li>FetchType.LAZY：懒加载，加载一个实体时，定义懒加载的属性不会马上从数据库中加载。</li>
<li>FetchType.EAGER：急加载，加载一个实体时，定义急加载的属性会立即从数据库中加载。</li>
</ul>
<p>比方User类有两个属性，name跟address，就像百度知道，登录后用户名是需要显示出来的，此属性用到的几率极大，要马上到数据库查，用急加载;而用户地址大多数情况下不需要显示出来，只有在查看用户资料是才需要显示，需要用了才查数据库，用懒加载就好了。所以，并不是一登录就把用户的所有资料都加载到对象中，于是有了这两种加载模式。 optional:表示该属性是否允许为null,默认为true</p>
<pre><code class="java">@Basic(optional=false)

　　public String getAddress() &#123; return address; &#125;
</code></pre>
<h2 id="Transient"><a href="#Transient" class="headerlink" title="@Transient"></a>@Transient</h2><p>@Transient表示该属性并非一个到数据库表的字段的映射，表示<br>非持久化属性，与@Basic作用相反。JPA映射数据库的时候忽略它。如果一个属性并非数据库表的字段映射,就务必将其标示为 @Transient ,否则,ORM框架默认其注解为 @Basic</p>
<h2 id="Temporal-TemporalType"><a href="#Temporal-TemporalType" class="headerlink" title="@Temporal(TemporalType)"></a>@Temporal(TemporalType)</h2><p>@Temporal用来设置Date类型的属性映射到对应精度的字段。</p>
<ul>
<li>@Temporal(TemporalType.DATE)映射为日期date（只有<br>日期）。</li>
<li>@Temporal(TemporalType.TIME)映射为时间time（只有<br>时间）。</li>
<li>@Temporal(TemporalType.TIMESTAMP)映射为日期date+<br>time（日期+时间）。</li>
</ul>
<h2 id="Lob"><a href="#Lob" class="headerlink" title="@Lob"></a>@Lob</h2><p>@Lob 将属性映射成数据库支持的大对象类型，支持以下两种数<br>据库类型的字段。</p>
<ul>
<li>Clob（Character Large Ojects）类型是长字符串类型，<br>java.sql.Clob、Character[]、char[]和String将被映射为Clob类 型。</li>
<li>Blob（Binary Large Objects）类型是字节类型，<br>java.sql.Blob、Byte[]、byte[]和实现了Serializable接口的类型 将被映射为Blob类型。</li>
<li>Clob、Blob占用内存空间较大，一般配合<br>@Basic(fetch=FetchType.LAZY)将其设置为延迟加载。</li>
</ul>
<h2 id="Enumerated"><a href="#Enumerated" class="headerlink" title="@Enumerated"></a>@Enumerated</h2><p>在数据库中创建字段时，可以创建枚举类型的字段，例如在User表中，GENDER字段为枚举类型ENUM(‘MALE’,FEMALE)。那么在Entity实体类中需要在字段上使用使用@Enumerated注解，并创建相应的枚举类：</p>
<p>创建Enum：</p>
<pre><code class="java">public enum Gender &#123;
    //男性
    MALE(&quot;男性&quot;),
    //女性
    FEMALE(&quot;女性&quot;);

    private String value;
    Gender(String str)&#123;
        value=str;
    &#125;
&#125;
</code></pre>
<p>然后在实体类中使用@Enumerated注解：</p>
<pre><code class="java">@Entity
@Data
@Table(name = &quot;USER&quot;)
public class User &#123;
    @Id
    @GeneratedValue
    private Long id;

    @Column(name = &quot;NAME&quot;)
    private String name;

    @Column(name = &quot;EMAIL&quot;)
    private String email;

    @Column(name = &quot;ADDRESS&quot;)
    private String address;

    @Enumerated(EnumType.STRING)
    @Column(name = &quot;GENDER&quot;)
    private Gender gender;
&#125;
</code></pre>
<p>这样就可以在实体类中使用枚举类型啦。</p>
<p>值得注意的是，这时插入两条数据，数据库里面的值是MAIL/FMAIL，而不是“男<br>性”/“女性”。<strong>如果我们用@Enumerated(EnumType.ORDINAL)，那么 这时数据库里面的值是0、1。但是实际工作中，不建议用数字下标，因为枚举里面的属性值是会不断新增的，如果新增一个，位置变化了就惨了。</strong></p>
<h2 id="CreatedDate"><a href="#CreatedDate" class="headerlink" title="@CreatedDate"></a>@CreatedDate</h2><p>用来指定当前的时间字段的数据为数据插入时的时间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/06/04/%E8%BD%AC%E8%BD%BD-Lombok%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/04/%E8%BD%AC%E8%BD%BD-Lombok%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" class="post-title-link" itemprop="url">[转载]Lombok安装与常见的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-04 11:26:00" itemprop="dateCreated datePublished" datetime="2019-06-04T11:26:00+08:00">2019-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 20:59:58" itemprop="dateModified" datetime="2021-02-23T20:59:58+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/06/04/%E8%BD%AC%E8%BD%BD-Lombok%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/06/04/%E8%BD%AC%E8%BD%BD-Lombok%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文地址：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuyuegb2312/p/9750462.html">lombok踩坑与思考</a></p>
<p>在实习的时候公司的代码中用到了Lombok，主要是为了简化实体类的代码量，以前这些Getter和Setter方法都是用IDEA的ctrl+insert来生成的，但是为了代码风格的一致性，以后得改用Lombok了。在网上看到一篇关于Lombok踩坑的文章，抄袭一下。</p>
<h1 id="Lombok安装"><a href="#Lombok安装" class="headerlink" title="Lombok安装"></a>Lombok安装</h1><p>想要使用Lombok，首先需要在maven中加入Lombok的依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后需要在IDEA中安装Lombok的插件，在IDEA中点击File-&gt;Settings-&gt;Plugins，然后所有Lombok插件进行安装并重启IDEA，</p>
<p>最后，需要打开IDEA的Annotation Processors，在IDEA中选择File-&gt;Settings-&gt;Build,Execution,deployment-&gt;Compiler-&gt;Annotation Processors，然后勾选Enable annotation processing选项就OK啦。接下来就可以使用Lombok啦。</p>
<h1 id="一些杂七杂八的问题"><a href="#一些杂七杂八的问题" class="headerlink" title="一些杂七杂八的问题"></a>一些杂七杂八的问题</h1><p>以下这些是最初我不喜欢lombok的原因。</p>
<h2 id="额外的环境配置"><a href="#额外的环境配置" class="headerlink" title="额外的环境配置"></a>额外的环境配置</h2><p>作为IDE插件+jar包，需要对IDE进行一系列的配置。目前在idea中配置还算简单，几年前在eclipse下也配置过，会复杂不少。</p>
<h2 id="传染性"><a href="#传染性" class="headerlink" title="传染性"></a>传染性</h2><p>一般来说，对外打的jar包最好尽可能地减少三方包依赖，这样可以加快编译速度，也能减少版本冲突。一旦在resource包里用了lombok，别人想看源码也不得不装插件。</p>
<p>而这种不在对外jar包中使用lombok仅仅是约定俗成，当某一天lombok第一次被引入这个jar包时，新的感染者无法避免。</p>
<h2 id="降低代码可读性"><a href="#降低代码可读性" class="headerlink" title="降低代码可读性"></a>降低代码可读性</h2><p>定位方法调用时，对于自动生成的代码，getter/setter还好说，找到成员变量后find usages，再根据上下文区分是哪种；equals()这种，想找就只能写段测试代码再去find usages了。</p>
<p>目前主流ide基本都支持自动生成getter/setter代码，和lombok注解相比不过一次键入还是一次快捷键的区别，实际减轻的工作量十分微小。</p>
<h1 id="EqualsAndHashCode和equals"><a href="#EqualsAndHashCode和equals" class="headerlink" title="@EqualsAndHashCode和equals()"></a>@EqualsAndHashCode和equals()</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当这个注解设置callSuper=true时，会调用父类的equlas()方法，对应编译后class文件代码片段如下：</p>
<pre><code class="java">public boolean equals(Object o) &#123;
    if (o == this) &#123;
        return true;
    &#125; else if (!(o instanceof BaseVO)) &#123;
        return false;
    &#125; else &#123;
        BaseVO other = (BaseVO)o;
        if (!other.canEqual(this)) &#123;
            return false;
        &#125; else if (!super.equals(o)) &#123;
            return false;
        &#125; else &#123; 
            // 各项属性比较
        &#125;
    &#125;
&#125;
</code></pre>
<p>如果一个类的父类是Object（java中默认没有继承关系的类父类都是Object），那么这里会调用Object的equals()方法，如下</p>
<pre><code class="java">public boolean equals(Object obj) &#123;
    return (this == obj);
&#125;
</code></pre>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>对于父类是Object且使用了@EqualsAndHashCode(callSuper = true) 注解的类，这个类由lombok生成的equals()方法只有在两个对象是同一个对象时，才会返回true，否则总为false，无论它们的属性是否相同。这个行为在大部分时间是不符合预期的，equals()失去了其意义。即使我们期望equals()是这样工作的，那么其余的属性比较代码便是累赘，会大幅度降低代码的分支覆盖率。以一个近6000行代码的业务系统举例，是否修复该问题并编写对应测试用例，可以使整体的jacoco分支覆盖率提高10%~15%。</p>
<p>相反地，由于这个注解在jacoco下只算一行代码，未覆盖行数倒不会太多。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>有几种解决方法可以参考：</p>
<ul>
<li>不使用该注解。大部分pojo我们是不会调用equals进行比较的，实际用到时再重写即可。</li>
<li>去掉callSuper = true。如果父类是Object，推荐使用。</li>
<li>重写父类的equals()方法，确保父类不会调用或使用类似实现的Ojbect的equals()。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>@data注解包含@EqualsAndHashCode注解，由于不调用父类equals()，避免了Object.equals()的坑，但可能带来另一个坑。详见@data章节。</p>
<h1 id="data"><a href="#data" class="headerlink" title="@data"></a>@data</h1><h2 id="从一个坑出来掉到另一个大坑"><a href="#从一个坑出来掉到另一个大坑" class="headerlink" title="从一个坑出来掉到另一个大坑"></a>从一个坑出来掉到另一个大坑</h2><p>上文提到@EqualsAndHashCode(callSuper = true) 注解的坑，那么 @data 是否可以避免呢？很不幸的是，这里也有个坑。<br>由于 @data 实际上就是用的 @EqualsAndHashCode，没有调用父类的equals()，当我们需要比较父类属性时，是无法比较的。示例如下：</p>
<pre><code class="java">@Data
public class ABO &#123;
    private int a;

&#125;

@Data
public class BBO extends ABO &#123;

    private int b;

    public static void main(String[] args) &#123;

        BBO bbo1 = new BBO();
        BBO bbo2 = new BBO();

        bbo1.setA(1);
        bbo2.setA(2);

        bbo1.setB(1);
        bbo2.setB(1);

        System.out.print(bbo1.equals(bbo2)); // true
    &#125;
&#125;
</code></pre>
<p>很显然，两个子类忽略了父类属性比较。这并不是因为父类的属性对于子类是不可见——即使把父类private属性改成protected，结果也是一样——而是因为lombok自动生成的equals()只比较子类特有的属性。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>用了 @data 就不要有继承关系，类似kotlin的做法，具体探讨见下一节</li>
<li>自己重写equals()，lombok不会对显式重写的方法进行生成</li>
<li>显式使用@EqualsAndHashCode(callSuper = true)。lombok会以显式指定的为准。</li>
</ul>
<h2 id="关于-data和data"><a href="#关于-data和data" class="headerlink" title="关于@data和data"></a>关于@data和data</h2><p>在了解了 @data 的行为后，会发现它和kotlin语言中的data修饰符有点像：都会自动生成一些方法，并且在继承上也有问题——前者一旦有继承关系就会踩坑，而后者修饰的类是final的，不允许继承。kotlin为什么要这样做，二者有没有什么联系呢？在一篇流传较广的文章(抛弃 Java 改用 Kotlin 的六个月后，我后悔了(译文))中，对于data修饰符，提到：</p>
<p>Kotlin 对 equals()、hashCode()、toString() 以及 copy() 有很好的实现。在实现简单的DTO 时它非常有用。但请记住，数据类带有严重的局限性。你无法扩展数据类或者将其抽象化，所以你可能不会在核心模型中使用它们。</p>
<p>这个限制不是 Kotlin 的错。在 equals() 没有违反 Liskov 原则的情况下，没有办法产生正确的基于值的数据。</p>
<p>对于Liskov（里氏替换）原则，可以简单概括为：</p>
<p>一个对象在其出现的任何地方，都可以用子类实例做替换，并且不会导致程序的错误。换句话说，当子类可以在任意地方替换基类且软件功能不受影响时，这种继承关系的建模才是合理的。</p>
<p>根据上一章的讨论，equals()的实现实际上是受业务场景影响的，无论是否使用父类的属性做比较都是有可能的。但是kotlin无法决定equals()默认的行为，不使用父类属性就会违反了这个原则，使用父类属性有可能落入调用Object.equals()的陷阱，进入了两难的境地。</p>
<p>kotlin的开发者回避了这个问题，不使用父类属性并且禁止继承即可。只是kotlin的使用者就会发现自己定义的data对象没法继承，不得不删掉这个关键字手写其对应的方法。</p>
<p>回过头来再看 @data ，它并没有避免这些坑，只是把更多的选择权交给开发者决定，是另一种做法。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>其他lombok注解实际使用较少，整体阅读了 官方文档暂时没有发现其他问题，遇到以后继续更新。<br>实际上官方文档中也提到了equals()的坑。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/06/02/SpringBoot%E5%B8%B8%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/02/SpringBoot%E5%B8%B8%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9/" class="post-title-link" itemprop="url">SpringBoot常用的配置项</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-02 11:49:00" itemprop="dateCreated datePublished" datetime="2019-06-02T11:49:00+08:00">2019-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 20:59:58" itemprop="dateModified" datetime="2021-02-23T20:59:58+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/06/02/SpringBoot%E5%B8%B8%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/06/02/SpringBoot%E5%B8%B8%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>SpringBoot减少了Spring应用的大量的配置，但是开发者可能还需要对项目的细节进行微调，以满足自己特殊的需求，而这些配置项都应该在项目自带的配置文件application.properties中进行配置，如下是一些经常会用到的配置项，以后忘记了可以到这里看一看：</p>
<h1 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h1><pre><code class="yaml">spring:
  datasource:
    url:jdbc: mysql://127.0.0.1:3306/yxb?useSSL=false&amp;useUnicode=true
            &amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai
    driver: com.mysql.cj.jdbc.Driver    #一般不需要指定
    username: root
    password: 123456
</code></pre>
<h1 id="设置项目的启动端口和IP"><a href="#设置项目的启动端口和IP" class="headerlink" title="设置项目的启动端口和IP"></a>设置项目的启动端口和IP</h1><pre><code class="yaml">#启动端口和IP
server:
  port: 8080
  address: 192.168.1.10    #在部署到服务器时不需要此配置
</code></pre>
<h1 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h1><pre><code class="yaml">spring:
  jpa:
    show-sql: true    #打印sql语句
    properties:
      hibernate:
        enable_lazy_load_no_trans: true #解决缺少session的问题
        format_sql: true #格式化sql语句
        ddl_auto: true #实体类可以更改数据库结构，在@Table注解中加上catalog属性，值为数据库名。
</code></pre>
<h1 id="Banner"><a href="#Banner" class="headerlink" title="Banner"></a>Banner</h1><pre><code class="yaml">spring:
  banner:
    location: banner.txt    #指定banner.txt的位置
    
</code></pre>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><pre><code class="yaml">logging:
  level:
    root: info    #定义日志的打印等级
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/06/02/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/02/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">SpringBoot学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-02 10:37:00" itemprop="dateCreated datePublished" datetime="2019-06-02T10:37:00+08:00">2019-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 20:59:58" itemprop="dateModified" datetime="2021-02-23T20:59:58+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/06/02/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/06/02/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考文章：<br><a target="_blank" rel="noopener" href="https://docshome.gitbooks.io/springboot/content/">SpringBoot中文文档</a><br><a href="">SpringBoot实战</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liaojie970/p/8043150.html">@ConfigurationProperties注解</a>    </p>
<p>现在公司新项目使用的是SpringBoot，所以趁现在有时间学习一下SpringBoot,为以后的开发做好准备。</p>
<h1 id="spring-boot-maven-plugin插件"><a href="#spring-boot-maven-plugin插件" class="headerlink" title="spring-boot-maven-plugin插件"></a>spring-boot-maven-plugin插件</h1><p>SpringBoot项目中会自带一个插件：<code>org.springframework.boot：spring-boot-maven-plugin</code>，这个插件有如下几个目标可以使用：</p>
<ul>
<li>spring-boot:build-info</li>
<li>spring-boot:help 运行该目标能够显示其他目标的说明文字</li>
<li>spring-boot:repackage</li>
<li>spring-boot:run 启动你的项目</li>
<li>spring-boot:start</li>
<li>spring-boot:stop</li>
</ul>
<p>Spring Boot Maven plugin的最主要goal就是repackage，其在Maven的package生命周期阶段，能够将mvn package生成的软件包，再次打包为可执行的软件包，并将mvn package生成的软件包重命名为*.original。使用命令<code>mvn package spring-boot:repackage</code>将生成一个可以直接执行的jar包，使用java -jar执行，同时原生的jar使用.original后缀保存。</p>
<h1 id="指定SpringBoot启动时运行的类"><a href="#指定SpringBoot启动时运行的类" class="headerlink" title="指定SpringBoot启动时运行的类"></a>指定SpringBoot启动时运行的类</h1><p>你还可以指定要执行的类，如果不指定的话，Spring会找有这个【public static void main(String[] args)】方法的类，当做可执行的类。</p>
<p>如果你想指定的话，可以用下面两个方法：</p>
<ul>
<li>如果你的POM是继承spring-boot-starter-parent的话，只需要下面的指定就行。</li>
</ul>
<pre><code class="xml">&lt;properties&gt;
    &lt;!-- The main class to start by executing java -jar --&gt;
    &lt;start-class&gt;com.mycorp.starter.HelloWorldApplication&lt;/start-class&gt;
&lt;/properties&gt;
</code></pre>
<ul>
<li>如果你的POM不是继承spring-boot-starter-parent的话，需要下面的指定。</li>
</ul>
<pre><code class="xml">    &lt;plugin&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
      &lt;configuration&gt;
        &lt;mainClass&gt;$&#123;start-class&#125;&lt;/mainClass&gt;
        &lt;layout&gt;ZIP&lt;/layout&gt;
      &lt;/configuration&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;goals&gt;
            &lt;goal&gt;repackage&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
</code></pre>
<h1 id="SpringBootApplication注解"><a href="#SpringBootApplication注解" class="headerlink" title="@SpringBootApplication注解"></a>@SpringBootApplication注解</h1><p>@SpringBootApplication开启了Spring的组件扫描和Spring Boot的自动配置功能。实际上，@SpringBootApplication将三个有用的注解组合在了一起。</p>
<ul>
<li>Spring的@Configuration：标明该类使用Spring基于Java的配置。虽然本书不会写太多 配置，但我们会更倾向于使用基于Java而不是XML的配置。</li>
<li>Spring的@ComponentScan：启用组件扫描，这样你写的Web控制器类和其他组件才能被 自动发现并注册为Spring应用程序上下文里的Bean。本章稍后会写一个简单的Spring MVC 控制器，使用@Controller进行注解，这样组件扫描才能找到它。</li>
<li>Spring Boot的@EnableAutoConfiguration：这个不起眼的小注解也可以称为 @Abracadabra<br>，就是这一行配置开启了Spring Boot自动配置的魔力，让你不用再写成篇的配置了。</li>
</ul>
<p>在Spring Boot的早期版本中，你需要在ReadingListApplication类上同时标上这三个注<br>解，但从Spring Boot 1.2.0开始，有@SpringBootApplication就行了。</p>
<h1 id="使用-ConfigurationProperties注解"><a href="#使用-ConfigurationProperties注解" class="headerlink" title="使用@ConfigurationProperties注解"></a>使用@ConfigurationProperties注解</h1><p>在application.yml中，假如有如下配置：</p>
<pre><code class="yml">#自定义配置
myconfig:
  config1: this is myconfig
</code></pre>
<p>如果想将myconfig下的配置包装成一个对象，并提供getter和setter方法进行读取和写入，应该如何实现呢？这就需要使用<code>@ConfigurationProperties</code>注解去实现。使用这个注解主要由以下步骤：</p>
<ol>
<li>为项目于添加spring-boot-configuration-processor依赖</li>
<li>创建一个Bean,并定义myconfig下的所有属性，并提供getter或者setter方法。</li>
<li>在需要使用到的地方使用getter和setter方法进行读取和写入。</li>
</ol>
<p>要使用ConfigurationProperties注解，首先需要为项目添加所需的依赖，在pom文件中添加：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后创建bean:</p>
<pre><code class="java">package com.xqk.yxb.dto;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * @author Aviator
 */
@Data
@Component
@ConfigurationProperties(prefix = &quot;myconfig&quot;)
public class MyConfig &#123;
    private String config1;
&#125;
</code></pre>
<p>bean中的@ConfigurationProperties注解定义了属性在配置文件中的前缀为myconfig，并定义了myconfig下的属性config1。并提供了getter和setter方法。</p>
<p>需要使用自定义的属性时，只需要注入我们自定义的bean，就可以使用：</p>
<pre><code class="java">package com.xqk.yxb.controller;

import com.xqk.yxb.dto.HTTPResponse;
import com.xqk.yxb.dto.MyConfig;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * @author Aviator
 */
@RestController
public class HomeController &#123;

    @Autowired
    private MyConfig myConfig;

    private Logger log=Logger.getLogger(&quot;HomeController&quot;);

    @RequestMapping(value = &quot;/index&quot;,method = RequestMethod.GET)
    public HTTPResponse home()&#123;
        log.log(Level.INFO,myConfig.getConfig1());
        myConfig.setConfig1(&quot;项目搭建成功&quot;);
        log.log(Level.INFO,myConfig.getConfig1());
        return new HTTPResponse(1,&quot;项目搭建成功&quot;);
    &#125;
&#125;
</code></pre>
<p>也可以在@bean注解的方法上使用@ConfigurationProperties注解，这样就不需要在实体类上使用@Component和@Configuration注解了,在启动类中定义bean：</p>
<pre><code class="java">package com.dxz.property4;

import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;

@SpringBootApplication
public class TestProperty4 &#123;

    @Bean
    @ConfigurationProperties(locations = &quot;classpath:mail.properties&quot;,prefix = &quot;mail&quot;)
    public MailProperties mailProperties()&#123;
        MailProperties mp = new MailProperties();
        System.out.println(&quot;zheli &quot; + mp);
        return mp;

    &#125;

    public static void main(String[] args) &#123;
        //SpringApplication.run(TestProperty1.class, args);
        new SpringApplicationBuilder(TestProperty4.class).web(true).run(args);

    &#125;
&#125;
</code></pre>
<blockquote>
<p><strong>开启配置属性</strong> 从技术上来说，@ConfigurationProperties注解不会生效，除<br>非先向Spring配置类添加@EnableConfigurationProperties注解。但通常无需这么 做，因为Spring Boot自动配置后面的全部配置类都已经加上了@EnableConfigurationProperties注解。因此，除非你完全不使用自动配置（那怎么可能？），否则就无需显式地添加@EnableConfigurationProperties。</p>
</blockquote>
<h1 id="使用-ApplicationRunner-或-CommandLineRunner"><a href="#使用-ApplicationRunner-或-CommandLineRunner" class="headerlink" title="使用 ApplicationRunner 或 CommandLineRunner"></a>使用 ApplicationRunner 或 CommandLineRunner</h1><p>如果您需要在 SpringApplication 启动时运行一些代码，可以实现 ApplicationRunner 或者 CommandLineRunner 接口。这两个接口的工作方式是一样的，都提供了一个单独的 run 方法，它将在 SpringApplication.run(​…) 完成之前调用。</p>
<p>CommandLineRunner 接口提供了访问应用程序字符串数组形式参数的方法，而 ApplicationRunner 则使用了上述的 ApplicationArguments 接口。以下示例展示 CommandLineRunner 和 run 方法的使用：</p>
<pre><code class="java">import org.springframework.boot.*;
import org.springframework.stereotype.*;

@Component
public class MyBean implements CommandLineRunner &#123;

    public void run(String... args) &#123;
        // Do something...
    &#125;

&#125;
</code></pre>
<p>如果您定义了多个 CommandLineRunner 或者 ApplicationRunner bean，则必须指定调用顺序，您可以实现 org.springframework.core.Ordered 接口，也可以使用 org.springframework.core.annotation.Order 注解解决顺序问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/05/21/Maven%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/21/Maven%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Maven知识点总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-21 11:51:00" itemprop="dateCreated datePublished" datetime="2019-05-21T11:51:00+08:00">2019-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:02" itemprop="dateModified" datetime="2021-02-23T21:00:02+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/05/21/Maven%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/05/21/Maven%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考地址：<a target="_blank" rel="noopener" href="http://ifeve.com/maven-pom/">并发编程网-maven文档翻译</a>    </p>
<p>实习结束后从上海到武汉已经休息了大半个月了，是时候学习点东西了，首先想学习一下关于Maven的知识，回想起来貌似还没有系统的学过Maven，平时最多的也就用到过Maven的依赖管理，公司项目的POM文件很多标签都不知道什么意思,所以系统学习一下Maven还是很有必要的，网上找了一本扫描版的Maven实战的电子书凑活看一下。等Maven学完之后再将公司实习的时候每周总结的知识点学习一遍，岂不美哉？so,开始吧。    </p>
<h1 id="Maven的安装与配置"><a href="#Maven的安装与配置" class="headerlink" title="Maven的安装与配置"></a>Maven的安装与配置</h1><p>用户下载Maven的安装包，然后解压到指定目录，配置M2_HOME的环境变量，并将<code>%M2_HOME%/bin</code>添加到path环境变量中。同时如果需要修改本地仓库路径，可以在 Maven 目录下的 conf/setting.xml 文件中，通过 <localRepository /> 来指定本地仓库路径，默认路径为<code>~/.m2/repository</code>。</p>
<p>在首次运行mvn命令行时，可能会抛出<code>No compiler is provided in this environment. Perhaps you are running on a JRE rather than a JDK?</code>错误，这是因为mvn打包需要jdk的环境，而它自己没有找到jdk的配置目录，所以就报错了，首先应该检查自己的jdk环境变量是否有问题，如果没问题，就需要修改一下bin目录中的mvn.bat或者mvn.sh文件的代码：<img src="https://resource-1259322763.cos.ap-guangzhou.myqcloud.com/blog/Maven%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Maven%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png" alt="图片"><br>在mvn.bat文件中，手动设置JAVA_HOME的目录，就可以解决这个问题：<br><img src="https://resource-1259322763.cos.ap-guangzhou.myqcloud.com/blog/Maven%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/maven%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF.png" alt="图片"></p>
<h1 id="问题-idea-maven-有jar包，就是报错整个项目找不到jar"><a href="#问题-idea-maven-有jar包，就是报错整个项目找不到jar" class="headerlink" title="[问题]idea maven 有jar包，就是报错整个项目找不到jar"></a>[问题]idea maven 有jar包，就是报错整个项目找不到jar</h1><p>idea中的mvn很容易出现各种各样的问题，有时候明明mvn中有jar包，但是编译的时候还是提示却少jar包，这有可能是idea的解析有问题，删除.iml文件，让他重新生成，试了几次之后就成功了。</p>
<h1 id="pom-xml中最基本的标签"><a href="#pom-xml中最基本的标签" class="headerlink" title="pom.xml中最基本的标签"></a>pom.xml中最基本的标签</h1><pre><code class="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;
  &lt;artifactId&gt;my-app&lt;/artifactId&gt;
  &lt;version&gt;1&lt;/version&gt;
  &lt;name&gt;项目名称&lt;/name&gt;
  &lt;description&gt;Parent pom providing dependency and plugin
  management for applications built with Maven&lt;/description&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
&lt;/project&gt;
</code></pre>
<ul>
<li>modelVersion 指定xml的版本，在maven3和2中只能为4.0.0</li>
<li>groupId和artifactId是maven项目的坐标</li>
<li>version 工程的版本</li>
<li>packaging 项目打包的格式，可以是jar、war、pom，当项目为聚合或者继承项目时，必须要将其申明为pom</li>
<li>name 项目的输出名称，在mvn命令时会显示该名称</li>
<li>description 项目的简要描述</li>
</ul>
<h1 id="依赖引入（dependencies）"><a href="#依赖引入（dependencies）" class="headerlink" title="依赖引入（dependencies）"></a>依赖引入（dependencies）</h1><pre><code class="xml">&lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。 --&gt; 
&lt;dependencies&gt; 
  &lt;dependency&gt; 
    &lt;!-- 依赖的group ID --&gt; 
    &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; 

    &lt;!-- 依赖的artifact ID --&gt; 
    &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt; 

    &lt;!-- 依赖的版本号。 在 Maven 2 里，也可以配置成版本号的范围。 --&gt; 
    &lt;version&gt;3.8.1&lt;/version&gt; 

    &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展
                 名或分类器。类型经常和使用的打包方式对应，尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。
                 如果设置extensions为 true，就可以在plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt; 
    &lt;type&gt;jar&lt;/type&gt; 

    &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，
                 如果你想要构建两个单独的构件成JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生
                 成两个单独的JAR构件。 --&gt; 
    &lt;classifier&gt;&lt;/classifier&gt; 

    &lt;!-- 依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 
                - compile ：默认范围，用于编译 
                - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath 
                - runtime: 在执行时需要使用 
                - test: 用于test任务时使用 
                - system: 需要外在提供相应的元素。通过systemPath来取得 
                - systemPath: 仅用于范围为system。提供相应的路径 
                - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt; 
    &lt;scope&gt;test&lt;/scope&gt; 

    &lt;!-- 仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件
                 系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt; 
    &lt;systemPath&gt;&lt;/systemPath&gt; 

    &lt;!-- 当计算传递依赖时，从依赖构件列表里，列出被排除的依赖构件集。即告诉 Maven 你只依赖指定的项目，不依赖项目的
                 依赖。此元素主要用于解决版本冲突问题 --&gt; 
    &lt;exclusions&gt; 
      &lt;exclusion&gt; 
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt; 
        &lt;groupId&gt;org.springframework&lt;/groupId&gt; 
      &lt;/exclusion&gt; 
    &lt;/exclusions&gt; 

    &lt;!-- 可选依赖，如果你在项目 B 中把 C 依赖声明为可选，你就需要在依赖于 B 的项目（例如项目 A）中显式的引用对 C 的依赖。
                 可选依赖阻断依赖的传递性。 --&gt; 
    &lt;optional&gt;true&lt;/optional&gt; 
  &lt;/dependency&gt; 
&lt;/dependencies&gt;
</code></pre>
<h1 id="仓库配置"><a href="#仓库配置" class="headerlink" title="仓库配置"></a>仓库配置</h1><pre><code class="xml">&lt;!-- 发现依赖和扩展的远程仓库列表。 --&gt; 
&lt;repositories&gt; 
  &lt;!-- 包含需要连接到远程仓库的信息 --&gt; 
  &lt;repository&gt; 
    &lt;!-- 如何处理远程仓库里发布版本的下载 --&gt; 
    &lt;releases&gt; 
      &lt;!-- true 或者 false 表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; 
      &lt;enabled&gt;&lt;enabled&gt; 

      &lt;!-- 该元素指定更新发生的频率。Maven 会比较本地 POM 和远程 POM 的时间戳。
             这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; 
      &lt;updatePolicy&gt;&lt;/updatePolicy&gt; 

        &lt;!-- 当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt; 
      &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; 
    &lt;/releases&gt; 

    &lt;!-- 如何处理远程仓库里快照版本的下载。有了 releases 和 snapshots 这两组配置，POM 就可以在每个单独的仓库中，
         为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。 --&gt; 
    &lt;snapshots&gt; 
      &lt;enabled&gt;&lt;enabled&gt;
      &lt;updatePolicy&gt;&lt;/updatePolicy&gt;
      &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; 
    &lt;/snapshots&gt; 

    &lt;!-- 远程仓库唯一标识符。可以用来匹配在 settings.xml 文件里配置的远程仓库 --&gt; 
    &lt;id&gt;banseon-repository-proxy&lt;/id&gt; 

    &lt;!-- 远程仓库名称 --&gt; 
    &lt;name&gt;banseon-repository-proxy&lt;/name&gt; 

    &lt;!-- 远程仓库 URL，按 protocol://hostname/path 形式 --&gt; 
    &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt; 

    &lt;!-- 用于定位和排序构件的仓库布局类型-可以是 default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认
         的布局；然而，Maven 1.x 有一种不同的布局。我们可以使用该元素指定布局是 default（默认）还是 legacy（遗留）。 --&gt; 
    &lt;layout&gt; default &lt;/layout&gt; 
  &lt;/repository&gt; 
&lt;/repositories&gt;
</code></pre>
<h1 id="项目的聚合（Aggregator）"><a href="#项目的聚合（Aggregator）" class="headerlink" title="项目的聚合（Aggregator）"></a>项目的聚合（Aggregator）</h1><p>在实习的时候，发现公司的项目不是单单的一个模块，而是由四个小模块组合而成，最后所有的模块由一个总的pom文件进行管理，当时看的一脸懵逼，其实这就是使用的maven的工程聚合的功能，具体的目录结构如下：</p>
<pre><code class="java">|
|\
|  module1
|     \
|      pom.xml
|\
| module2
|    \
|     pom.xml
|\
| module3
|    \
|     pom.xml
|\pom.xml
</code></pre>
<p>在项目中有一个工程仅仅用来聚合其他的工程，所以该maven工程没有常规的src等目录，只有一个pom.xml文件，当对聚合工程执行maven命令时，会对所有聚合的工程都执行该命令，起到项目总体管理的目的。</p>
<p>工程聚合和工程继承很相似，但不是从子模块指定父POM，而是从父POM指定子模块。这样做的话，父工程就知道子模块的存在了，而且如果Maven命令从父工程调用，在子模块中也能顺利执行。工程聚合要求如下做法：</p>
<ol>
<li>将父POM的packageing属性设为”pom”</li>
<li>在父POM中指定模块的目录(子POM)</li>
</ol>
<p>在聚合项目的pom.xml中，具体的示例如下：</p>
<pre><code class="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;
  &lt;artifactId&gt;my-app&lt;/artifactId&gt;
  &lt;version&gt;1&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;name&gt;项目描述&lt;/name&gt;
 
  &lt;modules&gt;
    &lt;module&gt;module1&lt;/module&gt;
    &lt;module&gt;../module2&lt;/module&gt;
    &lt;!--标签的数据为相对路径，module2与聚合项目为平行目录--&gt;
  &lt;/modules&gt;
&lt;/project&gt;
</code></pre>
<p>modules标签指定一个或多个子模块的文件夹的相对路径。这样，如果在顶级目录执行的mvn命令，那么在子模块中也会被执行相同的命令。</p>
<h1 id="项目的继承（Extend）"><a href="#项目的继承（Extend）" class="headerlink" title="项目的继承（Extend）"></a>项目的继承（Extend）</h1><p>maven项目中，如果多个子模块中都引用了相同的依赖，势必会有许许多多的重复性的代码，而且如果每个模块申明的依赖版本不一样，那么就会导致许多奇怪的问题，maven中一个解决方法是将公共的依赖申明到父类的pom中，如果需要则从父类的pom文件中引用。</p>
<p>想要使用到工程的继承，只需要在子工程的pom文件中使用parent标签申明父类的pom就可以引用到父类的pom文件,具体步骤如下所示：</p>
<ul>
<li>在所有子POM中指定它们的父POM。</li>
<li>将父POM的packaging元素的值设为”pom”。</li>
<li>在父POM中指定子模块(子POM)的目录。</li>
</ul>
<p>在子类的pom中需要如下配置：</p>
<pre><code class="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;
    &lt;artifactId&gt;my-app&lt;/artifactId&gt;
    &lt;version&gt;1&lt;/version&gt;
    &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt;
  &lt;/parent&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;artifactId&gt;my-module&lt;/artifactId&gt;
&lt;/project&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
    ...
   &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>relativePath指定了父类pom的相对路径，其默认的路径为../pom.xml，所以如果是默认路径则不需要指定relativePath标签。</p>
<p>如上面所看到的的，如果需要指定子模块的version和父模块的version相同，则只需要在子模块的pom文件中，<strong>去除本项目的groupId和version即可</strong>，这样子模块的version就继承了父模块的version。</p>
<p>上述pom文件中申明的依赖和插件都会被所有子模块所继承，这会导致不需要该依赖的模块也会继承这些依赖和插件。为了子模块更灵活的继承父类的模块和依赖，需要使用更灵活的方法。</p>
<h1 id="使用dependencyManagement和pluginManagement"><a href="#使用dependencyManagement和pluginManagement" class="headerlink" title="使用dependencyManagement和pluginManagement"></a>使用dependencyManagement和pluginManagement</h1><p>使用dependencyManagement和pluginManagement标签包含的依赖和plugin不会被主动的继承，如果子pom文件中显示的申明了和父类pom中相同坐标的依赖或者插件，该依赖和插件才会被继承到子pom中。具体用法如下所示：</p>
<pre><code class="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;
  &lt;artifactId&gt;my-app&lt;/artifactId&gt;
  &lt;version&gt;1&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;name&gt;项目描述&lt;/name&gt;
 
  &lt;modules&gt;
    &lt;module&gt;module1&lt;/module&gt;
    &lt;module&gt;../module2&lt;/module&gt;
    &lt;!--标签的数据为相对路径，module2与聚合项目为平行目录--&gt;
  &lt;/modules&gt;
  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
    &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot&lt;/artifactId&gt;
    &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-test&lt;/artifactId&gt;
    &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-test-autoconfigure&lt;/artifactId&gt;
    &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;/dependencyManagement&gt;
    &lt;build&gt;
    &lt;pluginManagement&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
          &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;
          &lt;version&gt;$&#123;kotlin.version&#125;&lt;/version&gt;
          &lt;executions&gt;
            &lt;execution&gt;
              &lt;id&gt;compile&lt;/id&gt;
              &lt;phase&gt;compile&lt;/phase&gt;
              &lt;goals&gt;
                &lt;goal&gt;compile&lt;/goal&gt;
              &lt;/goals&gt;
            &lt;/execution&gt;
            &lt;execution&gt;
              &lt;id&gt;test-compile&lt;/id&gt;
              &lt;phase&gt;test-compile&lt;/phase&gt;
              &lt;goals&gt;
                &lt;goal&gt;test-compile&lt;/goal&gt;
              &lt;/goals&gt;
            &lt;/execution&gt;
          &lt;/executions&gt;
          &lt;configuration&gt;
            &lt;jvmTarget&gt;$&#123;java.version&#125;&lt;/jvmTarget&gt;
            &lt;javaParameters&gt;true&lt;/javaParameters&gt;
          &lt;/configuration&gt;
        &lt;/plugin&gt;
        &lt;/pluginManagement&gt;
   &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<p>在子pom中只需要声明父类相同坐标的依赖，不需要声明版本，就能继承父类pom的依赖和插件，而那些在子pom文件中未申明的依赖和插件则不会被继承：</p>
<pre><code class="xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h1 id="maven反应堆构建顺序"><a href="#maven反应堆构建顺序" class="headerlink" title="maven反应堆构建顺序"></a>maven反应堆构建顺序</h1><p>反应堆指的是maven中所有模块构成的一个体系，反应堆的构建顺序如下：</p>
<pre><code class="text">聚合模块-&gt;父类模块-&gt;子模块1-&gt;子模块2-&gt;...
</code></pre>
<h1 id="maven中的变量"><a href="#maven中的变量" class="headerlink" title="maven中的变量"></a>maven中的变量</h1><p>Maven鼓励的做法是不要做重复的工作(don’t repeat yourself)。但总有在不同的地方使用相同属性的情况。为了确保属性值指定一次，Maven允许你在POM使用你自己的变量或者预先定义的变量。</p>
<p>maven中有两种变量，一种为用户自定义类型的变量，一种是工程的变量，包含了整个工程的详细信息。</p>
<h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><p>在pom文件中，使用properties标签可以自定义一个或者多个属性</p>
<pre><code class="xml">&lt;properties&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
&lt;/properties&gt;
</code></pre>
<p>在项目中，可以使用<code>$&#123;java.version&#125;</code>来引用自定义的属性。</p>
<pre><code class="xml">&lt;plugin&gt;
&lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
&lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;
&lt;version&gt;$&#123;kotlin.version&#125;&lt;/version&gt;
&lt;executions&gt;
    &lt;execution&gt;
        &lt;id&gt;compile&lt;/id&gt;
        &lt;phase&gt;compile&lt;/phase&gt;
        &lt;goals&gt;
            &lt;goal&gt;compile&lt;/goal&gt;
        &lt;/goals&gt;
    &lt;/execution&gt;
    &lt;execution&gt;
        &lt;id&gt;test-compile&lt;/id&gt;
        &lt;phase&gt;test-compile&lt;/phase&gt;
        &lt;goals&gt;
            &lt;goal&gt;test-compile&lt;/goal&gt;
        &lt;/goals&gt;
    &lt;/execution&gt;
&lt;/executions&gt;
&lt;configuration&gt;
    &lt;jvmTarget&gt;$&#123;java.version&#125;&lt;/jvmTarget&gt;&lt;!--引用自定义属性--&gt;
    &lt;javaParameters&gt;true&lt;/javaParameters&gt;
&lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<p>要注意的是这些变量在继承之后才会被处理。这意味着如果一个父工程使用了一个变量，它们在子工程中的定义与在父工程中的定义会不一样，是最后使用的那个。<strong>即，从父pom中继承的属性会被自定义的属性覆盖</strong></p>
<h2 id="工程变量"><a href="#工程变量" class="headerlink" title="工程变量"></a>工程变量</h2><p>一个Model的任何字段都是一个单独的可以做为变量引用的值元素。例如，<code>$&#123;project.groupId&#125;</code>, <code>$&#123;project.version&#125;</code>,<code>$&#123;project.build.sourceDirectory&#125;</code>等等。参考POM reference 列举的全部属性。这些变量都用”project”前缀来引用。你可以看看pom references. 作为前缀，或者完全省略前缀 – 这些形式现在已经废弃不再使用了。</p>
<h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><table>
<thead>
<tr>
<th>变量</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>project.basedir</td>
<td>当前工程所在的目录</td>
</tr>
<tr>
<td>project.baseUri</td>
<td>当前工程所在的目录，表示为一个URI，Maven 2.1.0之后</td>
</tr>
<tr>
<td>maven.build.timestamp</td>
<td>时间戳，表示开始构建的时间，Maven 2.1.0-M1之后</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/04/13/CentOS%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%89%E8%A3%85rpm%E5%8C%85%E7%9A%84MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/13/CentOS%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%89%E8%A3%85rpm%E5%8C%85%E7%9A%84MySQL/" class="post-title-link" itemprop="url">CentOS系统下安装rpm格式的MySQL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-13 09:45:00" itemprop="dateCreated datePublished" datetime="2019-04-13T09:45:00+08:00">2019-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:10" itemprop="dateModified" datetime="2021-02-23T21:00:10+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Database/" itemprop="url" rel="index"><span itemprop="name">Database</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/13/CentOS%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%89%E8%A3%85rpm%E5%8C%85%E7%9A%84MySQL/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/13/CentOS%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%89%E8%A3%85rpm%E5%8C%85%E7%9A%84MySQL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>通过<a target="_blank" rel="noopener" href="https://dev.mysql.com/downloads/mysql/">官网</a>我们可以通过各种方式安装MySQL,但是如果通过官方下载的镜像安装时，由于网络的问题，会链接不到镜像，所以可以通过下载rpm格式的安装包，然后通过rpm命令去安装MySQL。</p>
<h1 id="下载rpm的安装包"><a href="#下载rpm的安装包" class="headerlink" title="下载rpm的安装包"></a>下载rpm的安装包</h1><p>可以通过<a target="_blank" rel="noopener" href="https://dev.mysql.com/downloads/mysql/">官网</a>去下载RedHat对应版本的tar压缩包，需要注意的是如果CentOS上没有MySQL组件或者版本不对，则需要下载RPM Bundle包，里面有MySQL的所有组件。</p>
<h1 id="解压tar文件"><a href="#解压tar文件" class="headerlink" title="解压tar文件"></a>解压tar文件</h1><p>下载之后会有一个.tar格式的压缩包，使用<code>tar -xvf 压缩包名</code>去解压，需要注意是**.tar格式和.tar.gz格式解压和压缩区别是不带-z参数。<strong>解压之后会得到以下文件（第一个文件不是的，截图手抖多截了一个QAQ）：<br><img src="https://s2.ax1x.com/2019/04/12/AbFghQ.png" alt="AbFghQ.png"><br>然后依次安装</strong>common-&gt;libs-&gt;client-&gt;server**，安装顺序不能错哦。</p>
<h1 id="使用rpm命令安装MySQL组件-参考文章"><a href="#使用rpm命令安装MySQL组件-参考文章" class="headerlink" title="使用rpm命令安装MySQL组件(参考文章)"></a>使用rpm命令安装MySQL组件(<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zqwang0929/p/3352237.html">参考文章</a>)</h1><p>rpm安装命令：</p>
<pre><code class="bash">rpm -i example.rpm    #安装 example.rpm 包；
rpm -iv example.rpm   #安装 example.rpm 包并在安装过程中显示正在安装的文件信息；
rpm -ivh example.rpm  #安装 example.rpm 包并在安装过程中显示正在安装的文件信息及安装进度
</code></pre>
<p>rpm卸载命令：</p>
<pre><code class="bash"> # rpm -e example
</code></pre>
<p>如果出现：</p>
<pre><code class="bash">error: Failed dependencies:
    mysql-community-client(x86-64) &gt;= 5.7.9 is needed by mysql-community-server-5.7.25-1.el7.x86_64
    mysql-community-common(x86-64) = 5.7.25-1.el7 is needed by mysql-community-server-5.7.25-1.el7.x86_64
    mariadb-server is obsoleted by mysql-community-server-5.7.25-1.el7.x86_64
</code></pre>
<p>则表明组件的安装顺序有问题。</p>
<p>如果出现：</p>
<pre><code class="bash">Preparing...                          ################################# [100%]
    file /usr/share/mysql/czech/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/danish/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/dutch/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/english/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/estonian/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/french/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/german/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/greek/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/hungarian/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/italian/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/japanese/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
    file /usr/share/mysql/korean/errmsg.sys from install of mysql-community-common-5.7.25-1.el7.x86_64 conflicts 
    with file from package mariadb-libs-1:5.5.60-1.el7_5.x86_64
</code></pre>
<p>这是因为安装的rpm包和系统已有的组件冲突了，可以通过如下方式删除系统中的组件：<br>首先使用yum查看系统的MySQL组件：</p>
<pre><code>yum list installed | grep &quot;mysql&quot;
</code></pre>
<p>然后如果已经安装的MySQL组件和想要安装的组件有冲突，就删除它们吧：</p>
<pre><code>yum -y remove 想要删除的组件名
</code></pre>
<p>删除之后再使用rpm安装就ok了。</p>
<h1 id="启动并设置密码（参考文章）"><a href="#启动并设置密码（参考文章）" class="headerlink" title="启动并设置密码（参考文章）"></a>启动并设置密码（<a target="_blank" rel="noopener" href="https://blog.csdn.net/hello_world_qwp/article/details/79551789">参考文章</a>）</h1><p>启动MySQL并查看运行状态:</p>
<pre><code class="bash">sudo service mysqld start;#启动
sudo service mysqld status;#查看是否运行
</code></pre>
<p>因为安装时会给root设置一个默认密码，可以通过如下方式查看保存在log文件中的密码：</p>
<pre><code class="bash">sudo grep &#39;temporary password&#39; /var/log/mysqld.log
</code></pre>
<p>然后使用这个密码登陆MySQL：</p>
<pre><code class="sql">mysql -uroot -p
</code></pre>
<p>修改密码可以使用如下命令：</p>
<pre><code class="sql"> ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;NewPassword&#39;;#方式一
 SET password=password(&#39;NewPassword&#39;);
</code></pre>
<p>设置密码时，如果密码太简单，会因为MySQL密码的安全策略而报错,可以通过如下命令修改安全策略：</p>
<pre><code class="sql">SHOW VARIABLES LIKE &#39;validate_password%&#39;; #查看系统安全策略
set global validate_password_policy=LOW; #设置密码的验证强度等级为低，就只会检查密码长度
set global validate_password_length=6; #设置密码长度为6，默认长度为8
</code></pre>
<p>MySQL安全各策略字段含义如下：</p>
<ul>
<li>validate_password_length  固定密码的总长度；</li>
<li>validate_password_dictionary_file 指定密码验证的文件路径；</li>
<li>validate_password_mixed_case_count  整个密码中至少要包含大/小写字母的总个数；</li>
<li>validate_password_number_count  整个密码中至少要包含阿拉伯数字的个数；</li>
<li>validate_password_policy 指定密码的强度验证等级，默认为 MEDIUM；</li>
<li>validate_password_special_char_count 整个密码中至少要包含特殊字符的个数；</li>
</ul>
<p>关于 validate_password_policy 的取值：<br>    0/LOW：只验证长度；<br>    1/MEDIUM：验证长度、数字、大小写、特殊字符；<br>    2/STRONG：验证长度、数字、大小写、特殊字符、字典文件；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/03/27/Sping-Data-JPA%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/27/Sping-Data-JPA%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">Sping Data JPA入门学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-27 19:23:00" itemprop="dateCreated datePublished" datetime="2019-03-27T19:23:00+08:00">2019-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:10" itemprop="dateModified" datetime="2021-02-23T21:00:10+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/03/27/Sping-Data-JPA%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/27/Sping-Data-JPA%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://ityouknow.gitbooks.io/spring-data-jpa-reference-documentation/content/Working-with-Spring-Data-Repositories/spring-data-repositories.html">Spring Data JPA的官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/opensource/os-cn-spring-jpa/index.html">IMB Develop 博客</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ccwm0129/article/details/80663151">CSDN博客</a></li>
</ul>
<p>目前的公司的项目需要用到Spring Data JPA，记得刚开始看的时候感觉一脸懵逼，后来稍微看懂了以后感觉项目中如果业务逻辑比较简单的话，使用JPA比Mybatis更省事省力，它不需要使用JDBC中的那套麻烦的API，甚至也不需要写Mybatis那样的映射，定义好接口就可以直接用，感觉非常神奇，好好学习一下，今天下雨，就不加班了吧。</p>
<p>2019.3.28，我配这个花了差不多两天的时间，各种jar包不兼容，缺这里少哪里，我都感觉快得抑郁症了，真滴痛苦，好在最后好点了，非常感谢参考的文章的博主以及《Spring In Action》的作者，给了我黑暗的人生一点阳光。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/AwJlIf"><img src="https://s2.ax1x.com/2019/03/28/AwJlIf.png" alt="AwJlIf.png"></a></p>
<p>最后的图片是很久以前在豆瓣看的一只飞机耳的猫，有点阔爱。</p>
<h1 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h1><p>对数据库的一切操作的第一步是数据源（DataSource），学习Mybatis的时候应也是得先配置数据源，Spirng中有三种数据源：</p>
<ul>
<li>通过JDBC驱动程序定义的数据源</li>
<li>JNDI查找的数据源（测试环境推荐）</li>
<li>基于连接池的数据源（生产环境推荐）</li>
</ul>
<p>在配置数据源之前，需要添加MySQL驱动的jar:</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>jar包的版本很重要，有时候版本不兼容是很麻烦的。</p>
<h2 id="配置JDBC驱动程序定义的数据源"><a href="#配置JDBC驱动程序定义的数据源" class="headerlink" title="配置JDBC驱动程序定义的数据源"></a>配置JDBC驱动程序定义的数据源</h2><p>不支持池化的链接，推荐开发时使用。</p>
<h2 id="配置JNDI数据源"><a href="#配置JNDI数据源" class="headerlink" title="配置JNDI数据源"></a>配置JNDI数据源</h2><p>可以在应用之外对数据源进行控制。</p>
<h2 id="配置连接池的数据源"><a href="#配置连接池的数据源" class="headerlink" title="配置连接池的数据源"></a>配置连接池的数据源</h2><p>重点记录一下基于连接池的数据源，生产环境推荐使用，性能更好。连接池有一下三种实现方式：</p>
<ul>
<li>Apache Commons DBCP</li>
<li>c3p0</li>
<li>BoneCP</li>
</ul>
<p>记录一下第一种配置DataSource的方式，其他的方式类似，首先导入需要的jar包：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;
    &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;
    &lt;version&gt;1.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后通过xml文件配置的方式：</p>
<pre><code class="xml">&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/spring_data_jpa?
        characterEncoding=utf8&amp;amp;userSSL=false&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
        &lt;property name=&quot;initialSize&quot; value=&quot;10&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>或者可以通过注解的方式获得一个bean：</p>
<pre><code class="java">    @Bean
    public DataSource dataSource()&#123;
        BasicDataSource dataSource=new BasicDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://127.0.0.1:3306/spring_data_jpa?
        characterEncoding=utf8&amp;amp;userSSL=false&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;123456&quot;);
    &#125;
</code></pre>
<p>也可以在.properties后缀的文件中写入配置项，然后使用<code>$&#123;配置项名称&#125;</code>的方式在xml文件中引用配置项，如下是在jdbcConfiguration.properties文件中定义jdbc配置项：</p>
<pre><code class="txt">jdbcConfiguration.properties
jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/springdata?useSSL=false&amp;characterEncoding=utf-8
jdbc.username=root
jdbc.password=123456
</code></pre>
<p><strong>这里需要注意的是，在properties文件中<code>&amp;</code>不需要转译成<code>&amp;amp;</code>，否则所有中文会变成???，而在xml文件中配置时则需要转译成<code>&amp;amp;</code></strong></p>
<p>对DataSource进行测试：</p>
<pre><code class="java">import org.apache.commons.dbcp.BasicDataSource;
import org.junit.jupiter.api.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;

public class DataSourceTest &#123;
    private ApplicationContext context;
    private Connection con;

    @Test
    public void testDataSource() &#123;
        context = new ClassPathXmlApplicationContext(&quot;WEB-INF/applicationContext.xml&quot;);
        DataSource dataSource = context.getBean(DataSource.class);
        try &#123;
            con = dataSource.getConnection();
            System.out.println(con);
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            try &#123;
                if (con != null)
                    con.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

&#125;

output:
jdbc:mysql://127.0.0.1:3306/spring_data_jpa?characterEncoding=utf8&amp;userSSL=false
,UserName=root@localhost, MySQL-AB JDBC Driver
</code></pre>
<h1 id="配置实体管理器（EntityManager）"><a href="#配置实体管理器（EntityManager）" class="headerlink" title="配置实体管理器（EntityManager）"></a>配置实体管理器（EntityManager）</h1><p>实体管理器是负责管理Entity的对象。对Entity的操作包括添加、删除、修改和查询，都是通过实体管理器来实现的。使用JPA的第一个步骤就是配置一下EntityManager，而EntityManager都是通过EntityManagerFactory得到的，JPA定义了两种类型的实体管理器：</p>
<ul>
<li><p>应用程序类型管理器<br>适用于不是运行在JavaEE容器中的独立应用程序，用户需要对其进行打开、关闭、事物处理等控制，配置比较繁琐。由<code>LocalEntityManagerFactoryBean</code>生成对应的<code>EntityManager</code>。</p>
</li>
<li><p>容器类型管理器<br>由JavaEE负责创建和管理，适合JaveEE容器，配置比应用程序管理器简单很多。由<code>LocalContinerManagerFactoryBean</code>生成对应的<code>EntityManager</code>。</p>
</li>
</ul>
<p>两种配置方式没有什么大的区别，Spring都会负责管理两种EntityManager。如何配置两种EntityManager对Spring应用程序来说是透明的，你只需要把注意力放在如何处理业务逻辑上，数据访问的细节被隐藏起来了。            </p>
<p>JpaVenderAdapter类是JPA的具体实现类，有四种JPA实现厂商：</p>
<ul>
<li>EclipseLinkJpaVenderAdapter</li>
<li>HibernateJpaVneterAdapter</li>
<li>OpenJpaVneterAdapter</li>
<li>TopLinkJpaVneterAdapter</li>
</ul>
<p>在applicatinContext.xml文件中进行配置：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd 
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/data/jpa
       http://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;&gt;

    &lt;!--引入jdbc配置文件--&gt;
    &lt;context:property-placeholder location=&quot;jdbcConfiguration.properties&quot;/&gt;

   &lt;!--使用jpa命名空间开启Repository接口自动扫描--&gt;
    &lt;jpa:repositories base-package=&quot;com.spring.model&quot;/&gt;

    &lt;!--配置数据源--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; &gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--配置Jpa实现供应商--&gt;
    &lt;bean id=&quot;jpaVendorAdapter&quot; class=&quot;org.springframework.orm.jpa.vendor
    .HibernateJpaVendorAdapter&quot;&gt;
        &lt;property name=&quot;database&quot; value=&quot;MYSQL&quot; /&gt;
        &lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot; /&gt;
        &lt;property name=&quot;showSql&quot; value=&quot;false&quot; /&gt;
        &lt;property name=&quot;generateDdl&quot; value=&quot;false&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--配置实体管理器工厂--&gt;
    &lt;bean id=&quot;entityManagerFactory&quot; 
    class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;property name=&quot;jpaVendorAdapter&quot; ref=&quot;jpaVendorAdapter&quot; /&gt;
        &lt;property name=&quot;packagesToScan&quot; value=&quot;com.spring.model&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--配置事务管理器--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<h1 id="继承接口继承Repository接口"><a href="#继承接口继承Repository接口" class="headerlink" title="继承接口继承Repository接口"></a>继承接口继承Repository接口</h1><h2 id="Repository接口"><a href="#Repository接口" class="headerlink" title="Repository接口"></a>Repository接口</h2><p>Repository是一个标记接口，所有继承（或者间接继承）了这个接口的接口都会被Spring自动扫描到，然后自动创建这个接口的实现类。<br>如果用户只需要定义自己特有的方法，而不使用CrudRepository接口中自带的方法，则只需要继承Repository接口：</p>
<pre><code class="java">interface PersonRepository extends Repository&lt;Person, Long&gt; &#123;
  List&lt;Person&gt; findByLastname(String lastname);
&#125;
</code></pre>
<p>也可以使用下面的这种方式：</p>
<pre><code class="java">@RepositoryDefinition(domainClass = AccountInfo.class, idClass = Long.class) 
public interface UserDao &#123; …… &#125;
</code></pre>
<h2 id="CrudRepository接口"><a href="#CrudRepository接口" class="headerlink" title="CrudRepository接口"></a>CrudRepository接口</h2><p>以下部分内容来自Spring Data JPA的<a target="_blank" rel="noopener" href="https://ityouknow.gitbooks.io/spring-data-jpa-reference-documentation/content/Working-with-Spring-Data-Repositories/spring-data-repositories.html">官方文档</a>以及<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/opensource/os-cn-spring-jpa/index.html">IBM Develop的大神</a>的文章。</p>
<p>Spring Data库的核心接口是<code>Repository</code>。它使用domain类去管理，domain类中的id类型作为类型参数。这个接口主要作为一个标记接口(没有任何方法)，依靠具体的类型运作并帮助您发现接口，CrudRepository 提供丰富的CRUD功能去管理实体类。</p>
<pre><code class="java">import java.io.Serializable;

@NoRepositoryBean
public interface CrudRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; &#123;
    &lt;S extends T&gt; S save(S var1);

    &lt;S extends T&gt; Iterable&lt;S&gt; save(Iterable&lt;S&gt; var1);

    T findOne(ID var1);

    boolean exists(ID var1);

    Iterable&lt;T&gt; findAll();

    Iterable&lt;T&gt; findAll(Iterable&lt;ID&gt; var1);

    long count();

    void delete(ID var1);

    void delete(T var1);

    void delete(Iterable&lt;? extends T&gt; var1);

    void deleteAll();
&#125;
</code></pre>
<p>有@NoRepositoryBean注解的接口Spring不会为其创建实现类。两个接口的中间接口一般需要使用@NoRepositoryBean注解。<br>通过CrudRepository类的定义可以看到，CrudRepository类定义了11种对数据库操作的常用方法。</p>
<p><strong>如果持久层接口较多，且每一个接口都需要声明相似的增删改查方法，直接继承 Repository 就显得有些啰嗦，这时可以继承 CrudRepository，它会自动为域对象创建增删改查方法，供业务层直接使用。开发者只是多写了 “Crud” 四个字母，即刻便为域对象提供了开箱即用的十个增删改查方法。</strong></p>
<p>**但是，使用 CrudRepository 也有副作用，它可能暴露了你不希望暴露给业务层的方法。比如某些接口你只希望提供增加的操作而不希望提供删除的方法。针对这种情况，开发者只能退回到 Repository 接口，然后到 CrudRepository 中把希望保留的方法声明复制到自定义的接口中即可。 **</p>
<p>用户可以定义一个接口继承CrudRepository类来定义访问数据库的方法，当然也可以使用CrudRepository接口中自带的方法：</p>
<pre><code class="java">public interface UserRepository extends CrudRepository&lt;User, Long&gt; &#123;

  //查询并统计
  Long countByLastname(String lastname);
  
  //查询并删除
  Long deleteByLastname(String lastname);
  List&lt;User&gt; removeByLastname(String lastname);
&#125;
</code></pre>
<h2 id="PagingAndSortingRepository接口"><a href="#PagingAndSortingRepository接口" class="headerlink" title="PagingAndSortingRepository接口"></a>PagingAndSortingRepository接口</h2><p><code>CrudRepository</code>有一个<code>PagingAndSortingRepository</code> 抽象,增加了额外的方法来简化对实体的分页访问:</p>
<pre><code class="java">public interface PagingAndSortingRepository&lt;T, ID extends Serializable&gt;
  extends CrudRepository&lt;T, ID&gt; &#123;

  Iterable&lt;T&gt; findAll(Sort sort);

  Page&lt;T&gt; findAll(Pageable pageable);
&#125;
</code></pre>
<p>进入用户类别的第二页（每一页的条目是20），可以照下面这样来分页</p>
<pre><code class="java">PagingAndSortingRepository&lt;User, Long&gt; repository = // … get access to a bean
Page&lt;User&gt; users = repository.findAll(new PageRequest(1, 20));
</code></pre>
<h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p><strong>上述四个接口，开发者到底该如何选择？其实依据很简单，根据具体的业务需求，选择其中之一。笔者建议在通常情况下优先选择 Repository 接口。因为 Repository 接口已经能满足日常需求，其他接口能做到的在 Repository 中也能做到，彼此之间并不存在功能强弱的问题。只是 Repository 需要显示声明需要的方法，而其他则可能已经提供了相关的方法，不需要再显式声明，但如果对 Spring Data JPA 不熟悉，别人在检视代码或者接手相关代码时会有疑惑，他们不明白为什么明明在持久层接口中声明了三个方法，而在业务层使用该接口时，却发现有七八个方法可用，从这个角度而言，应该优先考虑使用 Repository 接口。</strong></p>
<h2 id="为接口的方法声明自定义查询"><a href="#为接口的方法声明自定义查询" class="headerlink" title="为接口的方法声明自定义查询"></a>为接口的方法声明自定义查询</h2><p>方法名定义查询的规则：</p>
<ul>
<li>And — 等价于 SQL 中的 and 关键字，比如 findByUsernameAndPassword(String user, Striang pwd)；</li>
<li>Or — 等价于 SQL 中的 or 关键字，比如 findByUsernameOrAddress(String user, String addr)；</li>
<li>Between — 等价于 SQL 中的 between 关键字，比如 findBySalaryBetween(int max, int min)；</li>
<li>LessThan — 等价于 SQL 中的 “&lt;”，比如 findBySalaryLessThan(int max)；</li>
<li>GreaterThan — 等价于 SQL 中的”&gt;”，比如 findBySalaryGreaterThan(int min)；</li>
<li>IsNull — 等价于 SQL 中的 “is null”，比如 findByUsernameIsNull()；</li>
<li>IsNotNull — 等价于 SQL 中的 “is not null”，比如 findByUsernameIsNotNull()；</li>
<li>NotNull — 与 IsNotNull 等价；</li>
<li>Like — 等价于 SQL 中的 “like”，比如 findByUsernameLike(String user)；</li>
<li>NotLike — 等价于 SQL 中的 “not like”，比如 findByUsernameNotLike(String user)；</li>
<li>OrderBy — 等价于 SQL 中的 “order by”，比如 findByUsernameOrderBySalaryAsc(String user)；</li>
<li>Not — 等价于 SQL 中的 “！ =”，比如 findByUsernameNot(String user)；</li>
<li>In — 等价于 SQL 中的 “in”，比如 findByUsernameIn(Collection<String> userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；</li>
<li>NotIn — 等价于 SQL 中的 “not in”，比如 findByUsernameNotIn(Collection<String> userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；</li>
</ul>
<p>在使用方法名定义查询时，会有一些限制，比如方法名太长、想要的查询很难用方法名去表达时，我们可以通过@Query注解自定义查询：</p>
<pre><code class="java">
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;
    @Query(&quot;SELECT a FROM User AS a WHERE a.user_id= ?1&quot;)//指定SQL语句
    User findById(Long id);
&#125;
</code></pre>
<p><strong>需要注意的是，占位符？后面必须按顺序接上数字。同时FROM后面的表明需要为实体类名，具体的原因还没弄清楚，可能是JPQL的特定语法</strong></p>
<p>很多开发者在创建 JPQL 时喜欢使用命名参数来代替位置编号，@Query 也对此提供了支持。JPQL 语句中通过”: 变量”的格式来指定参数，同时在方法的参数前面使用 @Param 将方法参数与 JPQL 中的命名参数对应，示例如下：</p>
<pre><code class="java">public interface UserDao extends Repository&lt;AccountInfo, Long&gt; &#123;

    public AccountInfo save(AccountInfo accountInfo);

    @Query(&quot;from AccountInfo a where a.accountId = :id&quot;)
    public AccountInfo findByAccountId(@Param(&quot;id&quot;)Long accountId);

    @Query(&quot;from AccountInfo a where a.balance &gt; :balance&quot;)
    public Page&lt;AccountInfo&gt; findByBalanceGreaterThan(
            @Param(&quot;balance&quot;)Integer balance,Pageable pageable);
&#125;
</code></pre>
<p>此外，开发者也可以通过使用 @Query 来执行一个更新操作，为此，我们需要在使用 @Query 的同时，用 @Modifying 来将该操作标识为修改查询，这样框架最终会生成一个更新的操作，而非查询。如下所示：</p>
<pre><code class="java">@Modifying 
@Query(&quot;update AccountInfo a set a.salary = ?1 where a.salary &lt; ?2&quot;) 
public int increaseSalary(int after, int before);//返回值必须为void、Integer/int
</code></pre>
<h2 id="定义实体类（Entity）"><a href="#定义实体类（Entity）" class="headerlink" title="定义实体类（Entity）"></a>定义实体类（Entity）</h2><p>对于接口中要使用到的实体类，需要使用以下方法定义：</p>
<pre><code class="java">import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity//声明一个实体类
@Table(name = &quot;user&quot;)//定义表名
public class User &#123;

    public User() &#123;
    &#125;

    @Id
    private Long user_id;

    private String user_name;
    private int user_age;
    private String user_addr;

    public User(Long user_id, String user_name, int user_age, String user_addr) &#123;
        this.user_id = user_id;
        this.user_name = user_name;
        this.user_age = user_age;
        this.user_addr = user_addr;
    &#125;

    public Long getUser_id() &#123;
        return user_id;
    &#125;

    setter/getter方法
&#125;
</code></pre>
<p>** 需要注意的是所有的POJO都要有默认构造器，因为反射需要有默认构造器。同时，在使用AutoIncrement时，需要在自增的属性上使用@GeneratedValue(strategy=GenerationType.IDENTITY) 或者添加注解：<code>&lt;property name=&quot;hibernate.id.new_generator_mappings&quot;&gt;false&lt;/property&gt;</code> **</p>
<p>可以在配置LocalContainerEntityManagerFactoryBean时，调用方法<code>setPackageToScan</code>来定义扫描Entity类的路径:</p>
<pre><code class="java">emf.setPackagesToScan(new String[]&#123;&quot;com.rick.entities&quot;&#125;);
</code></pre>
<h1 id="为这些接口创建代理实例"><a href="#为这些接口创建代理实例" class="headerlink" title="为这些接口创建代理实例"></a>为这些接口创建代理实例</h1><p>有了自定义的Repository接口，我们并不需要为这些接口提供实现类，我们只需要像配置<code>&lt;context:component-scan base-package=&quot;com.spring&quot; /&gt; </code>一样开启自动的Repository扫描，在<strong>启动</strong>时Spring就会扫描指定目录下的所有实现了Repository接口的接口，并自动为我们创建实现类，实现类的行为都是通过方法名实现的，专业名词叫做(领域特定语言)DSL，我也不懂是个啥，反正非常的炫酷。开启扫描有两种方式：<br>在xml中开启：</p>
<pre><code class="xml">&lt;jpa:repositories base-package=&quot;com.spring.model&quot;/&gt;
</code></pre>
<p>通过Java配置类开启：</p>
<pre><code class="java">import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@EnableJpaRepositories(&quot;com.acme.repositories&quot;)
class Config &#123;&#125;
</code></pre>
<h1 id="获得repository-实例注入并使用它。"><a href="#获得repository-实例注入并使用它。" class="headerlink" title="获得repository 实例注入并使用它。"></a>获得repository 实例注入并使用它。</h1><p>在需要对数据库进行操作的地方，直接注入一个repository，然后就可以调用我们定义的那些方法啦：</p>
<pre><code class="java">import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations= &quot;classpath:spring-config.xml&quot;)//得到xml配置文件
public class UserRepositoryIntegrationTest &#123;

    @Autowired
    UserRepository repository;//注入自定义的Repository接口

    @Test
    public void sampleTestCase() &#123;
        User result = repository.findById(10002l);
        User user=new User(10003l,&quot;caf&quot;,123,&quot;新洲蘑菇棒&quot;);
        repository.save(user);
        System.out.println(result);
        System.out.println(repository.count());
        System.out.println(repository.findById(10003l));
    &#125;
&#125;
</code></pre>
<h1 id="为接口中的部分方法提供自定义实现"><a href="#为接口中的部分方法提供自定义实现" class="headerlink" title="为接口中的部分方法提供自定义实现"></a>为接口中的部分方法提供自定义实现</h1><p>有些时候，开发者可能需要在某些方法中做一些特殊的处理，此时自动生成的代理对象不能完全满足要求。为了享受 Spring Data JPA 带给我们的便利，同时又能够为部分方法提供自定义实现，我们可以采用如下的方法：</p>
<ol>
<li>将需要开发者手动实现的方法从持久层接口（假设为 AccountDao ）中抽取出来，独立成一个新的接口（假设为 AccountDaoPlus ），并让 AccountDao 继承 AccountDaoPlus；<code>AccountDap extends CurdRepository&lt;User,long&gt;,AccountDaoPluse</code></li>
<li>为 AccountDaoPlus 提供自定义实现（默认为接口加上Impl,即为 AccountDaoPlusImpl ）； <code>AccountDaoPlusImple implements AccountDapPlus</code></li>
<li>将 AccountDaoPlusImpl 配置为 Spring Bean；</li>
<li>在业务层注入并使用AccountDaoPlus；</li>
</ol>
<h2 id="指定自定义实现类"><a href="#指定自定义实现类" class="headerlink" title="指定自定义实现类"></a>指定自定义实现类</h2><pre><code class="xml">&lt;jpa:repositories base-package=&quot;footmark.springdata.jpa.dao&quot;&gt; 
&lt;jpa:repository id=&quot;accountDao&quot; repository-impl-ref=&quot; accountDaoPlus &quot; /&gt; 
&lt;/jpa:repositories&gt; 

&lt;bean id=&quot;accountDaoPlus&quot; class=&quot;.......&quot;/&gt;
</code></pre>
<p>此外，&lt;jpa:repositories &gt; 提供了一个 repository-impl-postfix 属性，用以指定实现类的后缀。例如如下配置：</p>
<pre><code class="xml">&lt;--指定自定义实现类为自定义接口名+Impl;--&gt;
&lt;jpa:repositories base-package=&quot;footmark.springdata.jpa.dao&quot;
repository-impl-postfix=&quot;Impl&quot;/&gt;
</code></pre>
<p>基于Java类的配置时做如下配置：</p>
<pre><code class="java">@EnableRepositories(
    base-packet=&quot;com.spring.model&quot;
    repositoryImplementationPostfix=&quot;Helper&quot;//指定自定义实现类为自定义接口名+Helper;
)
</code></pre>
<h1 id="启用Spring注解事务"><a href="#启用Spring注解事务" class="headerlink" title="启用Spring注解事务"></a>启用Spring注解事务</h1><p><strong>SpringDataJPA，中在插入修改删除等需要对数据进行修改的操作时需要使用事务，而查找操作则不需要使用事务</strong>要启用Spring的注解事务，需要做如下配置，关于事务我还没有认真学习过，清明节放假好好学习一下：</p>
<p>首先需要在配置文件中开启注解事务：</p>
<pre><code class="xml">&lt;!--开启注解事务--&gt;
&lt;jx:annotation-driven/&gt;
</code></pre>
<p>同时需要引入jx的命名空间<code>xmlns:jx=&quot;http://www.springframework.org/schema/tx&quot;</code>.</p>
<p>在开启注解事物之后，就可以使用<code>@Transactional</code>注解来使用事务了。<br><code>@Transactional</code>注解只能使用在public修饰的方法中，对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能，同时需要在业务层使用，而不能在DAO接口层。</p>
<p><strong>Spring团队的建议是你在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。你当然可以在接口上使用 @Transactional 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是 不能继承 的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）。因 此，请接受Spring团队的建议并且在具体的类上使用</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zheng0518/article/details/52214310">博客原文</a></p>
<p>业务层代码：</p>
<pre><code class="java">import javax.transaction.Transactional;

/**
 * 业务层，用于定义对User的常规操作
 */
public class UserOptService &#123;

    private UserRepository repository;

    public UserOptService(UserRepository repository) &#123;
        this.repository = repository;
    &#125;

    @Transactional
    public void updateUserAddr(long id, String addr)&#123;
        repository.updateUserAddr(id,addr);
    &#125;

    public User findByUserId(long id)&#123;
        return repository.findById(id);
    &#125;

    public User addUser(User user)&#123;
        return repository.save(user);
    &#125;
&#125;
</code></pre>
<p>在DAO层（也就是Repository接口），对涉及删除、修改、增加的方法添加@Modifying注解：</p>
<pre><code class="java">import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;
    @Query(&quot;SELECT a FROM User AS a WHERE a.user_id= ?1&quot;)
    User findById(Long id);

    @Modifying//增加的注解
    @Query(&quot;UPDATE User SET user_addr = :addr WHERE user_id= :id&quot;)
    void updateUserAddr(@Param(&quot;id&quot;) Long id, @Param(&quot;addr&quot;) String addr);
&#125;
</code></pre>
<p>测试事务是否能正常运行：</p>
<pre><code class="java">import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations= &quot;classpath:spring-config.xml&quot;)
public class UserRepositoryIntegrationTest &#123;

    @Autowired
    UserOptService service;

    @Test
    public void sampleTestCase() &#123;
        User result = service.findByUserId(10002l);
        System.out.println(result);
        User user=new User(&quot;caf&quot;,134,&quot;新洲蘑菇棒&quot;);
        service.addUser(user);


        String addr=&quot;美丽繁华的魔都嗯嗯嗯！&quot;;
        service.updateUserAddr(10001l,addr);//可以成功修改
        service.updateUserAddr(100011l,addr);//使用错误的ID，不能成功修改
        System.out.println(service.findByUserId(10001l));
    &#125;
&#125;
</code></pre>
<p>在测试类中，使用正确的ID可以插入，而使用错误的ID则无法插入。(发生异常，数据回滚)</p>
<hr>
<p><img src="https://s2.ax1x.com/2019/03/27/Ade71f.png" alt="Ade71f.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/03/21/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8Multipart%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/21/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8Multipart%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">Spring中使用Multipart上传文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-21 22:10:00" itemprop="dateCreated datePublished" datetime="2019-03-21T22:10:00+08:00">2019-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:06" itemprop="dateModified" datetime="2021-02-23T21:00:06+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/03/21/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8Multipart%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/21/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8Multipart%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在web应用中，我们常常需要使用到文件上传功能，比如用户注册时需要上传用户自定义的头像，在聊天室需要发送聊天图片等等，这就需要使用到Multipart功能，要使用文件上传功能，前端的表单代码需要做一些小修改，同时后台Spring也需要添加对Multipart的解析器（Resolver）.</p>
<h1 id="前台代码的修改"><a href="#前台代码的修改" class="headerlink" title="前台代码的修改"></a>前台代码的修改</h1><p>当表单需呀使用到Multipart时，需要在form标签中加上enctype属性：</p>
<pre><code class="html">&lt;form method=&quot;POST&quot; action=&quot;http://localhost:8080/uploadImg&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;uploadImg&quot; accept=&quot;image/jpg,image/png&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot; &gt;
&lt;/form&gt;
</code></pre>
<p>需要注意的时上面的代码中的<code>enctype=&quot;multipart/form-data&quot;</code>,当使用此属性时，form表单会被拆分为多个part，包含文件的part中，存放的数据即为文件的二进制数据。<br>input标签中的<code>accept=&quot;image/jpg,image/png&quot;</code>属性指明了所需的文件类型。</p>
<h1 id="Spring中使用Multipart接收文件"><a href="#Spring中使用Multipart接收文件" class="headerlink" title="Spring中使用Multipart接收文件"></a>Spring中使用Multipart接收文件</h1><p>Spring中接收Multipart数据需要添加相应的解析器（Resolver）,Spring中主要有两种multipart解析器：</p>
<ul>
<li>StandardServletMultipartResovler 依赖于Servlet3.0对Multipart的支持，不需要依赖其他的包。</li>
<li>CommonsMultipartResolver 使用Jakarta Commons FileUpload解析multipart请求。</li>
</ul>
<p>如果需要把应用部署到Servlet3.0的容器中或者使用3.1之前的Spring版本，则需要使用CommonsMultipartResolver，否则，一般情况下我们使用StandardServletMultipartResovler。</p>
<h1 id="配置StandardServletMultipartResolver解析器"><a href="#配置StandardServletMultipartResolver解析器" class="headerlink" title="配置StandardServletMultipartResolver解析器"></a>配置StandardServletMultipartResolver解析器</h1><p>如果配置StandardServletMultipartResolver解析器，首先需要在WebConfig配置类中添加Bean。</p>
<pre><code class="java">@Bean
public MultipartResolver multipartResolver()&#123;
    return new StandardServletMultipartResolver();
&#125;
</code></pre>
<p>由于StandardServletMultipartResolver类没有属性和构造器参数，所以不能对其进行设置，我们需要重写AbstractAnnotationCongifDispatcherServlet类的customizeRegistration方法，在这个方法中去对StandardServletMultipartResolver进行设置：</p>
<pre><code class="java">@Override
protected void customizeRegistration(ServletRegistration.Dynamic registration) &#123;
    registration.setMultipartConfig(new MultipartConfigElement(&quot;E://avatar//&quot;,2097152,4194304,0));
&#125;
</code></pre>
<p>对于Multipart，我们一般需要配置一下几个参数：</p>
<ul>
<li>文件临时存放的路径<code>例如：&quot;E://avatar//&quot;</code></li>
<li>上传的文件的最大长度 <code>例如：2MB</code></li>
<li>整个请求的最大长度 <code>例如：4MB</code></li>
<li>上传过程中，如果文件大于某个数，则需要将其存入临时存放的路径中 <code>例如：0（即任何大小的文件都需要存到临时路径中）</code></li>
</ul>
<p>如果是基于web.xml的配置，则需要在DispatcherServlet的Servlet中添加<code>&lt;multipart-config&gt;</code>标签：</p>
<pre><code class="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;application&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.
    DispatcherServlet&lt;/servlet-class&gt;

    &lt;init-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;org.springframework.web.context.support.
        AnnotationConfigWebApplicationContext&lt;/param-value&gt;
    &lt;/init-param&gt;

    &lt;!--定义contextConfigLocation的初始化参数--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;com.spring.mvc.WebConfig&lt;/param-value&gt;
    &lt;/init-param&gt;

    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    
    &lt;multipart-config&gt;
        &lt;location&gt;E://avatar//&lt;/location&gt;
        &lt;max-file-size&gt;2097152&lt;/max-file-size&gt;
        &lt;max-request-size&gt;4194304&lt;/max-request-size&gt;
    &lt;/multipart-config&gt;

&lt;/servlet&gt;
</code></pre>
<h1 id="配置CommonsMultipartResolver解析器"><a href="#配置CommonsMultipartResolver解析器" class="headerlink" title="配置CommonsMultipartResolver解析器"></a>配置CommonsMultipartResolver解析器</h1><p>CommonsMultipartResolver可以作为StandardMultipartResolver的替代方案，配置CommonsMultipartResolver需要引入单独的jar包：</p>
<pre><code class="xml">&lt;dependency&gt;
      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
      &lt;artifactId&gt;com.springsource.org.apache.commons.fileupload&lt;/artifactId&gt;
      &lt;version&gt;1.2.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;commons-io&lt;/groupId&gt;
      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
      &lt;version&gt;2.5&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;  
</code></pre>
<p>然后在WebConfig.java中申明Bean:</p>
<pre><code class="java">@Bean
public MultipartResolver commonsMultipartResolver() throws IOException &#123;
    CommonsMultipartResolver resolver= new CommonsMultipartResolver();
    resolver.setUploadTempDir(new FileSystemResource(&quot;E://avatar//&quot;));
    resolver.setMaxUploadSize(2097152);
    resolver.setMaxInMemorySize(0);
    return resolver;
&#125;
</code></pre>
<p>与StandardMultipartRsolver不同的是，CommonsMultipartResolver可以在申明时直接配置参数，不过CommonsMultipartResolver类无法配置<code>整个请求的最大长度</code>这一参数。</p>
<h1 id="处理Multipart数据"><a href="#处理Multipart数据" class="headerlink" title="处理Multipart数据"></a>处理Multipart数据</h1><p>在Controller中，需要对Multipart进行写入处理：</p>
<pre><code class="java">import java.io.File;
import java.io.IOException;

import static org.springframework.web.bind.annotation.RequestMethod.POST;

@Controller
@RequestMapping(value = &quot;/uploadImg&quot;)
public class UploadImgController &#123;

    @RequestMapping(method = POST)
    public @ResponseBody LoginMsg uploadImg(@RequestParam(&quot;uploadImg&quot;)MultipartFile img
    ,User user) throws IOException &#123;
        System.out.println(&quot;UploadImgController has been visited&quot;);
        File f=new File(&quot;E://avatar//&quot;+img.getOriginalFilename());
        img.transferTo(f);
        String path=f.getAbsolutePath();
        return new LoginMsg(0,path);
    &#125;

&#125;
</code></pre>
<p>在处理表单对应的方法中，需要使用<code>@RequestParam</code>注解，并将前端的文件的标签的name属性作为参数传递进去，Spring会自动将其包装为MultipartFile对象，此对象包含了文件的所有信息：字节数组、文件名等，以及写入到磁盘的快捷方法<code>transferTo()</code>.<br>上面的方法中，还返回了代表成功失败的json对象，用于前端判断图片是否上传成功。同时，表单中的其他项则被包装到User类中。<br>同理，如果需要上传多个文件，则可以将参数设置为<code>@RequestParam(&quot;uploadImg&quot;)MultipartFile[] img</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/03/19/%E5%9F%BA%E4%BA%8EJava%E7%B1%BB%E9%85%8D%E7%BD%AE%E7%9A%84Spring%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89Servlet%E5%92%8CFilter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/19/%E5%9F%BA%E4%BA%8EJava%E7%B1%BB%E9%85%8D%E7%BD%AE%E7%9A%84Spring%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89Servlet%E5%92%8CFilter/" class="post-title-link" itemprop="url">基于Java类配置的SpringMVC中添加自定义Servlet和Filter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-19 21:59:00" itemprop="dateCreated datePublished" datetime="2019-03-19T21:59:00+08:00">2019-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:00" itemprop="dateModified" datetime="2021-02-23T21:00:00+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/03/19/%E5%9F%BA%E4%BA%8EJava%E7%B1%BB%E9%85%8D%E7%BD%AE%E7%9A%84Spring%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89Servlet%E5%92%8CFilter/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/19/%E5%9F%BA%E4%BA%8EJava%E7%B1%BB%E9%85%8D%E7%BD%AE%E7%9A%84Spring%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89Servlet%E5%92%8CFilter/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在基于Java类的Spring配置中，通过继承<code>AbstractAnnotationConfigDispatcherServletInitializer</code>类来初始化ContextLoadListener和DispatcherServlet,通过这种方式配置Spring时如何添加自定义的Servlet和Filter呢？比如解决跨域访问时，需要添加自定义的Filter去解决。</p>
<h1 id="重写AbstractAnnotationConfigDispatcherServletInitializer类的方法来添加Filter"><a href="#重写AbstractAnnotationConfigDispatcherServletInitializer类的方法来添加Filter" class="headerlink" title="重写AbstractAnnotationConfigDispatcherServletInitializer类的方法来添加Filter"></a>重写AbstractAnnotationConfigDispatcherServletInitializer类的方法来添加Filter</h1><p>如果想要添加DispatcherServlet相同映射路径的Filter,可以使用一种快捷的方法，即重写getServletFilters()方法，如下所示：</p>
<pre><code class="java">//AbstractAnnotationConfigDispatcherServletInitializer类中
@Override
public Filter[] getServletFilters()&#123;
    return new Filter[]&#123;new MyFilter()&#125;;
&#125;
</code></pre>
<p>该方法可以返回任意多的Filter,所有的Filter都会映射到DispatcherServlet路径上。</p>
<h1 id="实现WebApplicationInitializer接口添加自定义的Servlet和Filter"><a href="#实现WebApplicationInitializer接口添加自定义的Servlet和Filter" class="headerlink" title="实现WebApplicationInitializer接口添加自定义的Servlet和Filter"></a>实现WebApplicationInitializer接口添加自定义的Servlet和Filter</h1><p>这种方法更加灵活，可以将Servlet和Filter映射到自定义的路径下。</p>
<ul>
<li>添加自定义Servlet<pre><code class="java">import javax.servlet.ServletRegistration.Dynamic;
</code></pre>
</li>
</ul>
<p>public class MyServletInitializer implements WebApplicationInitializer{<br>    @Override<br>    public void onStartup(ServletContext servletContext) throws ServletException{<br>        Dynamic mySerlvet=servletContext.addServlet(“myServlet”,MyServlet.class);<br>        myServlet.addMapping(“/mypath/*”);<br>    }<br>}</p>
<pre><code>
- 添加自定义Filter
```java
import javax.servlet.FilterRegistration.Dynamic;

public class MyServletInitializer implements WebApplicationInitializer&#123;
    @Override
    public void onStartup(ServletContext servletContext) throws ServletException&#123;
        Dynamic myFilter=servletContext.addFilter(&quot;myFilter&quot;,MyFilter.class);
        myFilter.addMappingForUrlPatterns(null,false,&quot;/mypath/*&quot;);
    &#125;
&#125;
</code></pre>
<h1 id="重写AbstractAnnotationConfigDispatcherServletInitializer类的方法来自定义DispatcherServlet配置"><a href="#重写AbstractAnnotationConfigDispatcherServletInitializer类的方法来自定义DispatcherServlet配置" class="headerlink" title="重写AbstractAnnotationConfigDispatcherServletInitializer类的方法来自定义DispatcherServlet配置"></a>重写AbstractAnnotationConfigDispatcherServletInitializer类的方法来自定义DispatcherServlet配置</h1><p><code>AbstractAnnotationConfigDispatcherServletInitializer</code>类我们重写了必须重写的三个方法，getServletConfigClasses、getRootConfigClasses、getServletMappings,但是还有非常多的方法可以去重写，比如重写**customizeRegistration()**方法，在将DispatcherServlet注册到Servlet容器之中后，就会调用customizeRegistration()方法，并将DispatcherServlet注册之后得到的Dynamic对象传递进来，通过此方法可以自定义DispatcherServlet的很多事情，比如开启Multipart文件上传功能：</p>
<pre><code class="java">@Override
protected void customizeRegistration(ServletRegistration.Dynamic registration)&#123;
    registration.setMultipartCongif(
        new MultimartConfigElement(&quot;/tmp/uploads&quot;);
    );
    
    //或者设置LoadOnStartup参数
    registration.setLoadOnStartup(1);
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/03/16/IDEA%E4%B8%AD%E9%85%8D%E7%BD%AETomcat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/16/IDEA%E4%B8%AD%E9%85%8D%E7%BD%AETomcat/" class="post-title-link" itemprop="url">Windows系统下配置Tomcat</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-16 21:11:14" itemprop="dateCreated datePublished" datetime="2019-03-16T21:11:14+08:00">2019-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:06" itemprop="dateModified" datetime="2021-02-23T21:00:06+08:00">2021-02-23</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/03/16/IDEA%E4%B8%AD%E9%85%8D%E7%BD%AETomcat/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/16/IDEA%E4%B8%AD%E9%85%8D%E7%BD%AETomcat/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Tomcat下载并解压"><a href="#Tomcat下载并解压" class="headerlink" title="Tomcat下载并解压"></a>Tomcat下载并解压</h1><p>首先去官网下载一个Tomcat安装包,JDK当然也是需要滴。</p>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>下载下来的压缩包解药到文件夹中，比如说我解压到了<code>G:\apache-tomcat-7.0.86</code>文件夹，然后配置环境变量： </p>
<ul>
<li><p>计算机→属性→高级系统设置→高级→<strong>系统</strong>环境变量 </p>
</li>
<li><p>新建TOMCAT_HOME变量 </p>
<ul>
<li>变量名TOMCAT_HOME</li>
<li>变量值为解压的Tomcat安装包的路径,比如<code>G:\apache-tomcat-7.0.86</code></li>
</ul>
</li>
<li><p>新建CATALINA_HOME变量</p>
<ul>
<li>变量名CATALINA_HOME</li>
<li>变量值同样为解压的Tomcat安装包的路径</li>
</ul>
</li>
<li><p>修改变量Path</p>
<ul>
<li>在系统变量中找到Path变量名，双击或点击编辑，在末尾添加如下内容<code>;%TOMCAT_HOME%\bin;%CATALINA_HOME%\lib</code></li>
<li>这里要注意，各个变量值之间一定要用;分隔。</li>
</ul>
</li>
<li><p>在cmd命令窗口下输入startup回车（或者点击bin目录下的startup.bat文件），如果没有报错就说明成功</p>
</li>
<li><p>在浏览器中输入<code>http://localhost:8080</code>或<code>http://127.0.0.1:8080</code>，如果出现tomcat服务器页面即为配置成功。</p>
</li>
</ul>
<h2 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h2><p>如果输入startup出现<code>Neither the JAVA_HOME nor the JRE_HOME environment variable is defined</code>错误，原因是后来较新版本的JDK（例如我使用的JDK1.6）安装完不会自动登记环境变量JAVA_HOME，JRE_HOME。像我在单位的环境，我的用户是受限制的(PowerUser)，不方便设环境变量，于是我就找到了另外一个方法。<br>先看Tomcat的startup.bat，它调用了catalina.bat,而catalina.bat则调用了setclasspath.bat。只要在setclasspath.bat的开头声明环境变量，修改方法如下：<br>在文件中加入以下两行手动设置JAVA_HOME和JAR_HOME的路径：</p>
<pre><code class="bat">set JAVA_HOME=D:\Java\jdk1.6.0_11
set JRE_HOME=D:\Java\jre6
</code></pre>
<p>在linux系统中需要将set替换为export。</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/toutou/p/7910194.html">参考地址1</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37909508/article/details/79481926">参考地址2</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37909508/article/details/79481926">参考地址3</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="熊乾坤"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">熊乾坤</p>
  <div class="site-description" itemprop="description">熊乾坤的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">131</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/super-aviator" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;super-aviator" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">熊乾坤</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'o6g891hxXze8WG1xu174Bxc4-MdYXbMMI',
      appKey     : 'HSOYHT8PzTeNo7stIuLIuYvO',
      placeholder: "快来评论吧~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
