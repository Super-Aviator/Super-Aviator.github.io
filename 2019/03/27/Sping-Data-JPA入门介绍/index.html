<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"super-aviator.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":10,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="参考文章：  Spring Data JPA的官方文档 IMB Develop 博客 CSDN博客  目前的公司的项目需要用到Spring Data JPA，记得刚开始看的时候感觉一脸懵逼，后来稍微看懂了以后感觉项目中如果业务逻辑比较简单的话，使用JPA比Mybatis更省事省力，它不需要使用JDBC中的那套麻烦的API，甚至也不需要写Mybatis那样的映射，定义好接口就可以直接用，感觉非常神奇">
<meta property="og:type" content="article">
<meta property="og:title" content="Sping Data JPA入门学习">
<meta property="og:url" content="https://super-aviator.github.io/2019/03/27/Sping-Data-JPA%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/index.html">
<meta property="og:site_name" content="孤独飞行员">
<meta property="og:description" content="参考文章：  Spring Data JPA的官方文档 IMB Develop 博客 CSDN博客  目前的公司的项目需要用到Spring Data JPA，记得刚开始看的时候感觉一脸懵逼，后来稍微看懂了以后感觉项目中如果业务逻辑比较简单的话，使用JPA比Mybatis更省事省力，它不需要使用JDBC中的那套麻烦的API，甚至也不需要写Mybatis那样的映射，定义好接口就可以直接用，感觉非常神奇">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/28/AwJlIf.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/27/Ade71f.png">
<meta property="article:published_time" content="2019-03-27T11:23:00.000Z">
<meta property="article:modified_time" content="2021-02-23T13:00:10.000Z">
<meta property="article:author" content="熊乾坤">
<meta property="article:tag" content="Java Web">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="Spring Data JPA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.ax1x.com/2019/03/28/AwJlIf.png">

<link rel="canonical" href="https://super-aviator.github.io/2019/03/27/Sping-Data-JPA%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Sping Data JPA入门学习 | 孤独飞行员</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">孤独飞行员</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://super-aviator.github.io/2019/03/27/Sping-Data-JPA%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="熊乾坤">
      <meta itemprop="description" content="熊乾坤的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤独飞行员">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Sping Data JPA入门学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-27 19:23:00" itemprop="dateCreated datePublished" datetime="2019-03-27T19:23:00+08:00">2019-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:00:10" itemprop="dateModified" datetime="2021-02-23T21:00:10+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/03/27/Sping-Data-JPA%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/27/Sping-Data-JPA%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>参考文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://ityouknow.gitbooks.io/spring-data-jpa-reference-documentation/content/Working-with-Spring-Data-Repositories/spring-data-repositories.html">Spring Data JPA的官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/opensource/os-cn-spring-jpa/index.html">IMB Develop 博客</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ccwm0129/article/details/80663151">CSDN博客</a></li>
</ul>
<p>目前的公司的项目需要用到Spring Data JPA，记得刚开始看的时候感觉一脸懵逼，后来稍微看懂了以后感觉项目中如果业务逻辑比较简单的话，使用JPA比Mybatis更省事省力，它不需要使用JDBC中的那套麻烦的API，甚至也不需要写Mybatis那样的映射，定义好接口就可以直接用，感觉非常神奇，好好学习一下，今天下雨，就不加班了吧。</p>
<p>2019.3.28，我配这个花了差不多两天的时间，各种jar包不兼容，缺这里少哪里，我都感觉快得抑郁症了，真滴痛苦，好在最后好点了，非常感谢参考的文章的博主以及《Spring In Action》的作者，给了我黑暗的人生一点阳光。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/AwJlIf"><img src="https://s2.ax1x.com/2019/03/28/AwJlIf.png" alt="AwJlIf.png"></a></p>
<p>最后的图片是很久以前在豆瓣看的一只飞机耳的猫，有点阔爱。</p>
<h1 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h1><p>对数据库的一切操作的第一步是数据源（DataSource），学习Mybatis的时候应也是得先配置数据源，Spirng中有三种数据源：</p>
<ul>
<li>通过JDBC驱动程序定义的数据源</li>
<li>JNDI查找的数据源（测试环境推荐）</li>
<li>基于连接池的数据源（生产环境推荐）</li>
</ul>
<p>在配置数据源之前，需要添加MySQL驱动的jar:</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>jar包的版本很重要，有时候版本不兼容是很麻烦的。</p>
<h2 id="配置JDBC驱动程序定义的数据源"><a href="#配置JDBC驱动程序定义的数据源" class="headerlink" title="配置JDBC驱动程序定义的数据源"></a>配置JDBC驱动程序定义的数据源</h2><p>不支持池化的链接，推荐开发时使用。</p>
<h2 id="配置JNDI数据源"><a href="#配置JNDI数据源" class="headerlink" title="配置JNDI数据源"></a>配置JNDI数据源</h2><p>可以在应用之外对数据源进行控制。</p>
<h2 id="配置连接池的数据源"><a href="#配置连接池的数据源" class="headerlink" title="配置连接池的数据源"></a>配置连接池的数据源</h2><p>重点记录一下基于连接池的数据源，生产环境推荐使用，性能更好。连接池有一下三种实现方式：</p>
<ul>
<li>Apache Commons DBCP</li>
<li>c3p0</li>
<li>BoneCP</li>
</ul>
<p>记录一下第一种配置DataSource的方式，其他的方式类似，首先导入需要的jar包：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;
    &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;
    &lt;version&gt;1.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后通过xml文件配置的方式：</p>
<pre><code class="xml">&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/spring_data_jpa?
        characterEncoding=utf8&amp;amp;userSSL=false&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
        &lt;property name=&quot;initialSize&quot; value=&quot;10&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>或者可以通过注解的方式获得一个bean：</p>
<pre><code class="java">    @Bean
    public DataSource dataSource()&#123;
        BasicDataSource dataSource=new BasicDataSource();
        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        dataSource.setUrl(&quot;jdbc:mysql://127.0.0.1:3306/spring_data_jpa?
        characterEncoding=utf8&amp;amp;userSSL=false&quot;);
        dataSource.setUsername(&quot;root&quot;);
        dataSource.setPassword(&quot;123456&quot;);
    &#125;
</code></pre>
<p>也可以在.properties后缀的文件中写入配置项，然后使用<code>$&#123;配置项名称&#125;</code>的方式在xml文件中引用配置项，如下是在jdbcConfiguration.properties文件中定义jdbc配置项：</p>
<pre><code class="txt">jdbcConfiguration.properties
jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/springdata?useSSL=false&amp;characterEncoding=utf-8
jdbc.username=root
jdbc.password=123456
</code></pre>
<p><strong>这里需要注意的是，在properties文件中<code>&amp;</code>不需要转译成<code>&amp;amp;</code>，否则所有中文会变成???，而在xml文件中配置时则需要转译成<code>&amp;amp;</code></strong></p>
<p>对DataSource进行测试：</p>
<pre><code class="java">import org.apache.commons.dbcp.BasicDataSource;
import org.junit.jupiter.api.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;

public class DataSourceTest &#123;
    private ApplicationContext context;
    private Connection con;

    @Test
    public void testDataSource() &#123;
        context = new ClassPathXmlApplicationContext(&quot;WEB-INF/applicationContext.xml&quot;);
        DataSource dataSource = context.getBean(DataSource.class);
        try &#123;
            con = dataSource.getConnection();
            System.out.println(con);
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            try &#123;
                if (con != null)
                    con.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

&#125;

output:
jdbc:mysql://127.0.0.1:3306/spring_data_jpa?characterEncoding=utf8&amp;userSSL=false
,UserName=root@localhost, MySQL-AB JDBC Driver
</code></pre>
<h1 id="配置实体管理器（EntityManager）"><a href="#配置实体管理器（EntityManager）" class="headerlink" title="配置实体管理器（EntityManager）"></a>配置实体管理器（EntityManager）</h1><p>实体管理器是负责管理Entity的对象。对Entity的操作包括添加、删除、修改和查询，都是通过实体管理器来实现的。使用JPA的第一个步骤就是配置一下EntityManager，而EntityManager都是通过EntityManagerFactory得到的，JPA定义了两种类型的实体管理器：</p>
<ul>
<li><p>应用程序类型管理器<br>适用于不是运行在JavaEE容器中的独立应用程序，用户需要对其进行打开、关闭、事物处理等控制，配置比较繁琐。由<code>LocalEntityManagerFactoryBean</code>生成对应的<code>EntityManager</code>。</p>
</li>
<li><p>容器类型管理器<br>由JavaEE负责创建和管理，适合JaveEE容器，配置比应用程序管理器简单很多。由<code>LocalContinerManagerFactoryBean</code>生成对应的<code>EntityManager</code>。</p>
</li>
</ul>
<p>两种配置方式没有什么大的区别，Spring都会负责管理两种EntityManager。如何配置两种EntityManager对Spring应用程序来说是透明的，你只需要把注意力放在如何处理业务逻辑上，数据访问的细节被隐藏起来了。            </p>
<p>JpaVenderAdapter类是JPA的具体实现类，有四种JPA实现厂商：</p>
<ul>
<li>EclipseLinkJpaVenderAdapter</li>
<li>HibernateJpaVneterAdapter</li>
<li>OpenJpaVneterAdapter</li>
<li>TopLinkJpaVneterAdapter</li>
</ul>
<p>在applicatinContext.xml文件中进行配置：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd 
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/data/jpa
       http://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;&gt;

    &lt;!--引入jdbc配置文件--&gt;
    &lt;context:property-placeholder location=&quot;jdbcConfiguration.properties&quot;/&gt;

   &lt;!--使用jpa命名空间开启Repository接口自动扫描--&gt;
    &lt;jpa:repositories base-package=&quot;com.spring.model&quot;/&gt;

    &lt;!--配置数据源--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; &gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--配置Jpa实现供应商--&gt;
    &lt;bean id=&quot;jpaVendorAdapter&quot; class=&quot;org.springframework.orm.jpa.vendor
    .HibernateJpaVendorAdapter&quot;&gt;
        &lt;property name=&quot;database&quot; value=&quot;MYSQL&quot; /&gt;
        &lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot; /&gt;
        &lt;property name=&quot;showSql&quot; value=&quot;false&quot; /&gt;
        &lt;property name=&quot;generateDdl&quot; value=&quot;false&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--配置实体管理器工厂--&gt;
    &lt;bean id=&quot;entityManagerFactory&quot; 
    class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;property name=&quot;jpaVendorAdapter&quot; ref=&quot;jpaVendorAdapter&quot; /&gt;
        &lt;property name=&quot;packagesToScan&quot; value=&quot;com.spring.model&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--配置事务管理器--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<h1 id="继承接口继承Repository接口"><a href="#继承接口继承Repository接口" class="headerlink" title="继承接口继承Repository接口"></a>继承接口继承Repository接口</h1><h2 id="Repository接口"><a href="#Repository接口" class="headerlink" title="Repository接口"></a>Repository接口</h2><p>Repository是一个标记接口，所有继承（或者间接继承）了这个接口的接口都会被Spring自动扫描到，然后自动创建这个接口的实现类。<br>如果用户只需要定义自己特有的方法，而不使用CrudRepository接口中自带的方法，则只需要继承Repository接口：</p>
<pre><code class="java">interface PersonRepository extends Repository&lt;Person, Long&gt; &#123;
  List&lt;Person&gt; findByLastname(String lastname);
&#125;
</code></pre>
<p>也可以使用下面的这种方式：</p>
<pre><code class="java">@RepositoryDefinition(domainClass = AccountInfo.class, idClass = Long.class) 
public interface UserDao &#123; …… &#125;
</code></pre>
<h2 id="CrudRepository接口"><a href="#CrudRepository接口" class="headerlink" title="CrudRepository接口"></a>CrudRepository接口</h2><p>以下部分内容来自Spring Data JPA的<a target="_blank" rel="noopener" href="https://ityouknow.gitbooks.io/spring-data-jpa-reference-documentation/content/Working-with-Spring-Data-Repositories/spring-data-repositories.html">官方文档</a>以及<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/opensource/os-cn-spring-jpa/index.html">IBM Develop的大神</a>的文章。</p>
<p>Spring Data库的核心接口是<code>Repository</code>。它使用domain类去管理，domain类中的id类型作为类型参数。这个接口主要作为一个标记接口(没有任何方法)，依靠具体的类型运作并帮助您发现接口，CrudRepository 提供丰富的CRUD功能去管理实体类。</p>
<pre><code class="java">import java.io.Serializable;

@NoRepositoryBean
public interface CrudRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; &#123;
    &lt;S extends T&gt; S save(S var1);

    &lt;S extends T&gt; Iterable&lt;S&gt; save(Iterable&lt;S&gt; var1);

    T findOne(ID var1);

    boolean exists(ID var1);

    Iterable&lt;T&gt; findAll();

    Iterable&lt;T&gt; findAll(Iterable&lt;ID&gt; var1);

    long count();

    void delete(ID var1);

    void delete(T var1);

    void delete(Iterable&lt;? extends T&gt; var1);

    void deleteAll();
&#125;
</code></pre>
<p>有@NoRepositoryBean注解的接口Spring不会为其创建实现类。两个接口的中间接口一般需要使用@NoRepositoryBean注解。<br>通过CrudRepository类的定义可以看到，CrudRepository类定义了11种对数据库操作的常用方法。</p>
<p><strong>如果持久层接口较多，且每一个接口都需要声明相似的增删改查方法，直接继承 Repository 就显得有些啰嗦，这时可以继承 CrudRepository，它会自动为域对象创建增删改查方法，供业务层直接使用。开发者只是多写了 “Crud” 四个字母，即刻便为域对象提供了开箱即用的十个增删改查方法。</strong></p>
<p>**但是，使用 CrudRepository 也有副作用，它可能暴露了你不希望暴露给业务层的方法。比如某些接口你只希望提供增加的操作而不希望提供删除的方法。针对这种情况，开发者只能退回到 Repository 接口，然后到 CrudRepository 中把希望保留的方法声明复制到自定义的接口中即可。 **</p>
<p>用户可以定义一个接口继承CrudRepository类来定义访问数据库的方法，当然也可以使用CrudRepository接口中自带的方法：</p>
<pre><code class="java">public interface UserRepository extends CrudRepository&lt;User, Long&gt; &#123;

  //查询并统计
  Long countByLastname(String lastname);
  
  //查询并删除
  Long deleteByLastname(String lastname);
  List&lt;User&gt; removeByLastname(String lastname);
&#125;
</code></pre>
<h2 id="PagingAndSortingRepository接口"><a href="#PagingAndSortingRepository接口" class="headerlink" title="PagingAndSortingRepository接口"></a>PagingAndSortingRepository接口</h2><p><code>CrudRepository</code>有一个<code>PagingAndSortingRepository</code> 抽象,增加了额外的方法来简化对实体的分页访问:</p>
<pre><code class="java">public interface PagingAndSortingRepository&lt;T, ID extends Serializable&gt;
  extends CrudRepository&lt;T, ID&gt; &#123;

  Iterable&lt;T&gt; findAll(Sort sort);

  Page&lt;T&gt; findAll(Pageable pageable);
&#125;
</code></pre>
<p>进入用户类别的第二页（每一页的条目是20），可以照下面这样来分页</p>
<pre><code class="java">PagingAndSortingRepository&lt;User, Long&gt; repository = // … get access to a bean
Page&lt;User&gt; users = repository.findAll(new PageRequest(1, 20));
</code></pre>
<h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p><strong>上述四个接口，开发者到底该如何选择？其实依据很简单，根据具体的业务需求，选择其中之一。笔者建议在通常情况下优先选择 Repository 接口。因为 Repository 接口已经能满足日常需求，其他接口能做到的在 Repository 中也能做到，彼此之间并不存在功能强弱的问题。只是 Repository 需要显示声明需要的方法，而其他则可能已经提供了相关的方法，不需要再显式声明，但如果对 Spring Data JPA 不熟悉，别人在检视代码或者接手相关代码时会有疑惑，他们不明白为什么明明在持久层接口中声明了三个方法，而在业务层使用该接口时，却发现有七八个方法可用，从这个角度而言，应该优先考虑使用 Repository 接口。</strong></p>
<h2 id="为接口的方法声明自定义查询"><a href="#为接口的方法声明自定义查询" class="headerlink" title="为接口的方法声明自定义查询"></a>为接口的方法声明自定义查询</h2><p>方法名定义查询的规则：</p>
<ul>
<li>And — 等价于 SQL 中的 and 关键字，比如 findByUsernameAndPassword(String user, Striang pwd)；</li>
<li>Or — 等价于 SQL 中的 or 关键字，比如 findByUsernameOrAddress(String user, String addr)；</li>
<li>Between — 等价于 SQL 中的 between 关键字，比如 findBySalaryBetween(int max, int min)；</li>
<li>LessThan — 等价于 SQL 中的 “&lt;”，比如 findBySalaryLessThan(int max)；</li>
<li>GreaterThan — 等价于 SQL 中的”&gt;”，比如 findBySalaryGreaterThan(int min)；</li>
<li>IsNull — 等价于 SQL 中的 “is null”，比如 findByUsernameIsNull()；</li>
<li>IsNotNull — 等价于 SQL 中的 “is not null”，比如 findByUsernameIsNotNull()；</li>
<li>NotNull — 与 IsNotNull 等价；</li>
<li>Like — 等价于 SQL 中的 “like”，比如 findByUsernameLike(String user)；</li>
<li>NotLike — 等价于 SQL 中的 “not like”，比如 findByUsernameNotLike(String user)；</li>
<li>OrderBy — 等价于 SQL 中的 “order by”，比如 findByUsernameOrderBySalaryAsc(String user)；</li>
<li>Not — 等价于 SQL 中的 “！ =”，比如 findByUsernameNot(String user)；</li>
<li>In — 等价于 SQL 中的 “in”，比如 findByUsernameIn(Collection<String> userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；</li>
<li>NotIn — 等价于 SQL 中的 “not in”，比如 findByUsernameNotIn(Collection<String> userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；</li>
</ul>
<p>在使用方法名定义查询时，会有一些限制，比如方法名太长、想要的查询很难用方法名去表达时，我们可以通过@Query注解自定义查询：</p>
<pre><code class="java">
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;
    @Query(&quot;SELECT a FROM User AS a WHERE a.user_id= ?1&quot;)//指定SQL语句
    User findById(Long id);
&#125;
</code></pre>
<p><strong>需要注意的是，占位符？后面必须按顺序接上数字。同时FROM后面的表明需要为实体类名，具体的原因还没弄清楚，可能是JPQL的特定语法</strong></p>
<p>很多开发者在创建 JPQL 时喜欢使用命名参数来代替位置编号，@Query 也对此提供了支持。JPQL 语句中通过”: 变量”的格式来指定参数，同时在方法的参数前面使用 @Param 将方法参数与 JPQL 中的命名参数对应，示例如下：</p>
<pre><code class="java">public interface UserDao extends Repository&lt;AccountInfo, Long&gt; &#123;

    public AccountInfo save(AccountInfo accountInfo);

    @Query(&quot;from AccountInfo a where a.accountId = :id&quot;)
    public AccountInfo findByAccountId(@Param(&quot;id&quot;)Long accountId);

    @Query(&quot;from AccountInfo a where a.balance &gt; :balance&quot;)
    public Page&lt;AccountInfo&gt; findByBalanceGreaterThan(
            @Param(&quot;balance&quot;)Integer balance,Pageable pageable);
&#125;
</code></pre>
<p>此外，开发者也可以通过使用 @Query 来执行一个更新操作，为此，我们需要在使用 @Query 的同时，用 @Modifying 来将该操作标识为修改查询，这样框架最终会生成一个更新的操作，而非查询。如下所示：</p>
<pre><code class="java">@Modifying 
@Query(&quot;update AccountInfo a set a.salary = ?1 where a.salary &lt; ?2&quot;) 
public int increaseSalary(int after, int before);//返回值必须为void、Integer/int
</code></pre>
<h2 id="定义实体类（Entity）"><a href="#定义实体类（Entity）" class="headerlink" title="定义实体类（Entity）"></a>定义实体类（Entity）</h2><p>对于接口中要使用到的实体类，需要使用以下方法定义：</p>
<pre><code class="java">import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity//声明一个实体类
@Table(name = &quot;user&quot;)//定义表名
public class User &#123;

    public User() &#123;
    &#125;

    @Id
    private Long user_id;

    private String user_name;
    private int user_age;
    private String user_addr;

    public User(Long user_id, String user_name, int user_age, String user_addr) &#123;
        this.user_id = user_id;
        this.user_name = user_name;
        this.user_age = user_age;
        this.user_addr = user_addr;
    &#125;

    public Long getUser_id() &#123;
        return user_id;
    &#125;

    setter/getter方法
&#125;
</code></pre>
<p>** 需要注意的是所有的POJO都要有默认构造器，因为反射需要有默认构造器。同时，在使用AutoIncrement时，需要在自增的属性上使用@GeneratedValue(strategy=GenerationType.IDENTITY) 或者添加注解：<code>&lt;property name=&quot;hibernate.id.new_generator_mappings&quot;&gt;false&lt;/property&gt;</code> **</p>
<p>可以在配置LocalContainerEntityManagerFactoryBean时，调用方法<code>setPackageToScan</code>来定义扫描Entity类的路径:</p>
<pre><code class="java">emf.setPackagesToScan(new String[]&#123;&quot;com.rick.entities&quot;&#125;);
</code></pre>
<h1 id="为这些接口创建代理实例"><a href="#为这些接口创建代理实例" class="headerlink" title="为这些接口创建代理实例"></a>为这些接口创建代理实例</h1><p>有了自定义的Repository接口，我们并不需要为这些接口提供实现类，我们只需要像配置<code>&lt;context:component-scan base-package=&quot;com.spring&quot; /&gt; </code>一样开启自动的Repository扫描，在<strong>启动</strong>时Spring就会扫描指定目录下的所有实现了Repository接口的接口，并自动为我们创建实现类，实现类的行为都是通过方法名实现的，专业名词叫做(领域特定语言)DSL，我也不懂是个啥，反正非常的炫酷。开启扫描有两种方式：<br>在xml中开启：</p>
<pre><code class="xml">&lt;jpa:repositories base-package=&quot;com.spring.model&quot;/&gt;
</code></pre>
<p>通过Java配置类开启：</p>
<pre><code class="java">import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@EnableJpaRepositories(&quot;com.acme.repositories&quot;)
class Config &#123;&#125;
</code></pre>
<h1 id="获得repository-实例注入并使用它。"><a href="#获得repository-实例注入并使用它。" class="headerlink" title="获得repository 实例注入并使用它。"></a>获得repository 实例注入并使用它。</h1><p>在需要对数据库进行操作的地方，直接注入一个repository，然后就可以调用我们定义的那些方法啦：</p>
<pre><code class="java">import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations= &quot;classpath:spring-config.xml&quot;)//得到xml配置文件
public class UserRepositoryIntegrationTest &#123;

    @Autowired
    UserRepository repository;//注入自定义的Repository接口

    @Test
    public void sampleTestCase() &#123;
        User result = repository.findById(10002l);
        User user=new User(10003l,&quot;caf&quot;,123,&quot;新洲蘑菇棒&quot;);
        repository.save(user);
        System.out.println(result);
        System.out.println(repository.count());
        System.out.println(repository.findById(10003l));
    &#125;
&#125;
</code></pre>
<h1 id="为接口中的部分方法提供自定义实现"><a href="#为接口中的部分方法提供自定义实现" class="headerlink" title="为接口中的部分方法提供自定义实现"></a>为接口中的部分方法提供自定义实现</h1><p>有些时候，开发者可能需要在某些方法中做一些特殊的处理，此时自动生成的代理对象不能完全满足要求。为了享受 Spring Data JPA 带给我们的便利，同时又能够为部分方法提供自定义实现，我们可以采用如下的方法：</p>
<ol>
<li>将需要开发者手动实现的方法从持久层接口（假设为 AccountDao ）中抽取出来，独立成一个新的接口（假设为 AccountDaoPlus ），并让 AccountDao 继承 AccountDaoPlus；<code>AccountDap extends CurdRepository&lt;User,long&gt;,AccountDaoPluse</code></li>
<li>为 AccountDaoPlus 提供自定义实现（默认为接口加上Impl,即为 AccountDaoPlusImpl ）； <code>AccountDaoPlusImple implements AccountDapPlus</code></li>
<li>将 AccountDaoPlusImpl 配置为 Spring Bean；</li>
<li>在业务层注入并使用AccountDaoPlus；</li>
</ol>
<h2 id="指定自定义实现类"><a href="#指定自定义实现类" class="headerlink" title="指定自定义实现类"></a>指定自定义实现类</h2><pre><code class="xml">&lt;jpa:repositories base-package=&quot;footmark.springdata.jpa.dao&quot;&gt; 
&lt;jpa:repository id=&quot;accountDao&quot; repository-impl-ref=&quot; accountDaoPlus &quot; /&gt; 
&lt;/jpa:repositories&gt; 

&lt;bean id=&quot;accountDaoPlus&quot; class=&quot;.......&quot;/&gt;
</code></pre>
<p>此外，&lt;jpa:repositories &gt; 提供了一个 repository-impl-postfix 属性，用以指定实现类的后缀。例如如下配置：</p>
<pre><code class="xml">&lt;--指定自定义实现类为自定义接口名+Impl;--&gt;
&lt;jpa:repositories base-package=&quot;footmark.springdata.jpa.dao&quot;
repository-impl-postfix=&quot;Impl&quot;/&gt;
</code></pre>
<p>基于Java类的配置时做如下配置：</p>
<pre><code class="java">@EnableRepositories(
    base-packet=&quot;com.spring.model&quot;
    repositoryImplementationPostfix=&quot;Helper&quot;//指定自定义实现类为自定义接口名+Helper;
)
</code></pre>
<h1 id="启用Spring注解事务"><a href="#启用Spring注解事务" class="headerlink" title="启用Spring注解事务"></a>启用Spring注解事务</h1><p><strong>SpringDataJPA，中在插入修改删除等需要对数据进行修改的操作时需要使用事务，而查找操作则不需要使用事务</strong>要启用Spring的注解事务，需要做如下配置，关于事务我还没有认真学习过，清明节放假好好学习一下：</p>
<p>首先需要在配置文件中开启注解事务：</p>
<pre><code class="xml">&lt;!--开启注解事务--&gt;
&lt;jx:annotation-driven/&gt;
</code></pre>
<p>同时需要引入jx的命名空间<code>xmlns:jx=&quot;http://www.springframework.org/schema/tx&quot;</code>.</p>
<p>在开启注解事物之后，就可以使用<code>@Transactional</code>注解来使用事务了。<br><code>@Transactional</code>注解只能使用在public修饰的方法中，对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能，同时需要在业务层使用，而不能在DAO接口层。</p>
<p><strong>Spring团队的建议是你在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。你当然可以在接口上使用 @Transactional 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是 不能继承 的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）。因 此，请接受Spring团队的建议并且在具体的类上使用</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zheng0518/article/details/52214310">博客原文</a></p>
<p>业务层代码：</p>
<pre><code class="java">import javax.transaction.Transactional;

/**
 * 业务层，用于定义对User的常规操作
 */
public class UserOptService &#123;

    private UserRepository repository;

    public UserOptService(UserRepository repository) &#123;
        this.repository = repository;
    &#125;

    @Transactional
    public void updateUserAddr(long id, String addr)&#123;
        repository.updateUserAddr(id,addr);
    &#125;

    public User findByUserId(long id)&#123;
        return repository.findById(id);
    &#125;

    public User addUser(User user)&#123;
        return repository.save(user);
    &#125;
&#125;
</code></pre>
<p>在DAO层（也就是Repository接口），对涉及删除、修改、增加的方法添加@Modifying注解：</p>
<pre><code class="java">import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;
    @Query(&quot;SELECT a FROM User AS a WHERE a.user_id= ?1&quot;)
    User findById(Long id);

    @Modifying//增加的注解
    @Query(&quot;UPDATE User SET user_addr = :addr WHERE user_id= :id&quot;)
    void updateUserAddr(@Param(&quot;id&quot;) Long id, @Param(&quot;addr&quot;) String addr);
&#125;
</code></pre>
<p>测试事务是否能正常运行：</p>
<pre><code class="java">import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations= &quot;classpath:spring-config.xml&quot;)
public class UserRepositoryIntegrationTest &#123;

    @Autowired
    UserOptService service;

    @Test
    public void sampleTestCase() &#123;
        User result = service.findByUserId(10002l);
        System.out.println(result);
        User user=new User(&quot;caf&quot;,134,&quot;新洲蘑菇棒&quot;);
        service.addUser(user);


        String addr=&quot;美丽繁华的魔都嗯嗯嗯！&quot;;
        service.updateUserAddr(10001l,addr);//可以成功修改
        service.updateUserAddr(100011l,addr);//使用错误的ID，不能成功修改
        System.out.println(service.findByUserId(10001l));
    &#125;
&#125;
</code></pre>
<p>在测试类中，使用正确的ID可以插入，而使用错误的ID则无法插入。(发生异常，数据回滚)</p>
<hr>
<p><img src="https://s2.ax1x.com/2019/03/27/Ade71f.png" alt="Ade71f.png"></p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Java-Web/" rel="tag"><i class="fa fa-tag"></i> Java Web</a>
              <a href="/tags/Spring/" rel="tag"><i class="fa fa-tag"></i> Spring</a>
              <a href="/tags/Spring-Data-JPA/" rel="tag"><i class="fa fa-tag"></i> Spring Data JPA</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/03/21/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8Multipart%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/" rel="prev" title="Spring中使用Multipart上传文件">
      <i class="fa fa-chevron-left"></i> Spring中使用Multipart上传文件
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/04/13/CentOS%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%89%E8%A3%85rpm%E5%8C%85%E7%9A%84MySQL/" rel="next" title="CentOS系统下安装rpm格式的MySQL">
      CentOS系统下安装rpm格式的MySQL <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="nav-text">配置数据源</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AEJDBC%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="nav-text">配置JDBC驱动程序定义的数据源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AEJNDI%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="nav-text">配置JNDI数据源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="nav-text">配置连接池的数据源</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BD%93%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%88EntityManager%EF%BC%89"><span class="nav-text">配置实体管理器（EntityManager）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BFRepository%E6%8E%A5%E5%8F%A3"><span class="nav-text">继承接口继承Repository接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Repository%E6%8E%A5%E5%8F%A3"><span class="nav-text">Repository接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CrudRepository%E6%8E%A5%E5%8F%A3"><span class="nav-text">CrudRepository接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PagingAndSortingRepository%E6%8E%A5%E5%8F%A3"><span class="nav-text">PagingAndSortingRepository接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="nav-text">如何选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9F%A5%E8%AF%A2"><span class="nav-text">为接口的方法声明自定义查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BD%93%E7%B1%BB%EF%BC%88Entity%EF%BC%89"><span class="nav-text">定义实体类（Entity）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E8%BF%99%E4%BA%9B%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AE%9E%E4%BE%8B"><span class="nav-text">为这些接口创建代理实例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8E%B7%E5%BE%97repository-%E5%AE%9E%E4%BE%8B%E6%B3%A8%E5%85%A5%E5%B9%B6%E4%BD%BF%E7%94%A8%E5%AE%83%E3%80%82"><span class="nav-text">获得repository 实例注入并使用它。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%83%A8%E5%88%86%E6%96%B9%E6%B3%95%E6%8F%90%E4%BE%9B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0"><span class="nav-text">为接口中的部分方法提供自定义实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text">指定自定义实现类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%AF%E7%94%A8Spring%E6%B3%A8%E8%A7%A3%E4%BA%8B%E5%8A%A1"><span class="nav-text">启用Spring注解事务</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="熊乾坤"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">熊乾坤</p>
  <div class="site-description" itemprop="description">熊乾坤的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">127</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/super-aviator" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;super-aviator" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">熊乾坤</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'o6g891hxXze8WG1xu174Bxc4-MdYXbMMI',
      appKey     : 'HSOYHT8PzTeNo7stIuLIuYvO',
      placeholder: "快来评论吧~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
