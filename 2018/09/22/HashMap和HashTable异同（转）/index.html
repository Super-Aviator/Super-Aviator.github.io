<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="熊乾坤">


    <meta name="subtitle" content="飞行员">


    <meta name="description" content="熊乾坤的博客">



<title>HashMap和HashTable异同（转） | 飞行员</title>



    <link rel="icon" href="/images/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 5.4.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">孤独飞行员</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/">Home</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">孤独飞行员</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/">Home</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">HashMap和HashTable异同（转）</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">熊乾坤</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">2018-09-22&nbsp;&nbsp;11:35:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Java/">Java</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000014952453#articleHeader11">原文地址</a></p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>学完了Map的全部内容，我们再回头开开Map的框架图。<br>这里写图片描述</p>
<p>第1部分 Map概括<br>(01) Map 是“键值对”映射的抽象接口。<br>(02) AbstractMap 实现了Map中的绝大部分函数接口。它减少了“Map的实现类”的重复编码。<br>(03) SortedMap 有序的“键值对”映射接口。<br>(04) NavigableMap 是继承于SortedMap的，支持导航函数的接口。<br>(05) HashMap, Hashtable, TreeMap, WeakHashMap这4个类是“键值对”映射的实现类。它们各有区别！</p>
<ul>
<li>HashMap 是基于“拉链法”实现的散列表。一般用于单线程程序中。</li>
<li>Hashtable 也是基于“拉链法”实现的散列表。它一般用于多线程程序中。</li>
<li>WeakHashMap 也是基于“拉链法”实现的散列表，它一般也用于单线程程序中。相比HashMap，WeakHashMap中的键是“弱键”，当“弱键”被GC回收时，它对应的键值对也会被从WeakHashMap中删除；而HashMap中的键是强键。</li>
<li>TreeMap 是有序的散列表，它是通过红黑树实现的。它一般用于单线程中存储有序的映射。</li>
</ul>
<h2 id="第2部分-HashMap和Hashtable异同"><a href="#第2部分-HashMap和Hashtable异同" class="headerlink" title="第2部分 HashMap和Hashtable异同"></a>第2部分 HashMap和Hashtable异同</h2><h3 id="1部分-HashMap和Hashtable的相同点"><a href="#1部分-HashMap和Hashtable的相同点" class="headerlink" title="1部分 HashMap和Hashtable的相同点"></a>1部分 HashMap和Hashtable的相同点</h3><p>HashMap和Hashtable都是存储“键值对(key-value)”的散列表，而且都是采用拉链法实现的。        </p>
<p>存储的思想都是：通过table数组存储，数组的每一个元素都是一个Entry；而一个Entry就是一个单向链表，Entry链表中的每一个节点就保存了key-value键值对数据。</p>
<p>添加key-value键值对：首先，根据key值计算出哈希值，再计算出数组索引(即，该key-value在table中的索引)。然后，根据数组索引找到Entry(即，单向链表)，再遍历单向链表，将key和链表中的每一个节点的key进行对比。若key已经存在Entry链表中，则用该value值取代旧的value值；若key不存在Entry链表中，则新建一个key-value节点，并将该节点插入Entry链表的表头位置。        </p>
<p>删除key-value键值对：删除键值对，相比于“添加键值对”来说，简单很多。首先，还是根据key计算出哈希值，再计算出数组索引(即，该key-value在table中的索引)。然后，根据索引找出Entry(即，单向链表)。若节点key-value存在与链表Entry中，则删除链表中的节点即可。        </p>
<p>上面介绍了HashMap和Hashtable的相同点。正是由于它们都是散列表，我们关注更多的是“它们的区别，以及它们分别适合在什么情况下使用”。那接下来，我们先看看它们的区别。    </p>
<h3 id="第2-2部分-HashMap和Hashtable的不同点"><a href="#第2-2部分-HashMap和Hashtable的不同点" class="headerlink" title="第2.2部分 HashMap和Hashtable的不同点"></a>第2.2部分 HashMap和Hashtable的不同点</h3><h4 id="1-继承和实现方式不同"><a href="#1-继承和实现方式不同" class="headerlink" title="1 继承和实现方式不同"></a>1 继承和实现方式不同</h4><p>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。    </p>
<p>HashMap的定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>Hashtable的定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>从中，我们可以看出：</p>
<h5 id="1-1-HashMap和Hashtable都实现了Map、Cloneable、java-io-Serializable接口"><a href="#1-1-HashMap和Hashtable都实现了Map、Cloneable、java-io-Serializable接口" class="headerlink" title="1.1 HashMap和Hashtable都实现了Map、Cloneable、java.io.Serializable接口"></a>1.1 HashMap和Hashtable都实现了Map、Cloneable、java.io.Serializable接口</h5><p>  实现了Map接口，意味着它们都支持key-value键值对操作。支持“添加key-value键值对”、“获取key”、“获取value”、“获取map大小”、“清空map”等基本的key-value键值对操作。<br>  实现了Cloneable接口，意味着它能被克隆。<br>  实现了java.io.Serializable接口，意味着它们支持序列化，能通过序列化去传输。</p>
<h5 id="1-2-HashMap继承于AbstractMap，而Hashtable继承于Dictionary"><a href="#1-2-HashMap继承于AbstractMap，而Hashtable继承于Dictionary" class="headerlink" title="1.2 HashMap继承于AbstractMap，而Hashtable继承于Dictionary"></a>1.2 HashMap继承于AbstractMap，而Hashtable继承于Dictionary</h5><p>  Dictionary是一个抽象类，它直接继承于Object类，没有实现任何接口。Dictionary类是JDK 1.0的引入的。虽然Dictionary也支持“添加key-value键值对”、“获取value”、“获取大小”等基本操作，但它的API函数比Map少；而且Dictionary一般是通过Enumeration(枚举类)去遍历，Map则是通过Iterator(迭代器)去遍历。 然而‘由于Hashtable也实现了Map接口，所以，它即支持Enumeration遍历，也支持Iterator遍历。关于这点，后面还会进一步说明。        </p>
<p>  AbstractMap是一个抽象类，它实现了Map接口的绝大部分API函数；为Map的具体实现类提供了极大的便利。它是JDK 1.2新增的类。    </p>
<h4 id="2-线程安全不同"><a href="#2-线程安全不同" class="headerlink" title="2 线程安全不同"></a>2 线程安全不同</h4><p>Hashtable的几乎所有函数都是同步的，即它是线程安全的，支持多线程。<br>而HashMap的函数则是非同步的，它不是线程安全的。若要在多线程中使用HashMap，需要我们额外的进行同步处理。<br>对HashMap的同步处理可以使用Collections类提供的synchronizedMap静态方法，或者直接使用JDK 5.0之后提供的java.util.concurrent包里的ConcurrentHashMap类。        </p>
<h4 id="3-对null值的处理不同"><a href="#3-对null值的处理不同" class="headerlink" title="3 对null值的处理不同"></a>3 对null值的处理不同</h4><p>HashMap的key、value都可以为null。<br>Hashtable的key、value都不可以为null。    </p>
<p>我们先看看HashMap和Hashtable “添加key-value”的方法<br>HashMap的添加key-value的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span> <span class="comment">// 将“key-value”添加到HashMap中</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"> <span class="number">3</span>     <span class="comment">// 若“key为null”，则将该键值对添加到table[0]中。</span></span><br><span class="line"> <span class="number">4</span>     <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line"> <span class="number">5</span>         <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line"> <span class="number">6</span>     <span class="comment">// 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。</span></span><br><span class="line"> <span class="number">7</span>     <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line"> <span class="number">8</span>     <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"> <span class="number">9</span>     <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line"><span class="number">10</span>         Object k;</span><br><span class="line"><span class="number">11</span>         <span class="comment">// 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！</span></span><br><span class="line"><span class="number">12</span>         <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line"><span class="number">13</span>             V oldValue = e.value;</span><br><span class="line"><span class="number">14</span>             e.value = value;</span><br><span class="line"><span class="number">15</span>             e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line"><span class="number">16</span>             <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="number">17</span>         &#125;</span><br><span class="line"><span class="number">18</span>     &#125;</span><br><span class="line"><span class="number">19</span> </span><br><span class="line"><span class="number">20</span>     <span class="comment">// 若“该key”对应的键值对不存在，则将“key-value”添加到table中</span></span><br><span class="line"><span class="number">21</span>     modCount++;</span><br><span class="line"><span class="number">22</span>     addEntry(hash, key, value, i);</span><br><span class="line"><span class="number">23</span>     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">24</span> &#125;</span><br><span class="line"><span class="number">25</span> </span><br><span class="line"><span class="number">26</span> <span class="comment">// putForNullKey()的作用是将“key为null”键值对添加到table[0]位置</span></span><br><span class="line"><span class="number">27</span> <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line"><span class="number">28</span>     <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line"><span class="number">29</span>         <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">30</span>             V oldValue = e.value;</span><br><span class="line"><span class="number">31</span>             e.value = value;</span><br><span class="line"><span class="number">32</span>             <span class="comment">// recordAccess()函数什么也没有做</span></span><br><span class="line"><span class="number">33</span>             e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line"><span class="number">34</span>             <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="number">35</span>         &#125;</span><br><span class="line"><span class="number">36</span>     &#125;</span><br><span class="line"><span class="number">37</span>     <span class="comment">// 添加第1个“key为null”的元素都table中的时候，会执行到这里。</span></span><br><span class="line"><span class="number">38</span>     <span class="comment">// 它的作用是将“设置table[0]的key为null，值为value”。</span></span><br><span class="line"><span class="number">39</span>     modCount++;</span><br><span class="line"><span class="number">40</span>     addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line"><span class="number">41</span>     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">42</span> &#125;</span><br></pre></td></tr></table></figure>

<p>Hashtable的添加key-value的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">// 将“key-value”添加到Hashtable中</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"> <span class="number">3</span>     <span class="comment">// Hashtable中不能插入value为null的元素！！！</span></span><br><span class="line"> <span class="number">4</span>     <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">5</span>         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"> <span class="number">6</span>     &#125;</span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span>     <span class="comment">// 若“Hashtable中已存在键为key的键值对”，</span></span><br><span class="line"> <span class="number">9</span>     <span class="comment">// 则用“新的value”替换“旧的value”</span></span><br><span class="line"><span class="number">10</span>     Entry tab[] = table;</span><br><span class="line"><span class="number">11</span>     <span class="comment">// Hashtable中不能插入key为null的元素！！！</span></span><br><span class="line"><span class="number">12</span>     <span class="comment">// 否则，下面的语句会抛出异常！</span></span><br><span class="line"><span class="number">13</span>     <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line"><span class="number">14</span>     <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"><span class="number">15</span>     <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line"><span class="number">16</span>         <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line"><span class="number">17</span>             V old = e.value;</span><br><span class="line"><span class="number">18</span>             e.value = value;</span><br><span class="line"><span class="number">19</span>             <span class="keyword">return</span> old;</span><br><span class="line"><span class="number">20</span>         &#125;</span><br><span class="line"><span class="number">21</span>     &#125;</span><br><span class="line"><span class="number">22</span> </span><br><span class="line"><span class="number">23</span>     <span class="comment">// 若“Hashtable中不存在键为key的键值对”，</span></span><br><span class="line"><span class="number">24</span>     <span class="comment">// (01) 将“修改统计数”+1</span></span><br><span class="line"><span class="number">25</span>     modCount++;</span><br><span class="line"><span class="number">26</span>     <span class="comment">// (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子)</span></span><br><span class="line"><span class="number">27</span>     <span class="comment">//  则调整Hashtable的大小</span></span><br><span class="line"><span class="number">28</span>     <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line"><span class="number">29</span>         <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line"><span class="number">30</span>         rehash();</span><br><span class="line"><span class="number">31</span> </span><br><span class="line"><span class="number">32</span>         tab = table;</span><br><span class="line"><span class="number">33</span>         index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"><span class="number">34</span>     &#125;</span><br><span class="line"><span class="number">35</span> </span><br><span class="line"><span class="number">36</span>     <span class="comment">// (03) 将“Hashtable中index”位置的Entry(链表)保存到e中 Entry&lt;K,V&gt; e = tab[index];</span></span><br><span class="line"><span class="number">37</span>     <span class="comment">// (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”</span></span><br><span class="line">      <span class="comment">//并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。        </span></span><br><span class="line"><span class="number">38</span>     tab[index] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line"><span class="number">39</span>     <span class="comment">// (05) 将“Hashtable的实际容量”+1</span></span><br><span class="line"><span class="number">40</span>     count++;</span><br><span class="line"><span class="number">41</span>     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">42</span> &#125;</span><br></pre></td></tr></table></figure>
<p>根据上面的代码，我们可以看出：</p>
<p>Hashtable的key或value，都不能为null！否则，会抛出异常NullPointerException。        </p>
<p>HashMap的key、value都可以为null。 当HashMap的key为null时，HashMap会将其固定的插入table[0]位置(即HashMap散列表的第一个位置)；而且table[0]处只会容纳一个key为null的值，当有多个key为null的值插入的时候，table[0]会保留最后插入的value。        </p>
<h4 id="4-支持的遍历种类不同"><a href="#4-支持的遍历种类不同" class="headerlink" title="4 支持的遍历种类不同"></a>4 支持的遍历种类不同</h4><p>HashMap只支持Iterator(迭代器)遍历。<br>而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。        </p>
<p>Enumeration 是JDK 1.0添加的接口，只有hasMoreElements(), nextElement() 两个API接口，不能通过Enumeration()对元素进行修改 。<br>而Iterator 是JDK 1.2才添加的接口，支持hasNext(), next(), remove() 三个API接口。HashMap也是JDK 1.2版本才添加的，所以用Iterator取代Enumeration，HashMap只支持Iterator遍历。    </p>
<h4 id="5-通过Iterator迭代器遍历时，遍历的顺序不同"><a href="#5-通过Iterator迭代器遍历时，遍历的顺序不同" class="headerlink" title="5 通过Iterator迭代器遍历时，遍历的顺序不同"></a>5 通过Iterator迭代器遍历时，遍历的顺序不同</h4><p>HashMap是“从前向后”的遍历数组；再对数组具体某一项对应的链表，从表头开始进行遍历。        </p>
<p>Hashtabl是“从后往前”的遍历数组；再对数组具体某一项对应的链表，从表头开始进行遍历。    </p>
<p>HashMap和Hashtable都实现Map接口，所以支持获取它们“key的集合”、“value的集合”、“key-value的集合”，然后通过Iterator对这些集合进行遍历。        </p>
<p>由于“key的集合”、“value的集合”、“key-value的集合”的遍历原理都是一样的；下面，我以遍历“key-value的集合”来进行说明。    </p>
<p>HashMap 和Hashtable 遍历”key-value集合”的方式是：(01) 通过entrySet()获取“Map.Entry集合”。 (02) 通过iterator()获取“Map.Entry集合”的迭代器，再进行遍历。    </p>
<p>HashMap的实现方式：先“从前向后”的遍历数组；对数组具体某一项对应的链表，则从表头开始往后遍历。        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">// 返回“HashMap的Entry集合”</span></span><br><span class="line"> <span class="number">2</span> <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line"> <span class="number">3</span>     <span class="keyword">return</span> entrySet0();</span><br><span class="line"> <span class="number">4</span> &#125;</span><br><span class="line"> <span class="number">5</span> <span class="comment">// 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象</span></span><br><span class="line"> <span class="number">6</span> <span class="keyword">private</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123;</span><br><span class="line"> <span class="number">7</span>     Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;</span><br><span class="line"> <span class="number">8</span>     <span class="keyword">return</span> es != <span class="keyword">null</span> ? es : (entrySet = <span class="keyword">new</span> EntrySet());</span><br><span class="line"> <span class="number">9</span> &#125;</span><br><span class="line"><span class="number">10</span> <span class="comment">// EntrySet对应的集合</span></span><br><span class="line"><span class="number">11</span> <span class="comment">// EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line"><span class="number">13</span>     ...</span><br><span class="line"><span class="number">14</span>     <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line"><span class="number">15</span>         <span class="keyword">return</span> newEntryIterator();</span><br><span class="line"><span class="number">16</span>     &#125;</span><br><span class="line"><span class="number">17</span>     ...</span><br><span class="line"><span class="number">18</span> &#125;</span><br><span class="line"><span class="number">19</span> <span class="comment">// 返回一个“entry迭代器”</span></span><br><span class="line"><span class="number">20</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()   &#123;</span><br><span class="line"><span class="number">21</span>     <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line"><span class="number">22</span> &#125;</span><br><span class="line"><span class="number">23</span> <span class="comment">// Entry的迭代器</span></span><br><span class="line"><span class="number">24</span> <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line"><span class="number">25</span>     <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">26</span>         <span class="keyword">return</span> nextEntry();</span><br><span class="line"><span class="number">27</span>     &#125;</span><br><span class="line"><span class="number">28</span> &#125;</span><br><span class="line"><span class="number">29</span> <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="number">30</span>     <span class="comment">// 下一个元素</span></span><br><span class="line"><span class="number">31</span>     Entry&lt;K,V&gt; next;</span><br><span class="line"><span class="number">32</span>     <span class="comment">// expectedModCount用于实现fail-fast机制。</span></span><br><span class="line"><span class="number">33</span>     <span class="keyword">int</span> expectedModCount;</span><br><span class="line"><span class="number">34</span>     <span class="comment">// 当前索引</span></span><br><span class="line"><span class="number">35</span>     <span class="keyword">int</span> index;</span><br><span class="line"><span class="number">36</span>     <span class="comment">// 当前元素</span></span><br><span class="line"><span class="number">37</span>     Entry&lt;K,V&gt; current;</span><br><span class="line"><span class="number">38</span> </span><br><span class="line"><span class="number">39</span>     HashIterator() &#123;</span><br><span class="line"><span class="number">40</span>         expectedModCount = modCount;</span><br><span class="line"><span class="number">41</span>         <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line"><span class="number">42</span>             Entry[] t = table;</span><br><span class="line"><span class="number">43</span>             <span class="comment">// 将next指向table中第一个不为null的元素。</span></span><br><span class="line"><span class="number">44</span>             <span class="comment">// 这里利用了index的初始值为0，从0开始向后遍历，直到找到不为null的元素就退出循环。</span></span><br><span class="line"><span class="number">45</span>             <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">46</span>                 ;</span><br><span class="line"><span class="number">47</span>         &#125;</span><br><span class="line"><span class="number">48</span>     &#125;</span><br><span class="line"><span class="number">49</span> </span><br><span class="line"><span class="number">50</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">51</span>         <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line"><span class="number">52</span>     &#125;</span><br><span class="line"><span class="number">53</span> </span><br><span class="line"><span class="number">54</span>     <span class="comment">// 获取下一个元素</span></span><br><span class="line"><span class="number">55</span>     <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">56</span>         <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line"><span class="number">57</span>             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line"><span class="number">58</span>         Entry&lt;K,V&gt; e = next;</span><br><span class="line"><span class="number">59</span>         <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">60</span>             <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"><span class="number">61</span> </span><br><span class="line"><span class="number">62</span>         <span class="comment">// 注意！！！</span></span><br><span class="line"><span class="number">63</span>         <span class="comment">// 一个Entry就是一个单向链表</span></span><br><span class="line"><span class="number">64</span>         <span class="comment">// 若该Entry的下一个节点不为空，就将next指向下一个节点;</span></span><br><span class="line"><span class="number">65</span>         <span class="comment">// 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。</span></span><br><span class="line"><span class="number">66</span>         <span class="keyword">if</span> ((next = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">67</span>             Entry[] t = table;</span><br><span class="line"><span class="number">68</span>             <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">69</span>                 ;</span><br><span class="line"><span class="number">70</span>         &#125;</span><br><span class="line"><span class="number">71</span>         current = e;</span><br><span class="line"><span class="number">72</span>         <span class="keyword">return</span> e;</span><br><span class="line"><span class="number">73</span>     &#125;</span><br><span class="line"><span class="number">74</span> </span><br><span class="line"><span class="number">75</span>     ...</span><br><span class="line"><span class="number">76</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Hashtable的实现方式：先从“后向往前”的遍历数组；对数组具体某一项对应的链表，则从表头开始往后遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line"> <span class="number">2</span>     <span class="keyword">if</span> (entrySet==<span class="keyword">null</span>)</span><br><span class="line"> <span class="number">3</span>         entrySet = Collections.synchronizedSet(<span class="keyword">new</span> EntrySet(), <span class="keyword">this</span>);</span><br><span class="line"> <span class="number">4</span>     <span class="keyword">return</span> entrySet;</span><br><span class="line"> <span class="number">5</span> &#125;</span><br><span class="line"> <span class="number">6</span> </span><br><span class="line"> <span class="number">7</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line"> <span class="number">8</span>     <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">return</span> getIterator(ENTRIES);</span><br><span class="line"><span class="number">10</span>     &#125;</span><br><span class="line"><span class="number">11</span>     ...</span><br><span class="line"><span class="number">12</span> &#125;</span><br><span class="line"><span class="number">13</span> </span><br><span class="line"><span class="number">14</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Enumerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Enumeration</span>&lt;<span class="title">T</span>&gt;, <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="number">15</span>     <span class="comment">// 指向Hashtable的table</span></span><br><span class="line"><span class="number">16</span>     Entry[] table = Hashtable.<span class="keyword">this</span>.table;</span><br><span class="line"><span class="number">17</span>     <span class="comment">// Hashtable的总的大小</span></span><br><span class="line"><span class="number">18</span>     <span class="keyword">int</span> index = table.length;</span><br><span class="line"><span class="number">19</span>     Entry&lt;K,V&gt; entry = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">20</span>     Entry&lt;K,V&gt; lastReturned = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">21</span>     <span class="keyword">int</span> type;</span><br><span class="line"><span class="number">22</span> </span><br><span class="line"><span class="number">23</span>     <span class="comment">// Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志</span></span><br><span class="line"><span class="number">24</span>     <span class="comment">// iterator为true，表示它是迭代器；否则，是枚举类。</span></span><br><span class="line"><span class="number">25</span>     <span class="keyword">boolean</span> iterator;</span><br><span class="line"><span class="number">26</span> </span><br><span class="line"><span class="number">27</span>     <span class="comment">// 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。</span></span><br><span class="line"><span class="number">28</span>     <span class="keyword">protected</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"><span class="number">29</span> </span><br><span class="line"><span class="number">30</span>     Enumerator(<span class="keyword">int</span> type, <span class="keyword">boolean</span> iterator) &#123;</span><br><span class="line"><span class="number">31</span>         <span class="keyword">this</span>.type = type;</span><br><span class="line"><span class="number">32</span>         <span class="keyword">this</span>.iterator = iterator;</span><br><span class="line"><span class="number">33</span>     &#125;</span><br><span class="line"><span class="number">34</span> </span><br><span class="line"><span class="number">35</span>     <span class="comment">// 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。</span></span><br><span class="line"><span class="number">36</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">37</span>         Entry&lt;K,V&gt; e = entry;</span><br><span class="line"><span class="number">38</span>         <span class="keyword">int</span> i = index;</span><br><span class="line"><span class="number">39</span>         Entry[] t = table;</span><br><span class="line"><span class="number">40</span>         <span class="comment">/* Use locals for faster loop iteration */</span></span><br><span class="line"><span class="number">41</span>         <span class="keyword">while</span> (e == <span class="keyword">null</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">42</span>             e = t[--i];</span><br><span class="line"><span class="number">43</span>         &#125;</span><br><span class="line"><span class="number">44</span>         entry = e;</span><br><span class="line"><span class="number">45</span>         index = i;</span><br><span class="line"><span class="number">46</span>         <span class="keyword">return</span> e != <span class="keyword">null</span>;</span><br><span class="line"><span class="number">47</span>     &#125;</span><br><span class="line"><span class="number">48</span> </span><br><span class="line"><span class="number">49</span>     <span class="comment">// 获取下一个元素</span></span><br><span class="line"><span class="number">50</span>     <span class="comment">// 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式”</span></span><br><span class="line"><span class="number">51</span>     <span class="comment">// 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。</span></span><br><span class="line"><span class="number">52</span>     <span class="comment">// 然后，依次向后遍历单向链表Entry。</span></span><br><span class="line"><span class="number">53</span>     <span class="function"><span class="keyword">public</span> T <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">54</span>         Entry&lt;K,V&gt; et = entry;</span><br><span class="line"><span class="number">55</span>         <span class="keyword">int</span> i = index;</span><br><span class="line"><span class="number">56</span>         Entry[] t = table;</span><br><span class="line"><span class="number">57</span>         <span class="comment">/* Use locals for faster loop iteration */</span></span><br><span class="line"><span class="number">58</span>         <span class="keyword">while</span> (et == <span class="keyword">null</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">59</span>             et = t[--i];</span><br><span class="line"><span class="number">60</span>         &#125;</span><br><span class="line"><span class="number">61</span>         entry = et;</span><br><span class="line"><span class="number">62</span>         index = i;</span><br><span class="line"><span class="number">63</span>         <span class="keyword">if</span> (et != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">64</span>             Entry&lt;K,V&gt; e = lastReturned = entry;</span><br><span class="line"><span class="number">65</span>             entry = e.next;</span><br><span class="line"><span class="number">66</span>             <span class="keyword">return</span> type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e);</span><br><span class="line"><span class="number">67</span>         &#125;</span><br><span class="line"><span class="number">68</span>         <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;Hashtable Enumerator&quot;</span>);</span><br><span class="line"><span class="number">69</span>     &#125;</span><br><span class="line"><span class="number">70</span> </span><br><span class="line"><span class="number">71</span>     <span class="comment">// 迭代器Iterator的判断是否存在下一个元素</span></span><br><span class="line"><span class="number">72</span>     <span class="comment">// 实际上，它是调用的hasMoreElements()</span></span><br><span class="line"><span class="number">73</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">74</span>         <span class="keyword">return</span> hasMoreElements();</span><br><span class="line"><span class="number">75</span>     &#125;</span><br><span class="line"><span class="number">76</span> </span><br><span class="line"><span class="number">77</span>     <span class="comment">// 迭代器获取下一个元素</span></span><br><span class="line"><span class="number">78</span>     <span class="comment">// 实际上，它是调用的nextElement()</span></span><br><span class="line"><span class="number">79</span>     <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">80</span>         <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line"><span class="number">81</span>             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line"><span class="number">82</span>         <span class="keyword">return</span> nextElement();</span><br><span class="line"><span class="number">83</span>     &#125;</span><br><span class="line"><span class="number">84</span> </span><br><span class="line"><span class="number">85</span>     ...</span><br><span class="line"><span class="number">86</span> </span><br><span class="line"><span class="number">87</span> &#125;</span><br></pre></td></tr></table></figure>
<p>6 容量的初始值 和 增加方式都不一样<br>HashMap默认的容量大小是16；增加容量时，每次将容量变为“原始容量x2”。        </p>
<p>Hashtable默认的容量大小是11；增加容量时，每次将容量变为“原始容量x2 + 1”。</p>
<p>HashMap默认的“加载因子”是0.75, 默认的容量大小是16。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">// 默认的初始容量是16，必须是2的幂。</span></span><br><span class="line"> <span class="number">2</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> <span class="comment">// 默认加载因子</span></span><br><span class="line"> <span class="number">5</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"> <span class="number">6</span> </span><br><span class="line"> <span class="number">7</span> <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"> <span class="number">8</span> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"> <span class="number">9</span>     <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"><span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure>
<p>当HashMap的 “实际容量” &gt;= “阈值”时，(阈值 = 总的容量 * 加载因子)，就将HashMap的容量翻倍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">// 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line"> <span class="number">3</span>     <span class="comment">// 保存“bucketIndex”位置的值到“e”中</span></span><br><span class="line"> <span class="number">4</span>     Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line"> <span class="number">5</span>     <span class="comment">// 设置“bucketIndex”位置的元素为“新Entry”，</span></span><br><span class="line"> <span class="number">6</span>     <span class="comment">// 设置“e”为“新Entry的下一个节点”</span></span><br><span class="line"> <span class="number">7</span>     table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line"> <span class="number">8</span>     <span class="comment">// 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小</span></span><br><span class="line"> <span class="number">9</span>     <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line"><span class="number">10</span>         resize(<span class="number">2</span> * table.length);</span><br><span class="line"><span class="number">11</span> &#125;</span><br></pre></td></tr></table></figure>
<p>Hashtable默认的“加载因子”是0.75, 默认的容量大小是11。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>     <span class="comment">// 默认构造函数，指定的容量大小是11；加载因子是0.75</span></span><br><span class="line"><span class="number">4</span>     <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line"><span class="number">5</span> &#125;</span><br></pre></td></tr></table></figure>
<p>当Hashtable的 “实际容量” &gt;= “阈值”时，(阈值 = 总的容量 x 加载因子)，就将变为“原始容量x2 + 1”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">// 调整Hashtable的长度，将长度变成原来的(2倍+1)</span></span><br><span class="line"> <span class="number">2</span> <span class="comment">// (01) 将“旧的Entry数组”赋值给一个临时变量。</span></span><br><span class="line"> <span class="number">3</span> <span class="comment">// (02) 创建一个“新的Entry数组”，并赋值给“旧的Entry数组”</span></span><br><span class="line"> <span class="number">4</span> <span class="comment">// (03) 将“Hashtable”中的全部元素依次添加到“新的Entry数组”中</span></span><br><span class="line"> <span class="number">5</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="number">6</span>     <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line"> <span class="number">7</span>     Entry[] oldMap = table;</span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span>     <span class="keyword">int</span> newCapacity = oldCapacity * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="number">10</span>     Entry[] newMap = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span>     modCount++;</span><br><span class="line"><span class="number">13</span>     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line"><span class="number">14</span>     table = newMap;</span><br><span class="line"><span class="number">15</span> </span><br><span class="line"><span class="number">16</span>     <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line"><span class="number">17</span>         <span class="keyword">for</span> (Entry&lt;K,V&gt; old = oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line"><span class="number">18</span>             Entry&lt;K,V&gt; e = old;</span><br><span class="line"><span class="number">19</span>             old = old.next;</span><br><span class="line"><span class="number">20</span> </span><br><span class="line"><span class="number">21</span>             <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line"><span class="number">22</span>             e.next = newMap[index];</span><br><span class="line"><span class="number">23</span>             newMap[index] = e;</span><br><span class="line"><span class="number">24</span>         &#125;</span><br><span class="line"><span class="number">25</span>     &#125;</span><br><span class="line"><span class="number">26</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-添加key-value时的hash值算法不同"><a href="#7-添加key-value时的hash值算法不同" class="headerlink" title="7 添加key-value时的hash值算法不同"></a>7 添加key-value时的hash值算法不同</h4><p>HashMap添加元素时，是使用自定义的哈希算法。<br>Hashtable没有自定义哈希算法，而直接采用的key的hashCode()。    </p>
<p>HashMap添加元素时，是使用自定义的哈希算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line"> <span class="number">3</span>     <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line"> <span class="number">4</span> &#125;</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span> <span class="comment">// 将“key-value”添加到HashMap中</span></span><br><span class="line"> <span class="number">7</span> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"> <span class="number">8</span>     <span class="comment">// 若“key为null”，则将该键值对添加到table[0]中。</span></span><br><span class="line"> <span class="number">9</span>     <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">10</span>         <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line"><span class="number">11</span>     <span class="comment">// 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。</span></span><br><span class="line"><span class="number">12</span>     <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line"><span class="number">13</span>     <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"><span class="number">14</span>     <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line"><span class="number">15</span>         Object k;</span><br><span class="line"><span class="number">16</span>         <span class="comment">// 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！</span></span><br><span class="line"><span class="number">17</span>         <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line"><span class="number">18</span>             V oldValue = e.value;</span><br><span class="line"><span class="number">19</span>             e.value = value;</span><br><span class="line"><span class="number">20</span>             e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line"><span class="number">21</span>             <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="number">22</span>         &#125;</span><br><span class="line"><span class="number">23</span>     &#125;</span><br><span class="line"><span class="number">24</span> </span><br><span class="line"><span class="number">25</span>     <span class="comment">// 若“该key”对应的键值对不存在，则将“key-value”添加到table中</span></span><br><span class="line"><span class="number">26</span>     modCount++;</span><br><span class="line"><span class="number">27</span>     addEntry(hash, key, value, i);</span><br><span class="line"><span class="number">28</span>     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">29</span> &#125;</span><br></pre></td></tr></table></figure>
<p>Hashtable没有自定义哈希算法，而直接采用的key的hashCode()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">// Hashtable中不能插入value为null的元素！！！</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">4</span>         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"> <span class="number">5</span>     &#125;</span><br><span class="line"> <span class="number">6</span> </span><br><span class="line"> <span class="number">7</span>     <span class="comment">// 若“Hashtable中已存在键为key的键值对”，</span></span><br><span class="line"> <span class="number">8</span>     <span class="comment">// 则用“新的value”替换“旧的value”</span></span><br><span class="line"> <span class="number">9</span>     Entry tab[] = table;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line"><span class="number">11</span>     <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"><span class="number">12</span>     <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line"><span class="number">13</span>         <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line"><span class="number">14</span>             V old = e.value;</span><br><span class="line"><span class="number">15</span>             e.value = value;</span><br><span class="line"><span class="number">16</span>             <span class="keyword">return</span> old;</span><br><span class="line"><span class="number">17</span>             &#125;</span><br><span class="line"><span class="number">18</span>     &#125;</span><br><span class="line"><span class="number">19</span> </span><br><span class="line"><span class="number">20</span>     <span class="comment">// 若“Hashtable中不存在键为key的键值对”，</span></span><br><span class="line"><span class="number">21</span>     <span class="comment">// (01) 将“修改统计数”+1</span></span><br><span class="line"><span class="number">22</span>     modCount++;</span><br><span class="line"><span class="number">23</span>     <span class="comment">// (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子)</span></span><br><span class="line"><span class="number">24</span>     <span class="comment">//  则调整Hashtable的大小</span></span><br><span class="line"><span class="number">25</span>     <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line"><span class="number">26</span>         <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line"><span class="number">27</span>         rehash();</span><br><span class="line"><span class="number">28</span> </span><br><span class="line"><span class="number">29</span>         tab = table;</span><br><span class="line"><span class="number">30</span>         index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"><span class="number">31</span>     &#125;</span><br><span class="line"><span class="number">32</span> </span><br><span class="line"><span class="number">33</span>     <span class="comment">// (03) 将“Hashtable中index”位置的Entry(链表)保存到e中</span></span><br><span class="line"><span class="number">34</span>     Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line"><span class="number">35</span>     <span class="comment">// (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”</span></span><br><span class="line">      <span class="comment">//并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。        </span></span><br><span class="line"><span class="number">36</span>     tab[index] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line"><span class="number">37</span>     <span class="comment">// (05) 将“Hashtable的实际容量”+1</span></span><br><span class="line"><span class="number">38</span>     count++;</span><br><span class="line"><span class="number">39</span>     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">40</span> &#125;</span><br></pre></td></tr></table></figure>
<p>8 部分API不同<br>Hashtable支持contains(Object value)方法，而且重写了toString()方法；<br>而HashMap不支持contains(Object value)方法，没有重写toString()方法。        </p>
<p>最后，再说说“HashMap和Hashtable”使用的情景。<br>其实，若了解它们之间的不同之处后，可以很容易的区分根据情况进行取舍。例如：</p>
<ul>
<li>若在单线程中，我们往往会选择HashMap；而在多线程中，则会选择Hashtable。</li>
<li>若不能插入null元素，则选择Hashtable；否则，可以选择HashMap。</li>
</ul>
<p>但这个不是绝对的标准。例如，在多线程中，我们可以自己对HashMap进行同步，也可以选择ConcurrentHashMap。当HashMap和Hashtable都不能满足自己的需求时，还可以考虑新定义一个类，继承或重新实现散列表；当然，一般情况下是不需要的了。</p>
<h3 id="第3部分-HashMap和WeakHashMap异同"><a href="#第3部分-HashMap和WeakHashMap异同" class="headerlink" title="第3部分 HashMap和WeakHashMap异同"></a>第3部分 HashMap和WeakHashMap异同</h3><h4 id="3-1-HashMap和WeakHashMap的相同点"><a href="#3-1-HashMap和WeakHashMap的相同点" class="headerlink" title="3.1 HashMap和WeakHashMap的相同点"></a>3.1 HashMap和WeakHashMap的相同点</h4><p>1 它们都是散列表，存储的是“键值对”映射。<br>2 它们都继承于AbstractMap，并且实现Map基础。<br>3 它们的构造函数都一样。<br>它们都包括4个构造函数，而且函数的参数都一样。<br>4 默认的容量大小是16，默认的加载因子是0.75。<br>5 它们的“键”和“值”都允许为null。<br>6 它们都是“非同步的”。    </p>
<h4 id="3-2-HashMap和WeakHashMap的不同点"><a href="#3-2-HashMap和WeakHashMap的不同点" class="headerlink" title="3.2 HashMap和WeakHashMap的不同点"></a>3.2 HashMap和WeakHashMap的不同点</h4><p>1 HashMap实现了Cloneable和Serializable接口，而WeakHashMap没有。<br>HashMap实现Cloneable，意味着它能通过clone()克隆自己。<br>HashMap实现Serializable，意味着它支持序列化，能通过序列化去传输。</p>
<p>2 HashMap的“键”是“强引用(StrongReference)”，而WeakHashMap的键是“弱引用(WeakReference)”。<br>WeakReference的“弱键”能实现WeakReference对“键值对”的动态回收。当“弱键”不再被使用到时，GC会回收它，WeakReference也会将“弱键”对应的键值对删除。<br>这个“弱键”实现的动态回收“键值对”的原理呢？其实，通过WeakReference(弱引用)和ReferenceQueue(引用队列)实现的。 首先，我们需要了解WeakHashMap中：</p>
<p>第一，“键”是WeakReference，即key是弱键。<br>第二，ReferenceQueue是一个引用队列，它是和WeakHashMap联合使用的。当弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 WeakHashMap中的ReferenceQueue是queue。<br>第三，WeakHashMap是通过数组实现的，我们假设这个数组是table。</p>
<p>接下来，说说“动态回收”的步骤。</p>
<ol>
<li><p>新建WeakHashMap，将“键值对”添加到WeakHashMap中。<br>将“键值对”添加到WeakHashMap中时，添加的键都是弱键。实际上，WeakHashMap是通过数组table保存Entry(键值对)；每一个Entry实际上是一个单向链表，即Entry是键值对链表。</p>
</li>
<li><p>当某“弱键”不再被其它对象引用，并被GC回收时。在GC回收该“弱键”时，这个“弱键”也同时会被添加到queue队列中。<br>例如，当我们在将“弱键”key添加到WeakHashMap之后；后来将key设为null。这时，便没有外部外部对象再引用该了key。<br>接着，当Java虚拟机的GC回收内存时，会回收key的相关内存；同时，将key添加到queue队列中。</p>
</li>
<li><p>当下一次我们需要操作WeakHashMap时，会先同步table和queue。table中保存了全部的键值对，而queue中保存被GC回收的“弱键”；同步它们，就是删除table中被GC回收的“弱键”对应的键值对。        </p>
</li>
</ol>
<p>例如，当我们“读取WeakHashMap中的元素或获取WeakReference的大小时”，它会先同步table和queue，目的是“删除table中被GC回收的‘弱键’对应的键值对”。删除的方法就是逐个比较“table中元素的‘键’和queue中的‘键’”，若它们相当，则删除“table中的该键值对”。</p>
<h4 id="3-3-HashMap和WeakHashMap的比较测试程序"><a href="#3-3-HashMap和WeakHashMap的比较测试程序" class="headerlink" title="3.3 HashMap和WeakHashMap的比较测试程序"></a>3.3 HashMap和WeakHashMap的比较测试程序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">import</span> java.util.HashMap;</span><br><span class="line">  <span class="number">2</span> <span class="keyword">import</span> java.util.Iterator;</span><br><span class="line">  <span class="number">3</span> <span class="keyword">import</span> java.util.Map;</span><br><span class="line">  <span class="number">4</span> <span class="keyword">import</span> java.util.WeakHashMap;</span><br><span class="line">  <span class="number">5</span> <span class="keyword">import</span> java.util.Date;</span><br><span class="line">  <span class="number">6</span> <span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line">  <span class="number">7</span> </span><br><span class="line">  <span class="number">8</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  9  * <span class="doctag">@desc</span> HashMap 和 WeakHashMap比较程序</span></span><br><span class="line"><span class="comment"> 10  *</span></span><br><span class="line"><span class="comment"> 11  * <span class="doctag">@author</span> skywang</span></span><br><span class="line"><span class="comment"> 12  * <span class="doctag">@email</span> kuiwu-wang@163.com</span></span><br><span class="line"><span class="comment"> 13  */</span></span><br><span class="line"> <span class="number">14</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareHashmapAndWeakhashmap</span> </span>&#123;</span><br><span class="line"> <span class="number">15</span> </span><br><span class="line"> <span class="number">16</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> <span class="number">17</span> </span><br><span class="line"> <span class="number">18</span>         <span class="comment">// 当“弱键”是String时，比较HashMap和WeakHashMap</span></span><br><span class="line"> <span class="number">19</span>         compareWithString();</span><br><span class="line"> <span class="number">20</span>         <span class="comment">// 当“弱键”是自定义类型时，比较HashMap和WeakHashMap</span></span><br><span class="line"> <span class="number">21</span>         compareWithSelfClass();</span><br><span class="line"> <span class="number">22</span>     &#125;</span><br><span class="line"> <span class="number">23</span> </span><br><span class="line"> <span class="number">24</span>     <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 25      * 遍历map，并打印map的大小</span></span><br><span class="line"><span class="comment"> 26      */</span></span><br><span class="line"> <span class="number">27</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iteratorAndCountMap</span><span class="params">(Map map)</span> </span>&#123;</span><br><span class="line"> <span class="number">28</span>         <span class="comment">// 遍历map</span></span><br><span class="line"> <span class="number">29</span>         <span class="keyword">for</span> (Iterator iter = map.entrySet().iterator();</span><br><span class="line"> <span class="number">30</span>                 iter.hasNext();  ) &#123;</span><br><span class="line"> <span class="number">31</span>             Map.Entry en = (Map.Entry)iter.next();</span><br><span class="line"> <span class="number">32</span>             System.out.printf(<span class="string">&quot;map entry : %s - %s\n &quot;</span>,en.getKey(), en.getValue());</span><br><span class="line"> <span class="number">33</span>         &#125;</span><br><span class="line"> <span class="number">34</span> </span><br><span class="line"> <span class="number">35</span>         <span class="comment">// 打印HashMap的实际大小</span></span><br><span class="line"> <span class="number">36</span>         System.out.printf(<span class="string">&quot; map size:%s\n\n&quot;</span>, map.size());</span><br><span class="line"> <span class="number">37</span>     &#125;</span><br><span class="line"> <span class="number">38</span> </span><br><span class="line"> <span class="number">39</span>     <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 40      * 通过String对象测试HashMap和WeakHashMap</span></span><br><span class="line"><span class="comment"> 41      */</span></span><br><span class="line"> <span class="number">42</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compareWithString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="number">43</span>         <span class="comment">// 新建4个String字符串</span></span><br><span class="line"> <span class="number">44</span>         String w1 = <span class="keyword">new</span> String(<span class="string">&quot;W1&quot;</span>);</span><br><span class="line"> <span class="number">45</span>         String w2 = <span class="keyword">new</span> String(<span class="string">&quot;W2&quot;</span>);</span><br><span class="line"> <span class="number">46</span>         String h1 = <span class="keyword">new</span> String(<span class="string">&quot;H1&quot;</span>);</span><br><span class="line"> <span class="number">47</span>         String h2 = <span class="keyword">new</span> String(<span class="string">&quot;H2&quot;</span>);</span><br><span class="line"> <span class="number">48</span> </span><br><span class="line"> <span class="number">49</span>         <span class="comment">// 新建 WeakHashMap对象，并将w1,w2添加到 WeakHashMap中</span></span><br><span class="line"> <span class="number">50</span>         Map wmap = <span class="keyword">new</span> WeakHashMap();</span><br><span class="line"> <span class="number">51</span>         wmap.put(w1, <span class="string">&quot;w1&quot;</span>);</span><br><span class="line"> <span class="number">52</span>         wmap.put(w2, <span class="string">&quot;w2&quot;</span>);</span><br><span class="line"> <span class="number">53</span> </span><br><span class="line"> <span class="number">54</span>         <span class="comment">// 新建 HashMap对象，并将h1,h2添加到 WeakHashMap中</span></span><br><span class="line"> <span class="number">55</span>         Map hmap = <span class="keyword">new</span> HashMap();</span><br><span class="line"> <span class="number">56</span>         hmap.put(h1, <span class="string">&quot;h1&quot;</span>);</span><br><span class="line"> <span class="number">57</span>         hmap.put(h2, <span class="string">&quot;h2&quot;</span>);</span><br><span class="line"> <span class="number">58</span> </span><br><span class="line"> <span class="number">59</span>         <span class="comment">// 删除HashMap中的“h1”。</span></span><br><span class="line"> <span class="number">60</span>         <span class="comment">// 结果：删除“h1”之后，HashMap中只有 h2 ！</span></span><br><span class="line"> <span class="number">61</span>         hmap.remove(h1);</span><br><span class="line"> <span class="number">62</span> </span><br><span class="line"> <span class="number">63</span>         <span class="comment">// 将WeakHashMap中的w1设置null，并执行gc()。系统会回收w1</span></span><br><span class="line"> <span class="number">64</span>         <span class="comment">// 结果：w1是“弱键”，被GC回收后，WeakHashMap中w1对应的键值对，也会被删除。</span></span><br><span class="line"> <span class="number">65</span>         <span class="comment">//w2是“弱键”，但它不是null，不会被GC回收；也就不会被从WeakHashMap中删除。</span></span><br><span class="line"> <span class="number">66</span>         <span class="comment">// 因此，WeakHashMap中只有 w2</span></span><br><span class="line"> <span class="number">67</span>         <span class="comment">// 注意：若去掉“w1=null” 或者“System.gc()”，结果都会不一样！</span></span><br><span class="line"> <span class="number">68</span>         w1 = <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">69</span>         System.gc();</span><br><span class="line"> <span class="number">70</span> </span><br><span class="line"> <span class="number">71</span>         <span class="comment">// 遍历并打印HashMap的大小</span></span><br><span class="line"> <span class="number">72</span>         System.out.printf(<span class="string">&quot; -- HashMap --\n&quot;</span>);</span><br><span class="line"> <span class="number">73</span>         iteratorAndCountMap(hmap);</span><br><span class="line"> <span class="number">74</span> </span><br><span class="line"> <span class="number">75</span>         <span class="comment">// 遍历并打印WeakHashMap的大小</span></span><br><span class="line"> <span class="number">76</span>         System.out.printf(<span class="string">&quot; -- WeakHashMap --\n&quot;</span>);</span><br><span class="line"> <span class="number">77</span>         iteratorAndCountMap(wmap);</span><br><span class="line"> <span class="number">78</span>     &#125;</span><br><span class="line"> <span class="number">79</span> </span><br><span class="line"> <span class="number">80</span>     <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 81      * 通过自定义类测试HashMap和WeakHashMap</span></span><br><span class="line"><span class="comment"> 82      */</span></span><br><span class="line"> <span class="number">83</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compareWithSelfClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="number">84</span>         <span class="comment">// 新建4个自定义对象</span></span><br><span class="line"> <span class="number">85</span>         Self s1 = <span class="keyword">new</span> Self(<span class="number">10</span>);</span><br><span class="line"> <span class="number">86</span>         Self s2 = <span class="keyword">new</span> Self(<span class="number">20</span>);</span><br><span class="line"> <span class="number">87</span>         Self s3 = <span class="keyword">new</span> Self(<span class="number">30</span>);</span><br><span class="line"> <span class="number">88</span>         Self s4 = <span class="keyword">new</span> Self(<span class="number">40</span>);</span><br><span class="line"> <span class="number">89</span>         </span><br><span class="line"> <span class="number">90</span>         <span class="comment">// 新建 WeakHashMap对象，并将s1,s2添加到 WeakHashMap中</span></span><br><span class="line"> <span class="number">91</span>         Map wmap = <span class="keyword">new</span> WeakHashMap();</span><br><span class="line"> <span class="number">92</span>         wmap.put(s1, <span class="string">&quot;s1&quot;</span>);</span><br><span class="line"> <span class="number">93</span>         wmap.put(s2, <span class="string">&quot;s2&quot;</span>);</span><br><span class="line"> <span class="number">94</span>         </span><br><span class="line"> <span class="number">95</span>         <span class="comment">// 新建 HashMap对象，并将s3,s4添加到 WeakHashMap中</span></span><br><span class="line"> <span class="number">96</span>         Map hmap = <span class="keyword">new</span> HashMap();</span><br><span class="line"> <span class="number">97</span>         hmap.put(s3, <span class="string">&quot;s3&quot;</span>);</span><br><span class="line"> <span class="number">98</span>         hmap.put(s4, <span class="string">&quot;s4&quot;</span>);</span><br><span class="line"> <span class="number">99</span> </span><br><span class="line"><span class="number">100</span>         <span class="comment">// 删除HashMap中的s3。</span></span><br><span class="line"><span class="number">101</span>         <span class="comment">// 结果：删除s3之后，HashMap中只有 s4 ！</span></span><br><span class="line"><span class="number">102</span>         hmap.remove(s3);</span><br><span class="line"><span class="number">103</span> </span><br><span class="line"><span class="number">104</span>         <span class="comment">// 将WeakHashMap中的s1设置null，并执行gc()。系统会回收w1</span></span><br><span class="line"><span class="number">105</span>         <span class="comment">// 结果：s1是“弱键”，被GC回收后，WeakHashMap中s1对应的键值对，也会被删除</span></span><br><span class="line"><span class="number">106</span>         <span class="comment">// w2是“弱键”，但它不是null，不会被GC回收；也就不会被从WeakHashMap中删除。</span></span><br><span class="line"><span class="number">107</span>         <span class="comment">// 因此，WeakHashMap中只有 s2</span></span><br><span class="line"><span class="number">108</span>         <span class="comment">// 注意：若去掉“s1=null” 或者“System.gc()”，结果都会不一样！</span></span><br><span class="line"><span class="number">109</span>         s1 = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">110</span>         System.gc();</span><br><span class="line"><span class="number">111</span> </span><br><span class="line"><span class="number">112</span>         <span class="comment">/*</span></span><br><span class="line"><span class="comment">113         // 休眠500ms</span></span><br><span class="line"><span class="comment">114         try &#123;</span></span><br><span class="line"><span class="comment">115             Thread.sleep(500);</span></span><br><span class="line"><span class="comment">116         &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">117             e.printStackTrace();</span></span><br><span class="line"><span class="comment">118         &#125;</span></span><br><span class="line"><span class="comment">119         // */</span></span><br><span class="line"><span class="number">120</span>         </span><br><span class="line"><span class="number">121</span>         <span class="comment">// 遍历并打印HashMap的大小</span></span><br><span class="line"><span class="number">122</span>         System.out.printf(<span class="string">&quot; -- Self-def HashMap --\n&quot;</span>);</span><br><span class="line"><span class="number">123</span>         iteratorAndCountMap(hmap);</span><br><span class="line"><span class="number">124</span> </span><br><span class="line"><span class="number">125</span>         <span class="comment">// 遍历并打印WeakHashMap的大小</span></span><br><span class="line"><span class="number">126</span>         System.out.printf(<span class="string">&quot; -- Self-def WeakHashMap --\n&quot;</span>);</span><br><span class="line"><span class="number">127</span>         iteratorAndCountMap(wmap);</span><br><span class="line"><span class="number">128</span>     &#125;</span><br><span class="line"><span class="number">129</span> </span><br><span class="line"><span class="number">130</span>     <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Self</span> </span>&#123; </span><br><span class="line"><span class="number">131</span>         <span class="keyword">int</span> id;</span><br><span class="line"><span class="number">132</span> </span><br><span class="line"><span class="number">133</span>         <span class="function"><span class="keyword">public</span> <span class="title">Self</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="number">134</span>             <span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="number">135</span>         &#125;</span><br><span class="line"><span class="number">136</span> </span><br><span class="line"><span class="number">137</span>         <span class="comment">// 覆盖finalize()方法</span></span><br><span class="line"><span class="number">138</span>         <span class="comment">// 在GC回收时会被执行</span></span><br><span class="line"><span class="number">139</span>         <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="number">140</span>             <span class="keyword">super</span>.finalize();</span><br><span class="line"><span class="number">141</span>             System.out.printf(<span class="string">&quot;GC Self: id=%d addr=0x%s)\n&quot;</span>, id, <span class="keyword">this</span>);</span><br><span class="line"><span class="number">142</span>         &#125;   </span><br><span class="line"><span class="number">143</span>     &#125;</span><br><span class="line"><span class="number">144</span> &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> -- HashMap --</span><br><span class="line">map entry : H2 - h2</span><br><span class="line">  map size:<span class="number">1</span></span><br><span class="line"></span><br><span class="line"> -- WeakHashMap --</span><br><span class="line">map entry : W2 - w2</span><br><span class="line">  map size:<span class="number">1</span></span><br><span class="line"></span><br><span class="line"> -- Self-def HashMap --</span><br><span class="line">map entry : CompareHashmapAndWeakhashmap$Self@1ff9dc36 - s4</span><br><span class="line">  map size:<span class="number">1</span></span><br><span class="line"></span><br><span class="line"> -- Self-def WeakHashMap --</span><br><span class="line">GC Self: id=<span class="number">10</span> addr=0xCompareHashmapAndWeakhashmap$Self@12276af2)</span><br><span class="line">map entry : CompareHashmapAndWeakhashmap$Self@59de3f2d - s2</span><br><span class="line">  map size:<span class="number">1</span></span><br></pre></td></tr></table></figure>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>熊乾坤</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://super-aviator.github.io/2018/09/22/HashMap%E5%92%8CHashTable%E5%BC%82%E5%90%8C%EF%BC%88%E8%BD%AC%EF%BC%89/">https://super-aviator.github.io/2018/09/22/HashMap%E5%92%8CHashTable%E5%BC%82%E5%90%8C%EF%BC%88%E8%BD%AC%EF%BC%89/</a></span>
                    </p>
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E9%9D%A2%E8%AF%95/"># 面试</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2018/09/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-%E7%AE%97%E6%B3%95/">正则表达式匹配* .算法</a>
            
            
            <a class="next" rel="next" href="/2018/09/18/%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82-Facade-%E6%A8%A1%E5%BC%8F/">设计模式-外观(Facade)模式和最少知识原则</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 熊乾坤 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
