<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="熊乾坤">


    <meta name="subtitle" content="飞行员">


    <meta name="description" content="熊乾坤的博客">



<title>Java并发基础 | 飞行员</title>



    <link rel="icon" href="/images/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 5.4.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">孤独飞行员</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/">Home</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">孤独飞行员</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/">Home</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Java并发基础</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">熊乾坤</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">2021-02-28&nbsp;&nbsp;17:11:58</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Java/">Java</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="线程创建的三种方式"><a href="#线程创建的三种方式" class="headerlink" title="线程创建的三种方式"></a>线程创建的三种方式</h1><ol>
<li>实现Runnable接口</li>
<li>继承Thread类并重写run方法</li>
<li>使用FutureTask方式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 熊乾坤</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-03-13 12:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask=<span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> FutureTaskTest());</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>只有调用Thread类的start方法，才会创建线程，否则是在调用线程中执行run方法；同时调用start方法之后，只是将线程设置为就绪状态，只有获得CPU资源之后才会处于运行状态；</p>
<p><strong>小结：</strong> 继承的方式会收到单继承的限制，但是传参比较方便，内部获取线程直接使用this而无需使用Thread.currentThread方法；而实现Runnable接口则只能使用主线程中被声明为final的变量。如果需要线程返回结果，则使用FutureTask的方式。</p>
<h1 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h1><ul>
<li><p><strong>void interrupt()方法</strong>👀️中断线程，该方法设置线程的中断标识为true并立即返回，但是线程并没有被中断，会继续往下执行。如果线程因为调用了join、sleep、wait系列的函数而被挂起，调用线程的interrupt方法则会抛出InterruptedException异常并返回。</p>
</li>
<li><p><strong>boolean isterrupt()方法</strong> 👀️ 检测线程是否被中断，如果是则返回true，否则返回false.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里传递false表示不清理中断标识</span></span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>boolean interrupted()方法</strong>👀️ 检测当前线程是否被中断，如果是则返回true,否则返回false。该方法如果发现线程被中断，<strong>则会清理中断标识</strong>；该方法是static方法，可以通过Thread类直接调用；该方法是判断<strong>当前线程</strong>的终端标识，而非调用interrupted方法的线程的中断标识。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传入true表示清理中断标识；并且判断的当前线程的中断标识；</span></span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="使用中断使线程优雅退出"><a href="#使用中断使线程优雅退出" class="headerlink" title="使用中断使线程优雅退出"></a>使用中断使线程优雅退出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()&amp;&amp;more work to <span class="keyword">do</span>)&#123;</span><br><span class="line">        <span class="comment">//do more work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">    <span class="comment">//线程被中断</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//进行清理工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JMM-Java-Memory-Model"><a href="#JMM-Java-Memory-Model" class="headerlink" title="JMM(Java Memory Model)"></a>JMM(Java Memory Model)</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><h1 id="synchronize"><a href="#synchronize" class="headerlink" title="synchronize"></a>synchronize</h1><p>synchronize在JDK5.0早期版本中性能远不如ReentrantLock，但从JDK6.0开始，JDK在synchronized上做了大量优化，两者性能相差并不大。</p>
<p><strong>synchronize内存语义：</strong>进入synchronized块时，将块内用到的变量从线程的工作内存中清除,这样在synchronized块内使用到该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取。退出synchronized块时，将块内修改过的变量刷新到内存。</p>
<p>上面的语义其实也是加锁的语义。</p>
<p>synchronized有三种常见用法：</p>
<ul>
<li><strong>指定加锁对象</strong>：给对象加锁，进入临界区前要获取给定对象的锁。</li>
<li><strong>直接作用于示例方法</strong>：相当于对当前实例加锁，进入临界区前要获的当前实例的锁。</li>
<li><strong>直接作用于静态方法</strong>：相当于对类加锁，进入临界区前要获取类的锁。</li>
</ul>
<p>synchronized关键字能够解决原子性、可见性、有序性三个问题，但是当使用synchronzed时如果未获取到锁，则会从用户态切换为系统态并执行阻塞操作，会引起线程上下文切换并带来线程调度开销。</p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>相比于锁或者synchronized的这种比较笨重的方式解决可见性，java还提供了一种弱形式的同步：volatile。volatile可以确保对一个变量的更新立即刷新到主内存。当其他线程读取该共享变量时，会从主内存重新获取最新值。</p>
<p>volatile只提供了可见性、有序性，并不能保证操作的原子性。使用原则如下：</p>
<ul>
<li><strong>写入变量不依赖变量的当前值。</strong>因为如果依赖当前值，将是获取-计算-写入三步操作，而这三部操作不是原子性的，volatile不保证原子性。</li>
<li><strong>读写变量值时没有加锁。</strong>因为加锁已经保证了可见性，不需要再申明为volatile。</li>
</ul>
<h1 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare And Swap）"></a>CAS（Compare And Swap）</h1><p>CAS是JDK提供的非阻塞原子性操作,他通过硬件保证了比较更新操作的原子性。JDK里面的Unsafe类提供了一系列的compareAndSwap＊方法，下面以<code>compareAndSwapLong</code>方法为例进行简单介绍。</p>
<ul>
<li><strong>boolean compareAndSwapLong(Object obj,long valueOffset,long expect,long update）</strong>CAS有四个操作数，分别为：<strong>对象内存位置</strong>、<strong>对象中的变量的偏移量</strong>、<strong>变量预期值</strong>、<strong>新的值</strong>。其操作含义是，如果对象obj中内存偏移量为valueOffset的变量值为expect，则使用新的值update替换旧的值expect。这是处理器提供的一个原子性指令。</li>
</ul>
<p>关于CAS操作有个经典的ABA问题，具体如下：假如线程I使用CAS修改初始值为A的变量X，那么线程I会首先去获取当前变量X的值（为A〕，然后使用CAS操作尝试修改X的值为B，如果使用CAS操作成功了，那么程序运行一定是正确的吗？其实未必，这是因为有可能在线程I获取变量X的值A后，在执行CAS前，线程II使用CAS修改了变量X的值为B，然后又使用CAS修改了变量X的值为A。所以虽然线程I执行CAS时X的值是A，但是这个A己经不是线程I获取时的A了。这就是ABA问题。</p>
<p>ABA问题的产生是因为变量的状态值产生了环形转换，就是变量的值可以从A到B,然后再从B到A。如果变量的值只能朝着一个方向转换，比如A到B,B到C，不构成环形，就不会存在问题。JDK中的<code>AtomicStampedReference</code>类给每个变量的状态值都配备了一个时间戳，从而避免了ABA问题的产生。</p>
<h2 id="通过反射使用Unsafe类"><a href="#通过反射使用Unsafe类" class="headerlink" title="通过反射使用Unsafe类"></a>通过反射使用Unsafe类</h2><p>在Unsafe类的内部，使用类加载器限定了只有Bootstrap类加载器加载的类才能使用Unsafe，所以自己编写的代码无法使用Unsafe，需要使用反射才能使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 熊乾坤</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-03-16 23:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeUse</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明一个待修改的变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field field = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//使用反射拿到Unsafe类的theUnsafe引用</span></span><br><span class="line">        Unsafe unsafe = (Unsafe) field.get(Unsafe.class);</span><br><span class="line">        UnsafeUse unsafeUse = <span class="keyword">new</span> UnsafeUse();</span><br><span class="line">        <span class="keyword">long</span> statusOffset = unsafe.objectFieldOffset(UnsafeUse.class.getDeclaredField(<span class="string">&quot;status&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;CAS结果：&quot;</span> + unsafe.compareAndSwapLong(unsafeUse, statusOffset , <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的值：&quot;</span> + unsafeUse.status);</span><br><span class="line">        <span class="comment">//再测一次CAS失败的情况</span></span><br><span class="line">        System.out.println(<span class="string">&quot;CAS结果：&quot;</span> + unsafe.compareAndSwapLong(unsafeUse, statusOffset , <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的值：&quot;</span> + unsafeUse.status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h1>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>熊乾坤</span>
                    </p>
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E5%B9%B6%E5%8F%91/"># 并发</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/02/28/Java%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88/">Java并发集合</a>
            
            
            <a class="next" rel="next" href="/2021/02/27/%E8%BD%AC%E8%BD%BD-%E5%85%94%E5%AD%90%E7%9A%84%E9%82%80%E8%AF%B7/">转载-兔子的邀请</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 熊乾坤 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
